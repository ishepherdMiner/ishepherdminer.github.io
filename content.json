{"pages":[{"title":"","text":"# 隐私协议 @font-face { font-family: octicons-anchor; src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAYcAA0AAAAACjQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABMAAAABwAAAAca8vGTk9TLzIAAAFMAAAARAAAAFZG1VHVY21hcAAAAZAAAAA+AAABQgAP9AdjdnQgAAAB0AAAAAQAAAAEACICiGdhc3AAAAHUAAAACAAAAAj//wADZ2x5ZgAAAdwAAADRAAABEKyikaNoZWFkAAACsAAAAC0AAAA2AtXoA2hoZWEAAALgAAAAHAAAACQHngNFaG10eAAAAvwAAAAQAAAAEAwAACJsb2NhAAADDAAAAAoAAAAKALIAVG1heHAAAAMYAAAAHwAAACABEAB2bmFtZQAAAzgAAALBAAAFu3I9x/Nwb3N0AAAF/AAAAB0AAAAvaoFvbwAAAAEAAAAAzBdyYwAAAADP2IQvAAAAAM/bz7t4nGNgZGFgnMDAysDB1Ml0hoGBoR9CM75mMGLkYGBgYmBlZsAKAtJcUxgcPsR8iGF2+O/AEMPsznAYKMwIkgMA5REMOXicY2BgYGaAYBkGRgYQsAHyGMF8FgYFIM0ChED+h5j//yEk/3KoSgZGNgYYk4GRCUgwMaACRoZhDwCs7QgGAAAAIgKIAAAAAf//AAJ4nHWMMQrCQBBF/0zWrCCIKUQsTDCL2EXMohYGSSmorScInsRGL2DOYJe0Ntp7BK+gJ1BxF1stZvjz/v8DRghQzEc4kIgKwiAppcA9LtzKLSkdNhKFY3HF4lK69ExKslx7Xa+vPRVS43G98vG1DnkDMIBUgFN0MDXflU8tbaZOUkXUH0+U27RoRpOIyCKjbMCVejwypzJJG4jIwb43rfl6wbwanocrJm9XFYfskuVC5K/TPyczNU7b84CXcbxks1Un6H6tLH9vf2LRnn8Ax7A5WQAAAHicY2BkYGAA4teL1+yI57f5ysDNwgAC529f0kOmWRiYVgEpDgYmEA8AUzEKsQAAAHicY2BkYGB2+O/AEMPCAAJAkpEBFbAAADgKAe0EAAAiAAAAAAQAAAAEAAAAAAAAKgAqACoAiAAAeJxjYGRgYGBhsGFgYgABEMkFhAwM/xn0QAIAD6YBhwB4nI1Ty07cMBS9QwKlQapQW3VXySvEqDCZGbGaHULiIQ1FKgjWMxknMfLEke2A+IJu+wntrt/QbVf9gG75jK577Lg8K1qQPCfnnnt8fX1NRC/pmjrk/zprC+8D7tBy9DHgBXoWfQ44Av8t4Bj4Z8CLtBL9CniJluPXASf0Lm4CXqFX8Q84dOLnMB17N4c7tBo1AS/Qi+hTwBH4rwHHwN8DXqQ30XXAS7QaLwSc0Gn8NuAVWou/gFmnjLrEaEh9GmDdDGgL3B4JsrRPDU2hTOiMSuJUIdKQQayiAth69r6akSSFqIJuA19TrzCIaY8sIoxyrNIrL//pw7A2iMygkX5vDj+G+kuoLdX4GlGK/8Lnlz6/h9MpmoO9rafrz7ILXEHHaAx95s9lsI7AHNMBWEZHULnfAXwG9/ZqdzLI08iuwRloXE8kfhXYAvE23+23DU3t626rbs8/8adv+9DWknsHp3E17oCf+Z48rvEQNZ78paYM38qfk3v/u3l3u3GXN2Dmvmvpf1Srwk3pB/VSsp512bA/GG5i2WJ7wu430yQ5K3nFGiOqgtmSB5pJVSizwaacmUZzZhXLlZTq8qGGFY2YcSkqbth6aW1tRmlaCFs2016m5qn36SbJrqosG4uMV4aP2PHBmB3tjtmgN2izkGQyLWprekbIntJFing32a5rKWCN/SdSoga45EJykyQ7asZvHQ8PTm6cslIpwyeyjbVltNikc2HTR7YKh9LBl9DADC0U/jLcBZDKrMhUBfQBvXRzLtFtjU9eNHKin0x5InTqb8lNpfKv1s1xHzTXRqgKzek/mb7nB8RZTCDhGEX3kK/8Q75AmUM/eLkfA+0Hi908Kx4eNsMgudg5GLdRD7a84npi+YxNr5i5KIbW5izXas7cHXIMAau1OueZhfj+cOcP3P8MNIWLyYOBuxL6DRylJ4cAAAB4nGNgYoAALjDJyIAOWMCiTIxMLDmZedkABtIBygAAAA==) format('woff'); } body { background-color: white; } .markdown-body { min-width: 200px; max-width: 760px; margin: 0 auto; padding: 20px; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; color: #333; overflow: hidden; font-family: \"Helvetica Neue\", Helvetica, \"Segoe UI\", Arial, freesans, sans-serif; font-size: 16px; line-height: 1.6; word-wrap: break-word; } .markdown-body a { background: transparent;;word-wrap: break-word; word-break: break-all; } .markdown-body a:active, .markdown-body a:hover { outline: 0; } .markdown-body strong { font-weight: bold; } .markdown-body h1 { font-size: 2em; margin: 0.67em 0; } .markdown-body img { border: 0; } .markdown-body hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; } .markdown-body pre { overflow: auto; } .markdown-body code, .markdown-body kbd, .markdown-body pre { font-family: monospace, monospace; font-size: 1em; } .markdown-body input { color: inherit; font: inherit; margin: 0; } .markdown-body html input[disabled] { cursor: default; } .markdown-body input { line-height: normal; } .markdown-body input[type=\"checkbox\"] { -moz-box-sizing: border-box; box-sizing: border-box; padding: 0; } .markdown-body table { border-collapse: collapse; border-spacing: 0; } .markdown-body td, .markdown-body th { padding: 0; } .markdown-body * { -moz-box-sizing: border-box; box-sizing: border-box; } .markdown-body input { font: 13px/1.4 Helvetica, arial, freesans, clean, sans-serif, \"Segoe UI Emoji\", \"Segoe UI Symbol\"; } .markdown-body a { color: #4183c4; text-decoration: none; } .markdown-body a:hover, .markdown-body a:focus, .markdown-body a:active { text-decoration: underline; } .markdown-body hr { height: 0; margin: 15px 0; overflow: hidden; background: transparent; border: 0; border-bottom: 1px solid #ddd; } .markdown-body hr:before { display: table; content: \"\"; } .markdown-body hr:after { display: table; clear: both; content: \"\"; } .markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 { margin-top: 15px; margin-bottom: 15px; line-height: 1.1; } .markdown-body h1 { font-size: 30px; } .markdown-body h2 { font-size: 21px; } .markdown-body h3 { font-size: 16px; } .markdown-body h4 { font-size: 14px; } .markdown-body h5 { font-size: 12px; } .markdown-body h6 { font-size: 11px; } .markdown-body blockquote { margin: 0; } .markdown-body ul, .markdown-body ol { padding: 0; margin-top: 0; margin-bottom: 0; } .markdown-body ol ol, .markdown-body ul ol { list-style-type: lower-roman; } .markdown-body ul ul ol, .markdown-body ul ol ol, .markdown-body ol ul ol, .markdown-body ol ol ol { list-style-type: lower-alpha; } .markdown-body dd { margin-left: 0; } .markdown-body code { font: 12px Consolas, \"Liberation Mono\", Menlo, Courier, monospace; } .markdown-body pre { margin-top: 0; margin-bottom: 0; font: 12px Consolas, \"Liberation Mono\", Menlo, Courier, monospace; } .markdown-body kbd { background-color: #e7e7e7; background-image: -webkit-linear-gradient(#fefefe, #e7e7e7); background-image: linear-gradient(#fefefe, #e7e7e7); background-repeat: repeat-x; border-radius: 2px; border: 1px solid #cfcfcf; color: #000; padding: 3px 5px; line-height: 10px; font: 11px Consolas, \"Liberation Mono\", Menlo, Courier, monospace; display: inline-block; } .markdown-body>*:first-child { margin-top: 0 !important; } .markdown-body>*:last-child { margin-bottom: 0 !important; } .markdown-body .anchor { position: absolute; top: 0; bottom: 0; left: 0; display: block; padding-right: 6px; padding-left: 30px; margin-left: -30px; } .markdown-body .anchor:focus { outline: none; } .markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 { position: relative; margin-top: 1em; margin-bottom: 16px; font-weight: bold; line-height: 1.4; } .markdown-body h1 .octicon-link, .markdown-body h2 .octicon-link, .markdown-body h3 .octicon-link, .markdown-body h4 .octicon-link, .markdown-body h5 .octicon-link, .markdown-body h6 .octicon-link { display: none; color: #000; vertical-align: middle; } .markdown-body h1:hover .anchor, .markdown-body h2:hover .anchor, .markdown-body h3:hover .anchor, .markdown-body h4:hover .anchor, .markdown-body h5:hover .anchor, .markdown-body h6:hover .anchor { height: 1em; padding-left: 8px; margin-left: -30px; line-height: 1; text-decoration: none; } .markdown-body h1:hover .anchor .octicon-link, .markdown-body h2:hover .anchor .octicon-link, .markdown-body h3:hover .anchor .octicon-link, .markdown-body h4:hover .anchor .octicon-link, .markdown-body h5:hover .anchor .octicon-link, .markdown-body h6:hover .anchor .octicon-link { display: inline-block; } .markdown-body h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid #eee; } .markdown-body h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid #eee; } .markdown-body h3 { font-size: 1.5em; line-height: 1.43; } .markdown-body h4 { font-size: 1.25em; } .markdown-body h5 { font-size: 1em; } .markdown-body h6 { font-size: 1em; color: #777; } .markdown-body p, .markdown-body blockquote, .markdown-body ul, .markdown-body ol, .markdown-body dl, .markdown-body table, .markdown-body pre { margin-top: 0; margin-bottom: 16px; } .markdown-body hr { height: 4px; padding: 0; margin: 16px 0; background-color: #e7e7e7; border: 0 none; } .markdown-body ul, .markdown-body ol { padding-left: 2em; } .markdown-body ul ul, .markdown-body ul ol, .markdown-body ol ol, .markdown-body ol ul { margin-top: 0; margin-bottom: 0; } .markdown-body li>p { margin-top: 16px; } .markdown-body dl { padding: 0; } .markdown-body dl dt { padding: 0; margin-top: 16px; font-size: 1em; font-style: italic; font-weight: bold; } .markdown-body dl dd { padding: 0 16px; margin-bottom: 16px; } .markdown-body blockquote { padding: 0 15px; color: #777; border-left: 4px solid #ddd; } .markdown-body blockquote>:first-child { margin-top: 0; } .markdown-body blockquote>:last-child { margin-bottom: 0; } .markdown-body table { display: block; width: 100%; overflow: auto; word-break: normal; word-break: keep-all; } .markdown-body table th { font-weight: bold; } .markdown-body table th, .markdown-body table td { padding: 6px 13px; border: 1px solid #ddd; } .markdown-body table tr { background-color: #fff; border-top: 1px solid #ccc; } .markdown-body table tr:nth-child(2n) { background-color: #f8f8f8; } .markdown-body img { max-width: 100%; -moz-box-sizing: border-box; box-sizing: border-box; } .markdown-body code { padding: 0; padding-top: 0.2em; padding-bottom: 0.2em; margin: 0; font-size: 85%; background-color: rgba(0,0,0,0.04); border-radius: 3px; } .markdown-body code:before, .markdown-body code:after { letter-spacing: -0.2em; content: \"\\00a0\"; } .markdown-body pre>code { padding: 0; margin: 0; font-size: 100%; word-break: normal; white-space: pre; background: transparent; border: 0; } .markdown-body .highlight { margin-bottom: 16px; } .markdown-body .highlight pre, .markdown-body pre { padding: 16px; overflow: auto; font-size: 85%; line-height: 1.45; background-color: #f7f7f7; border-radius: 3px; } .markdown-body .highlight pre { margin-bottom: 0; word-break: normal; } .markdown-body pre { word-wrap: normal; } .markdown-body pre code { display: inline; max-width: initial; padding: 0; margin: 0; overflow: initial; line-height: inherit; word-wrap: normal; background-color: transparent; border: 0; } .markdown-body pre code:before, .markdown-body pre code:after { content: normal; } .markdown-body .highlight { background: #fff; } .markdown-body .highlight .mf, .markdown-body .highlight .mh, .markdown-body .highlight .mi, .markdown-body .highlight .mo, .markdown-body .highlight .il, .markdown-body .highlight .m { color: #945277; } .markdown-body .highlight .s, .markdown-body .highlight .sb, .markdown-body .highlight .sc, .markdown-body .highlight .sd, .markdown-body .highlight .s2, .markdown-body .highlight .se, .markdown-body .highlight .sh, .markdown-body .highlight .si, .markdown-body .highlight .sx, .markdown-body .highlight .s1 { color: #df5000; } .markdown-body .highlight .kc, .markdown-body .highlight .kd, .markdown-body .highlight .kn, .markdown-body .highlight .kp, .markdown-body .highlight .kr, .markdown-body .highlight .kt, .markdown-body .highlight .k, .markdown-body .highlight .o { font-weight: bold; } .markdown-body .highlight .kt { color: #458; } .markdown-body .highlight .c, .markdown-body .highlight .cm, .markdown-body .highlight .c1 { color: #998; font-style: italic; } .markdown-body .highlight .cp, .markdown-body .highlight .cs { color: #999; font-weight: bold; } .markdown-body .highlight .cs { font-style: italic; } .markdown-body .highlight .n { color: #333; } .markdown-body .highlight .na, .markdown-body .highlight .nv, .markdown-body .highlight .vc, .markdown-body .highlight .vg, .markdown-body .highlight .vi { color: #008080; } .markdown-body .highlight .nb { color: #0086B3; } .markdown-body .highlight .nc { color: #458; font-weight: bold; } .markdown-body .highlight .no { color: #094e99; } .markdown-body .highlight .ni { color: #800080; } .markdown-body .highlight .ne { color: #990000; font-weight: bold; } .markdown-body .highlight .nf { color: #945277; font-weight: bold; } .markdown-body .highlight .nn { color: #555; } .markdown-body .highlight .nt { color: #000080; } .markdown-body .highlight .err { color: #a61717; background-color: #e3d2d2; } .markdown-body .highlight .gd { color: #000; background-color: #fdd; } .markdown-body .highlight .gd .x { color: #000; background-color: #faa; } .markdown-body .highlight .ge { font-style: italic; } .markdown-body .highlight .gr { color: #aa0000; } .markdown-body .highlight .gh { color: #999; } .markdown-body .highlight .gi { color: #000; background-color: #dfd; } .markdown-body .highlight .gi .x { color: #000; background-color: #afa; } .markdown-body .highlight .go { color: #888; } .markdown-body .highlight .gp { color: #555; } .markdown-body .highlight .gs { font-weight: bold; } .markdown-body .highlight .gu { color: #800080; font-weight: bold; } .markdown-body .highlight .gt { color: #aa0000; } .markdown-body .highlight .ow { font-weight: bold; } .markdown-body .highlight .w { color: #bbb; } .markdown-body .highlight .sr { color: #017936; } .markdown-body .highlight .ss { color: #8b467f; } .markdown-body .highlight .bp { color: #999; } .markdown-body .highlight .gc { color: #999; background-color: #EAF2F5; } .markdown-body .octicon { font: normal normal 16px octicons-anchor; line-height: 1; display: inline-block; text-decoration: none; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .markdown-body .octicon-link:before { content: '\\f05c'; } .markdown-body .task-list-item { list-style-type: none; } .markdown-body .task-list-item+.task-list-item { margin-top: 3px; } .markdown-body .task-list-item input { float: left; margin: 0.3em 0 0.25em -1.6em; vertical-align: middle; } table td{ word-wrap: break-word !important; word-break: break-all !important; } /* github.com style (c) Vasily Polovnyov */ .hljs { display: block; overflow-x: auto; padding: 0.5em; color: #333; background: #f8f8f8; -webkit-text-size-adjust: none; } .hljs-comment, .diff .hljs-header { color: #998; font-style: italic; } .hljs-keyword, .css .rule .hljs-keyword, .hljs-winutils, .nginx .hljs-title, .hljs-subst, .hljs-request, .hljs-status { color: #333; font-weight: bold; } .hljs-number, .hljs-hexcolor, .ruby .hljs-constant { color: #008080; } .hljs-string, .hljs-tag .hljs-value, .hljs-doctag, .tex .hljs-formula { color: #d14; } .hljs-title, .hljs-id, .scss .hljs-preprocessor { color: #900; font-weight: bold; } .hljs-list .hljs-keyword, .hljs-subst { font-weight: normal; } .hljs-class .hljs-title, .hljs-type, .vhdl .hljs-literal, .tex .hljs-command { color: #458; font-weight: bold; } .hljs-tag, .hljs-tag .hljs-title, .hljs-rule .hljs-property, .django .hljs-tag .hljs-keyword { color: #000080; font-weight: normal; } .hljs-attribute, .hljs-variable, .lisp .hljs-body, .hljs-name { color: #008080; } .hljs-regexp { color: #009926; } .hljs-symbol, .ruby .hljs-symbol .hljs-string, .lisp .hljs-keyword, .clojure .hljs-keyword, .scheme .hljs-keyword, .tex .hljs-special, .hljs-prompt { color: #990073; } .hljs-built_in { color: #0086b3; } .hljs-preprocessor, .hljs-pragma, .hljs-pi, .hljs-doctype, .hljs-shebang, .hljs-cdata { color: #999; font-weight: bold; } .hljs-deletion { background: #fdd; } .hljs-addition { background: #dfd; } .diff .hljs-change { background: #0086b3; } .hljs-chunk { color: #aaa; } @media print{ .hljs{overflow: visible; word-wrap: break-word !important;} } 隐私协议 番茄清单(以下简称本应用)尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本应用会按照本隐私权政策的规定使用和披露您的个人信息。但本应用将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本应用不会将这些信息对外披露或向第三方提供。本应用会不时更新本隐私权政策。 您在同意本应用服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本应用服务使用协议不可分割的一部分。 1. 适用范围 (a) 在您使用本应用使用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器和计算机上的信息，包括但不限于您的IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据； (b) 本应用通过合法途径从商业伙伴处取得的用户个人数据。 您了解并同意，以下信息不适用本隐私权政策： (a) 违反法律规定或违反本应用规则行为及本应用已对您采取的措施。 2.信息使用 (a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。 (b) 本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。 (c) 为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。 3. 信息披露 在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息： (a) 经您事先同意，向第三方披露； (b)为提供您所要求的产品和服务，而必须和第三方分享您的个人信息； (c) 根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露； (d) 如您出现违反中国有关法律、法规或者本应用服务协议或相关规则的情况，需要向第三方披露； (e) 如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷； (f) 在本应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，本应用有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。 (g) 其它本应用根据法律、法规或者网站政策认为合适的披露。 4. 信息存储和交换 本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。 5. Cookie的使用 (a) 在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。 (b) 您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。 (c) 通过本应用所设cookies所取得的有关信息，将适用本政策。","link":"/private_protocol.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"☁︎ 标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"搭建Web服务器(nginx)","text":"前言 DNSPod域名解析有一天多都失败了,服务器也宕机了,公众号也没办法获得情况,提示暂时无法服务,不知道出什么问题了,上网查了一下,DNSPod如果解析失败,可以指向另一个备用ip,正好VPS提供独立ip,想尝试在VPS提供的服务器上搭建Web服务器。 Mac自带了apache服务器,考虑换一种服务器来试试,比如nginx。 环境 CentOS release 6.6 (Final)macOS Sierra 10.12.3 流程nginx安装非常简单 配置12$ cd /etc/yum.repos.d/$ vim nginx.repo 因为我不是用root登陆,所以后面创建nginx.repo文件是无法写入目录的,修改一下,前面添加sudo 1$ sudo vim nginx.repo 在新建的nginx.repo文件中,添加 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1 保存后yum.repos.d目录下会出现nginx.repo文件 安装然后执行 1$ sudo yum install nginx -y 启动服务1$ sudo /etc/init.d/nginx start 现在nginx已经启动了，直接访问服务器就能看到nginx欢迎页面了的。 nginx的目录上面的效果图的实际页面在 /usr/share/nginx/html/index.html 我使用的blog引擎是Hexo,它是把blog路径下的public目录的内容提交到服务器,所以先慢慢来,我先把public目录的内容传到远程服务器,测试一下效果 失败1» ~ (npm:0.0.0)scp -i ~/.ssh/id_vps -P xxxx ./public/* Jason@xxx.xxx.xxx.xxx:/usr/share/nginx/html/ 不能传递文件夹 权限问题 成功好吧,先压缩 1» ~ (npm:0.0.0) tar -cvzf blog.tar.gz ./public 权限问题,因为不是root,所以要么修改远程服务器的目录权限,或者是我先把包传到/tmp选择了后者 1» ~ (npm:0.0.0)sudo scp -i ~/.ssh/id_vps -P xxxxx blog.tar.gz Jason@xxx.xxx.xxx.xxx:/tmp 发送成功 到远程目录,解压,复制,粘贴到/usr/share/nginx/html/ 12$ tar -xvf blog.tar.gz$ sudo cp ./public/* /usr/share/nginx/html/ 访问远程服务器 DNSPod刚刚测试了一下,居然已经恢复了,不过没事儿,它恢复它的,我设置我的。 登陆DNSPod官网 选择D监控 选择监控设置(已添加了D监控) 点击修改设置 点击修改按钮 但是没办法点击,我以为是我的操作有问题。在网上找了一下,DNSPOD设置自动切换IP也是这么操作的,看D监控切换规则,也没有提到这一茬。 查看了一下网页源代码 去掉disabled=“disabled”,选中后,界面变成 就能输入了,不知道啥情况,输入远程服务器的ip,点击确定 好吧,看来免费的用户是不允许设置备用ip,文档中也没说明差评。 当然现在这样的体验还不好,还需要用ssh把public目录提交到远程服务器的指定目录,本来sudo hexo d一句话的事情,要变成好几件,略微麻烦些,而且因为域名解析的问题,不能流畅的切换,打算过些时间找到合适的DNS服务器再继考虑。 参考 centos 6.5 nginx安装与配置 D监控切换规则","link":"/2017/02/24/Technology-Building-a-Web-server-by-nginx/"},{"title":"理解HTTPS协议","text":"定义HTTPS*（也称为 *HTTP over TLS ，HTTP over SSL ，和 HTTP Secure ）是用于在因特网上广泛使用的计算机网络上的安全通信的协议。HTTPS 通过 TLS 或其前身的 SSL 实现超文本传输​​协议（HTTP）的安全传输。 在密码学中，加密（英语：Encryption ）是将明文信息改变为难以读取的密文内容，使之不可读。只有拥有解密方法的对象，经由解密过程，才能将密文还原为正常可读的内容。 对称加密 &amp; 非对称加密在现代加密体制主要有两种方式: 对称加密,即在加密与解密的过程中使用相同的加密密钥 (cryptographic keys) 的算法,比如 DES、RC4、AES。 非对称/公开加密,会使用一对密钥，分别命名为公钥与私钥，两个密钥可以互相加解密。外部可以获取公钥，但私钥一般只有所有者才知道。我们最熟悉的非对称加密应该就是 RSA 吧。 优缺点对称加密的缺点主要在于密钥必须双方共享，否则无法实现加解密，只要其中一方(主要指客户端)暴露了密钥，加密过程就不安全了，非对称加密克服了这一点，客户端获得的是服务器的公钥，本来就是公开的，被人获取也不影响。虽然非对称加密有这个好处,但是它的加密的效率比对称加密逊色。所以在 HTTPS 中两者都被使用到了。认证过程采用了非对称加密，而实际数据的传输使用了对称加密。 非对称加密的用途 公钥加密 + 私钥解密 用于通信加密私钥加密 + 公钥解密 用于身份认证 因此服务器用私钥加密的内容，只要持有公钥，都是可以解密的 SSL 握手流程 图片来自wiki - 传输层安全协议，描述的是 SSL 的握手流程。 协商加密算法 客户端发送 ClientHello 消息，包含支持的协议版本，加密和压缩算法等，一个客户端生成的随机数 RNc。 服务器收到 ClientHello 消息后，发送 ServerHello 确定要采用的协议版本，加密和压缩算法等，同时生成一个随机数 RNs。 RNc 与 RNs 将用于参与后面的 生成对称加密密钥 过程 交换证书 关于证书，在此处可理解为一种身份认证的方式，后面说明 服务器会发送证书(包含自身的公钥)发送给客户端，并要求客户端证书 客户端会校验服务器发送的证书是否可信，如果不可信，则关闭连接，若可信，继续执行 客户端会发送证书(包含自身的公钥)到服务器，这在双向认证时要求，一般情况下只要发送随机生成的公钥即可，主要还是要确认服务器是安全可信的。 服务器检验客户端证书，获得公钥，继续执行 客户端会将刚才发送的信息进行 hash 并用自己的私钥进行加密/签名， 服务器接收后会用得到的客户端的公钥先解密并用相同的算法进行 hash 比较结果 最后的两步，我不确定用途，只能揣测是为了证明服务器已经收到了客户端的公钥同时算法都没有问题。 生成对称加密密钥在RFC 2246 - The TLS Protocol Version 1.0 中,有如下的一段话 7.4.7.1. RSA encrypted premaster secret message…Structure of this message: struct { ProtocolVersion client_version; opaque random[46]; } PreMasterSecret; client_version The latest (newest) version supported by the client. This is used to detect version roll-back attacks. Upon receiving the premaster secret, the server should check that this value matches the value transmitted by the client in the client hello message. random 46 securely-generated random bytes. 因此 pre master key 的结构为 2 字节协议版本，匹配客户端一开始发送 ClientHello 时所提供的信息，46 字节随机数。它的作用是为了与协商加密算法阶段中随机生成的两个数 RNc 和 RNs 组合，最终生成本次会话中用于对称加密的密钥( Master secret )。 Generate a master secret from the premaster secret and exchanged random values. 客户端生成 pre master key，并通过服务器的公钥加密后发送给服务器 服务器用自己的私钥解密，双方现在都有 pre master key + RNc + RNs 客户端与服务器使用相同的算法将 pre master key + RNc + RNs 各自进行计算，生成 Master secret 客户端通知服务器接下来的通信用 Master secret 做为对称加密的密钥，结束 SSL 握手通信 服务器收到消息后，同样发送消息到客户端，确认使用 Master secret 为对称加密的密钥，结束 SSL 握手通信。 数字证书为什么在 HTTPS 会话中要用到数字证书？ 我们看到交换证书的过程中服务器发送的证书中包含了它的公钥，试想如果有不怀好意的中间人拦截了请求，与客户端协商了加密的算法，接收 RNc 并发送 RNs ,然后将自己的公钥发送给客户端。客户端不做校验就接收了，那后面的整个过程都是不安全的。所以需要一个凭证让客户端来验证这个公钥是不是属于与其通信的服务器。 数字证书就充当了这个提供凭证的角色 定义在wiki-电子证书中表明了数字证书并非数字身份证，而是身份认证机构盖在数字身份证上的一个章或印（或者说加在数字身份证上的一个签名），这一行为表示身份认证机构已认定这个持证人。 栗子打开钥匙串，查看一个数字证书 CACA (certificate authority) 就是一个提供身份认证的机构，为什么信任 CA*，证书的信任是链式的向上传递。在 *mac 上开发者证书的信任问题最终会走到苹果的根证书上，因为我们信任了这个证书，所以后面苹果服务器( CA )签名的证书我们也会信任。 而对于 12306 网站浏览器之所以会弹出 同样是因为系统不信任 12306 的根证书 SRCA ,所以由它签发的 kyfw.12306.cn 证书也是不受信任的。 csr (Certificate Signing request) What is a CSR? A CSR or Certificate Signing request is a block of encoded text that is given to a Certificate Authority when applying for an SSL Certificate. It is usually generated on the server where the certificate will be installed and contains information that will be included in the certificate such as the organization name, common name (domain name), locality, and country. It also contains the public key that will be included in the certificate. A private key is usually created at the same time that you create the CSR, making a key pair. A CSR is generally encoded using ASN.1 according to the PKCS #10 specification. 我们通过钥匙串创建的 csr 文件会包含了组织名，域名，国家等信息，同时还包含了公钥。在生成 csr 文件时也生成了对应的私钥，保存在钥匙串中。 总结我们平时通过钥匙串通过创建 csr 请求文件的行为，实际上是将自身信息和生成的公钥放到其中，发送给苹果服务器后，苹果服务器会使用自己的私钥对其进行签名，生成 cer 文件，我们下载到客户端，客户端发现该证书是可信的，就从钥匙串中找到并与它的私钥一起进行配置。 苹果服务器在这个场景下实际充当了 CA 的角色，若是服务器本身自己做 CA 进行签名也是可以的，这种情况下称为自签名，但是在 HTTPS 的会话中对证书进行校验时一般会失败，客户端需要操作信任该证书。 到这里，大致可以总结出数字证书的产生过程 在 HTTPS 协议中，客户端的证书验证与上面的场景类似，服务器预先从 CA 那获得数字证书，当客户端要求证书时，将该证书返回给客户端，只要客户端信任 CA , 就可以通过 CA 的公钥解密出服务器发来的证书( CA 用私钥签名服务器的一些信息与公钥)，从而得到公钥，同时判定公钥是来自服务器的。 但是这里有一个问题，如果中间人也请求了 CA 生成了对应的证书，客户端依然无法确定公钥是来自服务器的，还有是否有被修改。 参考 也许，这样理解HTTPS更容易 这篇文章可知，要由客户端负责去校验证书是否合法。 具体方式是客户端得到证书后，根据证书的内容(比如说服务器域名)和算法，客户端再生成一遍签名的过程，然后与证书编号进行比较，因为每个证书的编号应该是唯一的，所以中间人不能创建一个和原证书内容不同，然后编号却相同。如果出现了，那也是算法出的问题，不是设计思路有漏洞。因此客户端可以通过这种方式验证当前获得的证书是否符合要求。从而得到属于服务器的公钥，接着再继续 HTTPS 会话。 实践现在来动手操作，通过 Wireshark 捕获 HTTPS 请求来验证整个流程。如果直接手动打开 Wireshark 然后尝试捕获 eth0 网卡，可能会报权限不足的方法。简单的方法就是用终端直接 sudo Wireshark 打开 因为网络的信息非常多，需进行过滤 tcp.srcport == 443 or tcp.dstport == 443 我们只关注走 443 端口的 tcp 协议 访问 https://www.baidu.com 出现了 Client Hello , Server Hello 等 info 依次到里面看看 [实践]Client Hello 协议版本 tls 1.2 (0x0303) 2 个字节 随机数 RNc : 27ca27… 客户端支持的加密方式 : TLS_EMPTY_RENEGOTIATION_INFO_SCSV 0x00ff… Extension : server_name 下有 www.baidu.com [实践]Server Hello 服务器确定了协议版本号,生成了 RNs，确定了加密的方法 [实践]证书交换 服务器将包含自己公钥的数字证书发送给客户端 客户端验证证书通过后，将发送公钥给服务器 [实践]生成对称加密密钥双方互相通知对方，准备用加密算法对数据加密了，同时结束握手通信 但是好像少了 SSL 中所谈到的生成对称密钥的过程额 Google 搜索后发现在TLS Extended Master Secret, Breaking SSL Proxies提到了 Before extended master secret extension was introduced, parties communicating under TLS protocol (RFC 5246) would compute master secret with the following formula:master_secret = PRF(pre_master_secret, “master secret”, ClientHello.random + ServerHello.random) [0..47]; 在RFC 5246 中 Master secret 确实是使用 pre master secret + ClientHello.random + ServerHello.random 计算生成的，但是在 RFC 7627中描述了一种攻击。 C sends a “ClientHello” to A, and A forwards it to S. S sends a “ServerHello” to A, and A forwards it to C. S sends a “Certificate”, containing its certificate chain, to A. A replaces it with its own certificate chain and sends it to C. S sends a “ServerHelloDone” to A, and A forwards it to C. C sends a “ClientKeyExchange” to A, containing the “pre_master_secret”, encrypted with A’s public key. A decrypts the “pre_master_secret”, re-encrypts it with S’s public key, and sends it on to S. C sends a “Finished” to A. A computes a “Finished” for its connection with S and sends it to S. S sends a “Finished” to A. A computes a “Finished” for its connection with C and sends it to C. 被攻击的主要原因是 Master Secret 只依赖于 ClientHello.random , ServerHello.random ,解决方案是把证书和会话的信息都参与到 Master Secret 的生成过程 扩展类型为0x0017的扩展主密钥向客户端和服务器通知使用以下公式生成主密钥： master_secret = PRF(pre_master_secret, “extended master secret”, session_hash) [0..47]; 通过总结与实践尝试，我对 HTTPS 协议的认识又深刻了一点 That’s all 参考 wiki - HTTPS wiki - TLS wiki - 加密 TLS Handshake Protocol Premaster Secret RFC 2246 - The TLS Protocol Version 1.0 Certificate authority TLS Extended Master Secret, Breaking SSL Proxies Man-in-the-middle attack","link":"/2017/03/21/Technology-Analysis-of-Https-protocol/"},{"title":"自动化Git提交","text":"目标 在每天的固定时间自动将今天修改的本地仓库提交到github,算是提高生产力的一种方式吧。 shell脚本 首先要了解手工提交的时候执行的操作步骤 commite_repo.sh commite_repo.sh用于提交本地仓库到github 12345678910111213141516171819202122232425262728293031#!/bin/bashDATE=$(date +%s)# 要提交到github的工程名称CheckList=('Daily_knowledge_set','Daily_sh_set','Daily_ui_objc_set','Daily_ui_set','Daily_modules','Daily_leetcode_set')TARGET=\"你的本地仓库地址\"# echo ${DATE}cd ${TARGET}for file in ${TARGET}/*do cd ${file} echo ${file##*/} git remote -v | grep fetch | awk '{print $2}' | git pulldonefor file in ${TARGET}/*doif echo \"${CheckList[@]}\" | grep -w ${file##*/} &amp;&gt;/dev/null; then cd ${file} # echo ${file} git status | grep \"nothing to commit\" &gt; /dev/null 2&gt;&amp;1 if [ $? != 0 ]; then echo \"提交新的Commit:\"${file##*/}_${DATE} git add . git commit -m ${file##*/}_${DATE} git push else echo \"没有更改:\"${file##*/} fifidone 提交博客到github 123» ~ ~/.blog_ssh-add.sh» ~ sudo hexo g» ~ sudo hexo d ~/.blog_ssh-add.sh是为了解决因为ssh的证书不是默认的id_rsa,每次重启Mac提交博客,hexo都会报公钥错误的问题。 剩下两个是生成静态博客与部署到github的指令 因为使用了sudo,其中有一个密码验证的过程,在Hexo提交出现Permission denied (publickey)已经使用过expect来解决了,照葫芦画瓢写了如下脚本 exec_hexo.sh1234567891011#!/usr/local/bin/expect -fspawn sudo hexo gexpect \"Password:\"send \"你的密码\\n\"interactspawn sudo hexo dexpect \"Password:\"send \"你的密码\\n\"interact 再创建一个脚本去执行上面的两个脚本 schedule_commit_rep.sh123456789101112131415#!/bin/bashexport PATH=脚本存放路径:$PATHrepo_path=\"你的本地仓库地址\"blog_path=\"你的本地博客地址\"# 提交本地仓库cd ${repo_path}commit_repo.sh# 提交blogcd ${blog_path}~/.blog_ssh-add.shexec_hexo.sh 执行效果 现在脚本已经准备好了,需要做的是加入定时任务 crontab根据这篇文章OSX系统添加定时任务,可知macOS添加定时任务至少有两种方法,虽然作者推荐用launchctl, 这个是通过plist配置的方式来实现定时任务的，其优点就是最小时间间隔是一秒 但是这个优点在现在这个场景下并不重要,而且配置上比直接用crontab麻烦一些,因此还是选择用crontab来创建定时任务。 1234» ~ sudo crontab -ePassword:crontab: no crontab for root - using an empty onecrontab: installing new crontab 进入创建新的计划任务的页面,并设置成每分钟都执行 1* * * * * /bin/bash 脚本路径/.schedule_commit_rep.sh 等了好几分钟,似乎什么都没有发生,又找了两篇文章,说明了crontab的原理是 当用户使用crontab命令新建任务计划之后，该项 jobs 就会被 /var/spool/cron/ 目录下，而且以用户账号来创建一个文件，每一项任务计划为一行。 crond 检测的时间周期是 “分钟”， 每分钟会读取一次 /etc/crontab， 以及 /var/spool/cron 里面的记录并执行。 crond 执行的每一项任务计划，都会被记录到 /var/log/cron 这个日志文件。 另一篇说明的是在macOS上如何启用crontab,macOS*上默认没有/etc/crontab文件,用sudo touch /etc/crontab创建,等了几分钟后依然没有,查看了并没有spool/cron目录,在/var/log也没有*cron,macOS上的crontab与一般Linux上差别还是有点大。 搜索下stackoverflow,感觉比较近的is crontab broken on OSX El Capitan?, 指定编辑器?我使用crontab -l已经能看到了添加的计划任务了,感觉不太符合我的情况 我尝试了一下 1*/5 * * * * date &gt;&gt; /tmp/z.date 确实是生成了,但是觉得并不能解决我的问题。好吧,换个思路吧,既然在macOS上推荐用launchctl,那就换个思路用它吧 launchctlcd到家目录下的Library/LaunchAgents 1» ~ cd /Users/Jason/Library/LaunchAgents 创建定时任务的plist描述文件,比如com.jason.launchctl.plist 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;com.jason.launchctl.plist&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;脚本路径.sh&lt;/string&gt; &lt;/array&gt; &lt;key&gt;StartCalendarInterval&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Minute&lt;/key&gt; &lt;integer&gt;30&lt;/integer&gt; &lt;key&gt;Hour&lt;/key&gt; &lt;integer&gt;22&lt;/integer&gt; &lt;/dict&gt; &lt;key&gt;StandardOutPath&lt;/key&gt;&lt;string&gt;脚本执行输出日志路径.log&lt;/string&gt;&lt;key&gt;StandardErrorPath&lt;/key&gt;&lt;string&gt;脚本执行错误日志路径.err&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; 参考以下指令启动定时任务 12345launchctl load com.jason.launchctl.plistlaunchctl unload com.jason.launchctl.plistlaunchctl start com.jason.launchctl.plistlaunchctl stop com.jason.launchctl.plistlaunchctl list 要让任务生效，必须先load命令加载这个plist 如果任务呗修改了，那么必须先unload，然后重新load start可以测试任务，这个是立即执行，不管时间到了没有 执行start和unload前，任务必须先load过，否则报错 stop可以停止任务 ProgramArguments内不能直接写命令，只能通过shell脚本来执行 用load,然后用start直接执行一下 已经在执行了,终于可以了。 但是发现提交博客输入密码那步停了,修改plist只执行提交blog*的那一步,发现.err*有内容,打开 我先试试把interact注释看影响操作不。 尝试后发现会影响,搜索后没有发现比较满意的解决方案,如何用expect配合launchctl实现定时任务,即该任务要自动输入密码? 我以为是zsh终端的关系,换成bash在终端下执行也没有问题,而用launchctl执行配置文件不管是bash还是zsh都一样报错。 解决方案用写的脚本提交博客与本地工程,虽然无法定时的自动执行,但与以前相比效率还是稍微提高了一些的😔。 参考 OSX系统添加定时任务 在MAC OS X上如何启用crontab crontab 与 crond mac os 定期任务配置 is crontab broken on OSX El Capitan? Mac crontab: Mac OS X startup jobs with crontab, er, launchd","link":"/2017/02/25/Technology-Automated-Git-Submitted/"},{"title":"Charles HTTP抓包原理","text":"前言: Web代理服务器 来自参考链接2 对客户端/浏览器来说Web代理服务器是服务器对服务器来说Web代理服务器是客户端 环境 WireSharkCharlesmacOS 10.13.6 解释根据参考链接1中的这段话 Web proxy serversWeb proxies forward HTTP requests. The request from the client is the same as a regular HTTP request except the full URL is passed, instead of just the path.[17] GET http://en.wikipedia.org/wiki/Proxy_server HTTP/1.1Proxy-Authorization: Basic encoded-credentialsAccept: text/html Web代理服务器在转发HTTP请求时与正常的HTTP是一样的,除了请求头某个字段要传递全路径(full URL)而不是简单的路径(path)。继续追踪,通过rfc7230,就能知道这个这个字段就是absolute-form。 为什么会有这个变化呢? 原来只要传路径是因为,服务器知道自己的host是什么,但是代理服务器是充当了客户端的服务器后,我们必须要告诉代理服务器,接下去要访问谁,光提供路径是不够的。 证明准备iTerm ping Blog的域名,获得ip 1234% sudo ping www.iosugar.comPING ishepherdminer.github.io (185.199.111.153): 56 data bytes64 bytes from 185.199.111.153: icmp_seq=0 ttl=52 time=141.981 ms... 打开 WireShark 监听 en0 网卡,当前状态下就是无线网卡 设置过滤条件http and ip.addr == 185.199.111.153 未设置代理Chrome直接访问www.iosugar.com 设置代理手机设置代理,用Safari访问 过滤条件设置为 http and ip.addr == 185.199.110.153 or ip.dst == 192.168.31.191 其中192.168.31.191是计算机的地址 参考 Web_proxy_servers Thick Client Proxying - Part 6: How HTTP(s) Proxies Work rfc7230","link":"/2019/01/09/Technology-Charles-capture-principle/"},{"title":"CentOS远程登陆SSH配置","text":"前言 最近抛弃了原来的VPN,转而购买了VPS,配置也挺简单,已经提供了在浏览器上提供shell入口的方式,但是还是想简单记录下关于SSH远程登陆的流程(毕竟还是要打开浏览器,没终端方便,而且速度也慢),虽然网上这方面的博客很多,但是纸上得来终觉浅,还是想自己动手记录一下。 环境 CentOS release 6.6 (Final)macOS Sierra 10.12.3 流程 在Google上查找CentOS的ssh配置方法,经过一番搜索与比较,还是官方的wiki更好一些 文档中有 提示我们不要用root账户远程ssh登陆,因此需要创建用户 创建新用户创建新用户的指令为adduser,先看看adduser指令的用法 1$ &gt; adduser --help 创建一个名为Jason的用户 1$ &gt; adduser -m Jason 为新用户重新设置密码 1$ &gt; passwd Jason 输入新密码,确认,密码设置成功。关于密码的安全性,正好参考第一步 配置sshd_config文件然后根据文档操作/etc/ssh/sshd_config文件 禁止root用户SSH登陆 =&gt; PermitRootLogin no 允许指定用户使用SSH登陆 =&gt; AllowUsers alice bob 使用SSH 2.0 =&gt; Protocol 2 修改SSH登陆端口 Port 12345 因为远程服务器环境是CentOS 6.6而且也没有并没有selinux(提示找不到该指令semanage),如果有的话照着操作。 重启sshd服务 1$ &gt; service sshd restart 尝试ssh远程登陆 1$ &gt; ssh -p 指定端口号 用户名@服务器ip 提示添加远程服务器的指纹信息 输入密码 成功登陆远程主机 进一步配置 上面那些都应该没有问题,但是每次登陆都要输入密码,略麻烦,用证书认证的方式去替代密码。 在远程服务器的/etc/ssh/sshd_config By default, ssh will first try to authenticate using keys. If no keys are found or authentication fails, then ssh will fall back to conventional password authentication. 会优先选择证书认证的方式 照着文档进行操作吧 在客户端(macOS)上生成钥匙对(公钥 &amp; 私钥) 1$ &gt; ssh-keygen -t rsa 我将证书命名为id_vps,指令操作后会生成id_vps和id_vps.pub,分别代表着私钥和公钥 密码留空,如果不留空,后面ssh还是要输入证书的密码 修改私钥的权限为仅所有者可读可写 1$ &gt; chmod 600 id_vps 需要复制公钥到服务器然后写入到~/.ssh/authorized_keys 使用SSH*远程登陆到服务器,发现家目录中还没有.ssh目录,使用mkdir*创建 1$ &gt; mkdir .ssh 发送公钥 1$ &gt; scp -P 端口号 ./id_vps.pub Jason@服务器ip:/home/Jason/.ssh 在远程服务器上使用ls,确定公钥已经发送成功了 将公钥追加写入~/.ssh/authorized_keys中,若authorized_keys不存在,则会创建并写入 1$ &gt; cat id_vps.pub &gt;&gt; ~/.ssh/authorized_keys 同样修改authorized_keys的权限为600,并删除公钥文件,结果如下 用ssh-copy-id可以更方便一些 添加用户到sudoers此时使用SSH*远程登陆,还是不行的,因为在/etc/ssh/sshd_config配置文件中,还是使用密码方式进行认证的,为了能修改/etc/ssh/sshd_config同时为了以后操作的能方便些,将Jason添加到/etc/sudoers*中 以下摘自CentOS下添加sudo用户 在使用sudo的时候，如果出现”xxx is not in the sudoers file. This incident will be reported”说明当前用户名：xxx是没有权限使用sudo的，这个时候我们就需要修改/etc/sudoers来为当前用户xxx添加sudo权限。 使用 “su –” 命令，进入超级用户，进入etc目录 “cd /etc” 为sudoers文件添加写入的权限：使用命令 “chmod u+w sudoers” 使用命令“vim sudoers”，按“i”进入编辑模式后，找到“rootALL=(ALL) ALL ”，在后面添加：”xxxALL=(ALL) ALL”(这里的xxx是你的用户名)，再按一下“Esc”键退出编辑，输入“wq”（write quit）后，退出sudoers。 输入“chmod u-w(v) sudoers”将文件的写入属性撤销 通过“su xxx”切换回自己的用户名，再使用sudo命令时，就可以使用了 在/etc/ssh/ssh_config将密码认证方式的yes修改为no SSH登陆远程登陆 报错 1Permission denied (publickey,gssapi-keyex,gssapi-with-mic). 应该是证书的问题,但是感觉操作都没问题,与官方的步骤不同的是证书的名称 ssh*加上-v*参数打印出详细过程 1$ &gt; ssh -vp xxx Jason@服务器ip 如果我不指定,默认找~/.ssh/id_rsa所以肯定会失败 加上-i参数 1$ &gt; ssh -vp xxx -i ~/Jason/.ssh/id_vps Jason@服务器ip 登陆成功 原理SSH为什么安全?公钥加密 根据SSH原理与运用（一）：远程登录 整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。 中间人攻击伪造远程主机,根据ssh登陆流程用户会把登陆密码用伪造的远程主机提供的公钥进行加密,密码自然就泄露了 authorized_keys文件有什么用?在指令ssh的man手册中有如下语句 The file ~/.ssh/authorized_keys lists the public keys that are permitted for logging in. When the user logs in, the ssh program tells the server which key pair it would like to use for authentication. The client proves that it has access to the private key and the server checks that the corresponding public key is authorized to accept the account. authorized_keys的文件保存着可以登陆的用户的公钥,在ssh登陆时,在经过建立连接,协商加密算法等过程后,客户端会提供私钥由服务器检查是否能匹配相应的公钥(可能是提供一段内容,由客户端私钥加密,然后看服务器的authorized_keys中的公钥能否解开) 参考 CentOS下添加sudo用户 SSH原理与运用（一）：远程登录 SecuringSSH","link":"/2017/02/14/Technology-CentOS-remote-login-SSH-configuration/"},{"title":"FFmpeg学习笔记01(环境搭建)","text":"前言 学习FFmpeg 环境 macOS Sierra 10.12.3Xcode 8.2.1FFmpeg 3.2 是什么? 一个用于录制,转换和流式传输音频和视频的完整的跨平台解决方案。 可通过git方式下载源码 git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg 流程 网上搜索了一下,关于FFmpeg的编译主要有两种 方案一 通过FFmpeg-iOS-build-script,来输出arm*架构下的.a*文件,比较旧的用iFrameExtractor,原理类似。 方案二 根据这篇用xcode调试FFmpeg的方法,但是这样只能在Mac上运行和调试,如果用file指令会知道发现可执行文件的架构是x86_64的。 我的尝试 有没有办法在Xcode的iOS项目中直接编译FFmpeg工程? 先说结果,目前没有做成功 阅读FFmpeg-iOS-build-script的build-ffmpeg.sh脚本脚本前面下载源码及依赖脚本的部分,就不说了 最后的configure指令形式大概是这样的 1./configure --target-os=darwin --arch=arm64 --cc=\"xcrun -sdk iphoneos clang\" --enable-cross-compile --disable-debug --disable-programs --disable-doc --enable-pic --extra-cflags=\"-arch arm64 -mios-version-min=6.0 -fembed-bitcode\" --extra-ldflags=\"-arch arm64 -mios-version-min=6.0 -fembed-bitcode\" --prefix=/Users/Jason/Desktop/thin 指定了架构,编译器类型,最低版本等信息,make*编译,.o*文件也可以正常产生。 1find ./* -name \"*.o\" 通过查看编译了哪些.o,尝试找出源码中的哪些.c*是参与编译的。主要是几个库中的.c*文件参与了编译。 Xcode编译指令用Xcode编译流程可通过下图方式获知 编译一个ViewController.m的指令 主要思路是把生成.a静态库的源文件,拷贝到工程中,然后编译的时候都用clang,只要保证编译的参数一致,应该是能过的。 最后说说卡在哪儿了吧,遇到*&lt;OpenCL/cl.h&gt;头文件没有找到,Xcode中找不到,用find指令在Xcode的mac SDK上倒是有查找,我现在不太清楚是不是因为这个原因导致,网上找到的结果都是编译成.a形式的,然后能调试的都是在mac*平台下的,如果有懂的,请告诉我。 我的解决方案对于目前来说,是出于学习的目的,所以打算整3个Xcode工程 编译FFmpeg的静态库工程,FFmpeg-iOS-build-script 引用了静态库的iOS应用的工程,偏应用方面的,比如怎么使用FFmpeg的API来实现音视频编码解码之类的 FFmpeg源码可调式命令行工程,用于调试研究FFmpeg的底层实现 编译静态库工程12345678git clone https://github.com/kewlbear/FFmpeg-iOS-build-script# 编译./build-ffmpeg.sh # 合并./build-ffmpeg.sh lipo 引用静态库工程使用引用方式将编译后的FFmpeg-iOS目录(包含静态库和头文件)添加到工程中 根据当前目录结构给Build Settings中的Library Search Paths,添加 1$(PROJECT_DIR)/../FFmpeg-iOS-build-script/FFmpeg-iOS/lib 指向静态库的路径 引用依赖的动态库 libz.dylib libbz2.dylib libiconv.dylib 添加kxmovie工程,一个基于FFmpeg的播放器 git下工程,并将kxmovie目录拖拽并复制到工程中,因为目录中有pch文件, 简单在Main.storyboard中添加一个导航控制器,并在工程的根控制器添加如下代码 123456789#import \"KxMovieViewController.h\"...- (void)viewDidLoad { [super viewDidLoad]; ViewController *vc; NSString *path = @\"\"; vc = [KxMovieViewController movieViewControllerWithContentPath:path parameters:nil]; [self presentViewController:vc animated:YES completion:nil];} 在Build settings的Prefix Header,添加如下字段,指向pch文件 1Learn-FFmpeg/kxmovie/kxmovie-Prefix.pch ⌘ + B 提示 头文件路径的问题,同样在Build Settings的Header Search Paths添加 1$(PROJECT_DIR)/../FFmpeg-iOS-build-script/FFmpeg-iOS/include ⌘ + B 提示 上面两个直接根据提示修改,下面那个,根据iOS编译FFmpeg、kxmovie实现视频播放将其注释 ⌘ + B 提示 添加VideoToolbox.framework即可 ⌘ + B 成功 修改代码,设置path为本地音频地址 1234ViewController *vc;NSString *path = @\"http://192.168.5.101/~Jason/TestMusic.mp3\";vc = [KxMovieViewController movieViewControllerWithContentPath:path parameters:nil];[self presentViewController:vc animated:YES completion:nil]; 顺便设置info.plist以支持http访问 1234&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;&lt;true/&gt;&lt;/dict&gt; 截图 视频截图 源码工程参考用xcode调试FFmpeg的方法链接即可,在一些小地方注意一下即可,比如第一步生成ffmpeg_g*可执行文件–disable-optimizations &amp;&amp; make -j3,取消优化,不然调试的时候很多变量值无法输出,-j参数是job*是编译的线程数的意思 设置断点,调试FFmpeg 最终目录结构 最终工程结构 DEMO Update 170309因为FFmpeg-iOS-build-script没有添加到git中管理,整个目录文件,将近1个G,太大了,没有提交,简单写了个脚本来处理 123456789101112#!/bin/shversion=3.2if [ ! -d \"./FFmpeg-iOS-build-script\" ]; then git clone https://github.com/kewlbear/FFmpeg-iOS-build-script cd ./FFmpeg-iOS-build-script ./build-ffmpeg.sh ./build-ffmpeg.sh lipo cd ffmpeg-${version} ./configure --disable-optimizations &amp;&amp; make -j3fi 参考 FFMPEG – 編譯 ffmpeg library for iOS llvm - UsersManual Build Settings中的变量@rpath,@loader_path,@executable_path Xcode Build Search Paths设置 FFmpeg框架在iOS平台上的编译和使用 FFmpeg-user Need to debug the ffmpeg with gdb –enable-debug=3 FFmpeg-iOS-build-script","link":"/2017/03/06/Technology-FFmpeg-study-notes-01-environmental-building/"},{"title":"FFmpeg指令-视频截取","text":"场景 sdk 需要视频素材,我自己找的视频素材太大不能作为素材资源(150K以内)。 操作 记得 FFmpeg 能处理,用 man 查了下，当时写文档的人还真是很讲究。比如下面的图 文档太长，还是 –help 吧 1usage: ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}... 指令执行格式为 ffmpeg + 参数 + 输入文件参数 + -i 输入文件 ... 输出文件参数 输出文件,中括号表示可选，大括号代表必选。当前要做的是要截取一段时间。 12345678910111213-t duration record or transcode \"duration\" seconds of audio/video-t duration (input/output) When used as an input option (before \"-i\"), limit the duration of data read from the input file. When used as an output option (before an output url), stop writing the output after its duration reaches duration. duration must be a time duration specification, see the Time duration section in the ffmpeg-utils(1) manual. -to and -t are mutually exclusive and -t has priority. -t 在 -i 之前，duration 该用什么格式填写呢? 从 man 中找例子 1ffmpeg -filter_complex 'color=c=red' -t 5 out.mkv 生成了 5s 的纯红色的视频 1-ss time_off set the start time offset 设置开始时间的偏移量 到这里如何截取视频应该比较清楚了。试一下 1234ffmpeg -t 5 -ss 0 -i sample_iPod.m4v shot_sample_iPod.m4v -rwxrwxrwx@ 1 Jason staff 2236480 Jun 4 2016 sample_iPod.m4v-rw-r--r-- 1 Jason staff 76820 Apr 21 20:31 shot_sample_iPod.m4v 视频被顺利截成 5s 。 一点感悟 ffmpeg 很强大，看着好像挺麻烦的事情，找到合适的工具，瞬间就轻松不少。一开始没太注意，只知道的是 [] 表示可选的意思，现在又知道了 {} 表示必选，总结，总是会有所收获的。 参考 括号中的可选、必选表示","link":"/2017/04/21/Technology-FFmpeg-video-interception-command/"},{"title":"全角空格在Markdown中的使用","text":"导语 Markdown 是一种轻量级的标记语言。它关注内容而不是样式。因为全角空格在排版上会有一些用处，而且也确实碰到了，因此进行简单的记录。 段首空格 切换到全角状态，输入空格，即可。因为 Markdown 最后还是被 hexo-renderer-marked 转换成 html 。所以也可以使用 &amp;nbsp;、&amp;emsp; 这种转义字符，但是还是全角空格感觉上会更纯粹一些。 空行 123 456 虽然我留了两行，但是显示时 123 与 456 依然只有一行的间隔。 解决方案 设置 margin / padding 使用 &lt;br/&gt; &amp;emsp;、&amp;ensp; 使用全角空格 123 456 That’s all","link":"/2017/04/07/Technology-Full-width-spaces-used-in-Markdown/"},{"title":"Hexo域名绑定","text":"前言出于”折腾”的目的,在使用github+hexo搭建blog*后,将原来.io*的域名绑定为个人申请的域名 准备 域名 DNS服务器 流程当前的需求是将github分配的域名,重新指向给新申请的域名 由上图可知,CNAME能将域名指向另一个提供ip的域名,符合当前的需求、 关于DNS服务器,我选择了DNSPod,它现在可以申请域名,一事不烦二主,所以申请域名我也交给了它。 在控制台 &gt; 域名解析中添加申请成功的域名,比如iosugar.com,然后建立两条dns记录 两者只有主机记录不一样,主要是为了访问www.iosugar.com和iosugar.com效果能一致 访问配置好的新域名,会出现github的404错误,到blog的source目录下,新建CNAME文件,写入www.iosugar.com,hexo d到github上,然后点击工程的setting,可以看到 配置自定义域名已经成功了 等一段时间,访问iosugar.com成功了 注意 dns更新会有延迟,若是要想尽快测试效果,可以将DNSPod的dns域名服务器ip(通过ping指令)添加到本机的dns服务器的查询列表(网络&gt;高级&gt;DNS) 12345678910111213$ ping f1g1ns1.dnspod.netPING f1g1ns1.dnspod.net (180.163.19.15): 56 data bytes64 bytes from 180.163.19.15: icmp_seq=0 ttl=50 time=131.329 ms64 bytes from 180.163.19.15: icmp_seq=1 ttl=50 time=135.907 ms64 bytes from 180.163.19.15: icmp_seq=2 ttl=50 time=133.248 ms64 bytes from 180.163.19.15: icmp_seq=3 ttl=50 time=136.791 ms$ ping f1g1ns2.dnspod.netPING f1g1ns2.dnspod.net (101.226.30.224): 56 data bytes64 bytes from 101.226.30.224: icmp_seq=0 ttl=51 time=58.310 ms64 bytes from 101.226.30.224: icmp_seq=1 ttl=51 time=55.261 ms64 bytes from 101.226.30.224: icmp_seq=2 ttl=51 time=56.218 ms64 bytes from 101.226.30.224: icmp_seq=3 ttl=51 time=65.365 ms 因为使用了自定义的域名,所以在github上搭建的blog无法支持https 参考 我的博客是如何搭建的（github pages + HEXO + 域名绑定） 为部署在Github上的Hexo博客绑定个性域名","link":"/2017/01/01/Technology-Hexo-domain-binding/"},{"title":"Hexo提交出现Permission denied (publickey)","text":"环境说明 macOS Sierra 10.12.1node v6.5.0 问题参考 hexo-doc 搭建好blog后 为部署到github使用如下指令,去安装hexo-deployer-git插件 1$ npm install hexo-deployer-git --save 如果使用ssh-keygen生成RSA证书不选择默认的id_rsa名时,提交有时会报公钥错误 123FATAL Error: Permission denied (publickey). fatal: Could not read from remote repository.... 解决方法步骤 112// adds private key identities to the authentication agent$ ssh-add path/to/rsa_private_key 然后再进行提交 步骤 2原因: 重启后,又会提示该错误 限制: 执行ssh-add会有一个要求输入密码的交互过程 brew安装 expect 1$ brew install homebrew/dupes/expect 新建一个shell脚本 命名为 .blog_ssh-add.sh 12345#!/usr/local/bin/expect -fspawn /usr/bin/ssh-add /Users/Jason/.ssh/github_homeexpect \"Enter passphrase for /Users/Jason/.ssh/github_home:\"send \"111111\\n\\n\" ## 密码interact 添加可执行权限 1$ sudo chmod +x .blog_ssh-add.sh 当报错就会执行~/.blog_ssh-add.sh 会自动输入密码,然后再提交 参考 Shell脚本交互之：自动输入密码 ssh keys ssh-agent bash and ssh-add Automating an ssh connection with crontab How to avoid being asked passphrase each time I push to Bitbucket","link":"/2016/11/24/Technology-Hexo-commit-exists-Permission-denied-publickey/"},{"title":"hexo deploy 命令执行失败","text":"前言很久没写博客,重新恢复写作后,发现hexo deploy 无法推送了,一直报无权限,检查了~/.gitconfig账号是对的,按参考一在~/.ssh/config中加了公钥 按要求eval \"$(ssh-agent -s)\" 1234Host *.github.com AddKeysToAgent yes UseKeychain yes IdentityFile ~/.ssh/whz1992gt_github_home 指定github.com使用该公钥,但是还是失败。 解决方案原来是我以前安装过github后面推出的客户端工具,会在~/.config/gh/config.yml 里面还存着另一个账号,删除后,关闭iTerm还是不行,重启后终于能正常推送了。 参考 generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent","link":"/2022/12/11/Technology-Hexo-push-error/"},{"title":"macOS上如何创建网址快捷方式","text":"导语mac 上装了很多浏览器。因为喜欢 Safari 的 Pin Tab 的功能，所以主力的浏览器选择的是它，但是太多的 Pin Tab 似乎拖累了浏览器的速度，今天要打开苹果开发者后台时，由于网速不给力，最后换成 Firefox 才顺利打开。感觉有必要整理一下。又不想放到收藏夹中，放到那儿，似乎就很难再记起它了。 闲话点到为止即可，讲讲如何制作网址快捷方式，非常简单，只是因为以前没注意过这个角落，因此才考虑花点时间记录一下。 流程 切换到 Safari 浏览器中 移动到地址栏 长按鼠标/触摸板，以拖拽的方式将其移动到目标路径,比如 Finder/Desktop 顺利的话应该会生成类似这样的图标 That’s all","link":"/2017/03/28/Technology-How-to-create-URL-shortcuts-on-macOS/"},{"title":"iTunes Store 不可用 (没解决)","text":"前言最近发现 Mac 上的 iTunes 中的 AppStore 总是无法访问，出现如下三种错误 400 Bad Request 502 Your iTunes Store Session has expired (再次登陆还是报这个错) ) 尝试过下面的方案Clear CookieSafari &gt; 首选项(Preference) &gt; Privacy &gt; Manage Website Data中将 apple.com 的 cookie 删除 失败 重新安装 iTunes安装了 12.6.1.27 失败 重新登陆 Apple ID系统设置 &gt; iCloud 失败 重新安装系统没擦除硬盘,然后重新安装了 10.12.5 失败 申请 Contact Apple Support因为英语口语不好,选择了聊天的方式，边开 google 翻译，边聊，可能聊的不太好，对方的顾问态度很好，当我说出现了 Your iTunes Store Session has expired 问题时,让我检查了时间，系统版本，防火墙的设置，切换网络试试，最后让我进入安全模式试一试(开机按住 shift) 最后还是没有解决。 对方往邮箱中发了一封邮件，我想看看记录的详情 Contact Apple Support 当输入 CaseID 后 下面那个输入框本来没有，既然都是必须输入的，为什么要隐藏起来呢? 也许有其他用处 输入后留了出现了 We're Sorry 和一段 神秘代码 可能要等一段时间才会出现吧。 最后发现在 Apple - 系统状态 提到 不知道和这个有没有关系…… 参考 Apple - 系统状态","link":"/2017/06/25/Technology-ITunes-Store-unavailable-not-resolved/"},{"title":"IntelliJ IDEA Main函数传参","text":"前言 单纯做个记录 程序传参CC程序的入口为main,函数声明一般为 1int main(int argc,char *argv[]); arg是参数缩写,c是count,argc代表外部参数的个数,argv是一个指向字符数组的指针。简而言之外部可以给main传递一个字符串数组,个数由argc确定 Java1public static void main(String[] args) 字符串是个对象,带了长度属性,也就不用再多传一个参数长度了 ShellShell看上去有点不同,但是也很好理解,比如下面的指令 1ls ~/Desktop ls*会被保存在$0*~/Desktop*保存在$1*以此类推 场景在用IntelliJ IDEA调试一段Java代码时,需要在执行时给Main传个参 流程 就这样","link":"/2017/03/12/Technology-IntelliJ-IDEA-main-function-pass/"},{"title":"学习 CocoaAsyncSocket","text":"Socket套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I/O插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是IP地址与端口的组合。 大部分系统都提供了一组基于TCP或者UDP的应用程序编程接口（API），该接口通常以一组函数的形式出现，也称为套接字（Socket) 环境说明 python2.7macOS CatalinaXcode 11.3.1CocoaAsyncSocket ea517e0cc1b33b4f706a20f521ed298adbb05378 实验使用python分别创建Socket服务器与客户端[2] 服务端socket_service.py 123456789101112131415161718# -*- coding: utf-8 -*-import socketip_port = ('192.168.31.136', 9999)sk = socket.socket() # 创建套接字sk.bind(ip_port) # 绑定服务地址sk.listen(5) # 监听连接请求print('启动socket服务，等待客户端连接...')conn, address = sk.accept() # 等待连接，此处自动阻塞while True: # 一个死循环，直到客户端发送‘exit’的信号，才关闭连接 client_data = conn.recv(1024).decode('utf-8') # 接收信息 if client_data == \"exit\": # 判断是否退出连接 exit(\"通信结束\") print(\"来自%s的客户端向你发来信息：%s\" % (address, client_data.encode('utf-8'))) conn.sendall('recv:'+client_data.encode('utf-8')) # 回馈信息给客户端conn.close() # 关闭连接 用户端socket_client.py 123456789101112131415161718192021222324# -*- coding: utf-8 -*-import socketip_port = ('192.168.31.136', 9999) # 192.168.31.136为本机地址 ifconfig 查看s = socket.socket() # 创建套接字s.connect(ip_port) # 连接服务器while True: # 通过一个死循环不断接收用户输入，并发送给服务器 inp = input(\"请输入要发送的信息： \").strip() if not inp: # 防止输入空信息，导致异常退出 continue s.sendall(inp.encode()) if inp == \"exit\": # 如果输入的是‘exit’，表示断开连接 print(\"结束通信！\") break server_reply = s.recv(1024).decode() print(server_reply)s.close() # 关闭连接 在终端中启动socket_service.py 12-&gt; python socket_service.py启动socket服务，等待客户端连接... 启动socket_client.py 输入\"hello\" 12345678# 客户端-&gt; python socket_client.py请输入要发送的信息： \"hello\"recv:hello请输入要发送的信息：# 服务器来自('192.168.31.136', 58160)的客户端向你发来信息：hello 新开一个服务端socket窗口,使用浏览器访问 1234567891011# 服务器来自('192.168.31.136', 58258)的客户端向你发来信息：GET / HTTP/1.1Host: 192.168.31.136:9999Connection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7 使用浏览器访问,使用HTTP协议访问,传输层实现了端到端的传输(能力),但是信息要被正确的理解,需要一些说明,比如上面HTTP 请求头,操作系统拥有传输层的能力,并包装了一组抽象的编程接口(Socket),应用层协议通过调用Socket实现信息的传输并制定格式用于理解信息。 Socket的流程 来自网络 CocoaAsyncSocketCocoaAsyncSocket为macOS，iOS和tvOS提供了易于使用且功能强大的异步套接字库。 客户端Socket实现客户端socket,参考上图,主要为创建socket,连接,发送,接收,关闭流程 12345678910111213141516171819/// 创建``Socket``/// 指定代理及代理回调的队列_socket = [[GCDAsyncSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_main_queue()];// 连接NSError *err = nil;if (![_socket connectToHost:@\"192.168.31.136\" onPort:9999 error:&amp;err]) { // If there was an error, it's likely something like \"already connected\" or \"no delegate set\" NSLog(@\"I goofed: %@\", err);}// 发送NSString *requestString = @\"AsyncSocket request string 1\";NSData *requestData = [requestString dataUsingEncoding:NSUTF8StringEncoding]; [_socket writeData:requestData withTimeout:-1 tag:1];// 接收[_socket readDataWithTimeout:10 tag:1]; 代理回调连接成功 123- (void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(uint16_t)port { NSLog(@\"%@ - %@ - %hu\",sock,host,port);} 发送成功 1234567- (void)socket:(GCDAsyncSocket *)sock didWriteDataWithTag:(long)tag { if (tag == 1) { NSLog(@\"First request sent\"); }else if(tag == 2) { NSLog(@\"Second request sent\"); }} 接收成功 12345678- (void)socket:(GCDAsyncSocket *)sender didReadData:(NSData *)data withTag:(long)tag{ if (tag == 1) { NSLog(@\"%@\",[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]); }else if (tag == 2) { NSLog(@\"%@\",[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]); }} 确保真机和mac处于同一局域网,输出效果如下: 能成功连接,发送信息给服务端且接收服务端返回的信息 连接在连接的回调中设置断点,并进行追踪 对于连接操作,采用异步的并发队列进行管理,提高连接效率,调用系统提供socket.h中的connect方法 1int connect(int, const struct sockaddr *, socklen_t) __DARWIN_ALIAS_C(connect); 12345678connect - initiate a connection on a socketThe connect() system call connects the socket referred to by the file descriptor sockfd to the address specified by addr. The addrlen argument specifies the size of addr. If the connection or binding succeeds, zero is returned. On error, -1 is returned, and errno is set appropriately. 连接完成后,统一回调到socketQueue队列,调用didConnect:方法 SetupStreamPart1() 经过一些容错判断后,调用CFStreamCreatePairWithSocket 创建连接到套接字的可读和可写流 includeReadWrite参数为NO,对Stream在读写操作中发生错误和完成注册回调函数 dispatch_async(delegateQueue,... 异步回调到代理队列(初始化时可指定,此处为主队列)执行代理方法 SetupStreamsPart2() 回到socketQueue 在startCFStreamThreadIfNeeded方法中创建一个串行队列,以同步的方式新建一条子线程并开启运行循环 同时在addStreamsToRunLoop中,将创建的读写流作为事件源顺序添加到刚创建的子线程的runloop中,确保发生对应事件时,runloop能顺利派发。 回到didConnect:方法中, socket开启非阻塞IO,注册读写操作的回调,同时尝试进行读写操作 执行原来的两个读操作 参考 百科 - 套接字 socket编程 connect2 iOS网络编程之CFNetwork Introduction to non-blocking I/O","link":"/2020/03/05/Technology-Learn-CocoaAsyncSocket/"},{"title":"MWeb图床配置","text":"闲话 尝试过几个支持markdown的编辑器,比如MacDown,Ulysses,还是觉得MWeb比较合我的心意,原来就知道MWeb有图床的功能,但是一直没有用,主要是因为觉得有些麻烦,MWeb支持Google photos(应该不会使用这个),imgur,七牛(这两个都要注册,我用sm.ms直接就OK了,感觉也挺方便的),说白了主要就是因为懒,不想自定义配置,当然也下过iPic这样的小工具,同样也未曾使用,因为我觉得当我配置好MWeb后自然也可以不用这样的工具。偶然从订阅的RSS中看到幕后-专访MWeb,决定治治自己的拖延症。 imgur 好吧,闲话就不扯了,说正题吧,一开始考虑,既然已经有支持的了,就用imgur,然后就搜索imgur官网,注册,报错了 错误信息 Imgur is temporarily over capacity. Please try again later 搜索后,发现说这和网络还是有关系,为了避免以后出问题,我选择换一家 七牛 那我就换一种,换成七牛的,搜了一篇知乎上的国内有什么方便的图床？,里面说要付费,我没去试,所以不知道现在是不是需要付费。 自定义 前面那些都只是铺垫,一开始我就想自定义配置图床。正好发现sm.ms提供了API 参考图片上传的接口,要填写的字段主要有Name,填sm.ms或其他你喜欢的名称就好了,API URL,接口中有填https://sm.ms/api/upload,POST File Name字段根据 可知,填写smfile即可,Response URL PATH,一开始不知道填什么,搜索后,发现iOS 版 MWeb 图床功能中自定义图床的使用指南,好吧,MWeb作者已经写了如何配置图床😂,这个字段填写的就是返回的JSON结果中的图片的路径,根据 填data/url就好了,最后一个是可选,我没填,然后Validate,这里出现一个问题,在macOS 10.12.3上,MWeb 2.1.4(257)中,全屏条件下会出现 我必须选中弹窗,然后切到其他窗口,然后再切回来选择图片,上传测试 最后在完成之后 上传本地图片 选择Copy Markdown就可以得到包含上传图片路径后的博客内容,效率提高了不少,而且备份也容易了一点。花点时间抬头看看天,比一直老老实实的干活,有用一些。","link":"/2017/02/04/Technology-MWeb-map-bed-configuration/"},{"title":"Mac终端环境走代理","text":"前言 作为程序员,有时候在终端环境下也需要翻墙的能力,因此继续折腾一下。 环境 macOS Sierra 10.12.3 流程安装privoxy 通过Wiki-Shadowsocks可知,ss使用的是Socks5代理方式。网上搜索的得到的结果是在mac环境下推荐使用privoxy这个的工具。 使用brew安装privoxy 1» ~ brew install privotxy 会提示权限问题 install: /usr/local/etc/…: Permission denied 可使用以下指令修改/usr/local目录的所有者与组 1» ~ sudo chown -R \"$USER\":admin /usr/local 但这么做合适吗? 根据Unix目录结构的来历 因为/usr/local是用来存放用户自己安装的程序,我认为应该没问题 重新执行安装privoxy的指令。 安装成功 配置privoxy打开配置文件/usr/local/etc/privoxy/config 到添加以下两行配置 12listen-address 0.0.0.0:8118forward-socks5 / localhost:1080 . 注意不要忘了后面的 . , ss的默认端口为1080 为什么是8118 从上图可知privoxy的默认端口为8118 开启privoxy1» ~ /usr/local/sbin/privoxy /usr/local/etc/privoxy/config 查看是否成功开启8118端口进行监听 12» ~ netstat -na | grep 8118tcp4 0 0 *.8118 *.* LISTEN 设置代理服务器12export http_proxy='http://localhost:8118'export https_proxy='http://localhost:8118' 为了避免每次开机都能生效,可以将上面两句配置添加到.zshrc/.bashrc_profile中 效果图用curl访问google 关于原理 Socks5代理转化成http代理给命令行终端使用? 根据整个流程的配置下来,我觉得这样的描述好像有哪儿说不通。 用终端curl www.google.com,终端走的是https请求 因为配置https_proxy所以会走本机的8118端口 而privoxy监听了8118又会把请求派发(Forwarding)给1080的ss,让ss去请求 通过privoxy将原来走http的请求变成了走Socks5代理 副产品 在/usr/local/etc/privoxy/config配置文件中有listen-address 0.0.0.0:8118,表明ip是不限制的,手机只要设置了代理,也可以使用。 参考 Wiki-Shadowsocks How to fix homebrew permissions? Mac命令行终端下使用shadowsocks翻墙 Unix目录结构的来历 Mac OS下使用Privoxy做中转代理 Mac OS下使用Privoxy做中转代理","link":"/2017/02/19/Technology-Mac-terminal-environment/"},{"title":"ReactNative 入门体验","text":"环境 macOS Mojave Version 10.14.3Xcode 10.1iPhone 5s 10.0.1node v11.10.0npm 6.7.0React Native 0.58react 16.6.3 新建ReactNative项目12brew install nodebrew install watchman 安装React Native命令行工具1npm install -g react-native-cli 安装Xcode及命令行相关工具或者 1234567## man xcode-select## xcode-select - Manages the active developer directory for Xcode and BSD## tools.## --install## Opens a user interface dialog to request automatic installation## of the command line developer tools.xcode-select --install 详情参考英文-doc 链接2/中文-doc 链接11 创建新应用命令行1react-native init AwesomeProject WebStorm 若node版本过低可能出现Command yarn add react-native --exact` failed.,可参考Upgrade Node.js to the latest version on Mac OS升级node 观察日志的输出生成工程执行的是 1/Users/`userName`/.nvm/versions/node/v11.10.0/bin/node /Users/`userName`/.nvm/versions/node/v11.10.0/lib/node_modules/react-native-cli/index.js init AwesomeProject 查看react-native位置 123which react-native## 输出/Users/`userName`/.nvm/versions/node/v11.10.0/bin/react-native 运行React Native应用同样根据窗口日志的输出,iOS运行的方法可以用命令行或直接使用Xcode打开运行 使用命令行方式 12345678## cd到工程目录下cd /Users/`userName`/WebstormProjects/AwesomeProject## 执行react-native run-iosFound Xcode project AwesomeProject.xcodeproj... bla bla bla&gt; Running script 'Install Third Party' 启动模拟器,然后安装下载第三方的组件,下载的脚本是scripts/ios-install-third-party.sh 12345678if [ -d \"$HOME/.rncache\" ]; then cachedir=\"$HOME/.rncache\" # react-native 0.57.8 and olderelse cachedir=\"$HOME/Library/Caches/com.facebook.ReactNativeBuild\"fimkdir -p \"$cachedir\"... 缓存目录旧版在家目录的.rncache,如果存在该目录,则下载的库就会安装在此处,若网络原因无法下载,可参考iOS RN 0.45以上版本所需的第三方编译库(boost等),手动下载即可 但是,运行失败了 123456789101112131415161718Installing build/Build/Products/Debug-iphonesimulator/AwesomeProject.appAn error was encountered processing the command (domain=NSPOSIXErrorDomain, code=22):Failed to install the requested applicationThe bundle identifier of the application could not be determined.Ensure that the application's Info.plist contains a value for CFBundleIdentifier.Print: Entry, \":CFBundleIdentifier\", Does Not ExistCommand failed: /usr/libexec/PlistBuddy -c Print:CFBundleIdentifier build/Build/Products/Debug-iphonesimulator/AwesomeProject.app/Info.plistPrint: Entry, \":CFBundleIdentifier\", Does Not ExistError: Command failed: /usr/libexec/PlistBuddy -c Print:CFBundleIdentifier build/Build/Products/Debug-iphonesimulator/AwesomeProject.app/Info.plistPrint: Entry, \":CFBundleIdentifier\", Does Not Exist at checkExecSyncError (child_process.js:637:11) at Object.execFileSync (child_process.js:655:13) at Promise.then (/Users/Jason/WebstormProjects/AwesomeProject/node_modules/react-native/local-cli/runIOS/runIOS.js:208:5) at processTicksAndRejections (internal/process/next_tick.js:81:5) 再往上看,编译时就已经失败了 1234❌ /Users/Jason/WebstormProjects/AwesomeProject/node_modules/react-native/third-party/folly-2018.10.22.00/folly/detail/RangeCommon.h:22:10: 'glog/logging.h' file not found#include &lt;glog/logging.h&gt; ^ 用Xcode 的方式试试 选择模拟器并编译 除了jsi中RangeCommon.h的glog/logging.h找不到以外,这个与使用命令行运行时是一样,又多了三个错误,剩下的3个错误,参考Supporting Xcode 10 and the new Xcode build system,RN的一个issue,调整工程的编译系统,再次编译 现在错误变成一样了,都是文件找不到,来看看为什么找不到,React.xcodeproj &gt; ThirdParty &gt; glog &gt; glog下,确实缺少文件 jsi依赖于double-conversiondouble-conversion执行了ios-install-third-party.sh,并未能成功输出需要的头文件 1234567891011121314151617181920212223242526272829## ios-install-third-party.shfunction fetch_and_unpack () { file=$1 url=$2 hash=$3 cmd=$4 ... if [ \"$fetched\" = \"yes\" ] || [ ! -f \"third-party/$dir/.installed\" ]; then (cd third-party; ## &lt;2&gt; rm -rf \"$dir\" echo Unpacking \"$cachedir/$file\"... if ! tar zxf \"$cachedir/$file\"; then file_fail \"$cachedir/$file\" \"Unpacking '$cachedir/$file' failed\" fi cd \"$dir\" eval \"${cmd:-true}\" &amp;&amp; touch .installed) fi}## &lt;1&gt;mkdir -p third-partySCRIPTDIR=$(dirname \"$0\")fetch_and_unpack glog-0.3.5.tar.gz https://github.com/google/glog/archive/v0.3.5.tar.gz 61067502c5f9769d111ea1ee3f74e6ddf0a5f9cc \"\\\"$SCRIPTDIR/ios-configure-glog.sh\\\"\"... cd到third-party目录,将缓存目录下的包解压缩,并执行对应的指令,比如glog-0.3.5就执行 1$SCRIPTDIR/ios-configure-glog.sh 123456789101112131415### ios-configure-glog.sh./configure --host arm-apple-darwin# Fix build for tvOScat &lt;&lt; EOF &gt;&gt; src/config.h...# Prepare exported header includeEXPORTED_INCLUDE_DIR=\"exported/glog\"mkdir -p exported/glogcp -f src/glog/log_severity.h \"$EXPORTED_INCLUDE_DIR/\"cp -f src/glog/logging.h \"$EXPORTED_INCLUDE_DIR/\"cp -f src/glog/raw_logging.h \"$EXPORTED_INCLUDE_DIR/\"cp -f src/glog/stl_logging.h \"$EXPORTED_INCLUDE_DIR/\"cp -f src/glog/vlog_is_on.h \"$EXPORTED_INCLUDE_DIR/\" 执行该脚本执行configure并创建exported/glog目录,然后将configure过程中生成的文件cp到该目录,执行ios-configure-glog.sh后 结果如下: 这是正常的,但是⌘ + B再次编译后又报了相同的错误,对比Xcode与终端执行的日志结果发现,Xcode执行时checking whether the C compiler works... 失败了 查找关于'glog/logging.h' file not found,根据‘glog/logging.h’ file not found得到的解决方案是 12cd node_modules/react-native/third-party/glog-0.3.5sh ../../scripts/ios-configure-glog.sh 上面已经执行过了,用Xcode重新编译还会出现问题 参考react-native/pull/23511 手动修改ios-configure-glog.sh文件 123...export CXX=\"$(xcrun -find -sdk $PLATFORM_NAME cc) -arch $CURRENT_ARCH -isysroot $(xcrun -sdk $PLATFORM_NAME --show-sdk-path)\"... 试了以后,用Xcode编译依然报错ㄟ( ▔, ▔ )ㄏ 为什么有../../在上面的代码的&lt;1&gt;处可知,../..后,当前位置会在.../react-native目录下,要在该目录下创建third-party目录,同时又要保证SCRIPTDIR能正确定位到ios-configure-glog.sh去执行。 这样做后还是失败,因为&lt;2&gt;处移除后,重新执行,同样因为configure失败导致无法生成.h文件。 解决方法在终端根据上面提到的方法执行ios-install-third-party.sh后 12# 注释下面这句# fetch_and_unpack glog-0.3.5.tar.gz https://github.com/google/glog/archive/v0.3.5.tar.gz 61067502c5f9769d111ea1ee3f74e6ddf0a5f9cc \"\\\"$SCRIPTDIR/ios-configure-glog.sh\\\"\" 避免去删除glog这个包,然后再用Xcode进行编译就正常了,运行时模拟器下还是会崩溃,真机能正常运行。 资源地址获取不正确,有网络代理工具的情况时,比如SS,将其调成自动代理或关闭 Hello world修改App.js 12345678910111213141516export default class App extends Component&lt;Props&gt; { render() { // return ( // &lt;View style={styles.container}&gt; // &lt;Text style={styles.welcome}&gt;Welcome to React Native!&lt;/Text&gt; // &lt;Text style={styles.instructions}&gt;To get started, edit App.js&lt;/Text&gt; // &lt;Text style={styles.instructions}&gt;{instructions}&lt;/Text&gt; // &lt;/View&gt; // ); return ( &lt;View style={{ flex: 1, justifyContent: \"center\", alignItems: \"center\",backgroundColor: '#F5FCFF', }}&gt; &lt;Text&gt;Hello world!&lt;/Text&gt; &lt;/View&gt; ); }} 要使用backgroundColor: '#F5FCFF'设置背景色 集成ReactNative到已有项目建立目录结构新建一个目录去集成RN工程,将Xcode工程复制到RN下的ios子目录 安装JavaScript依赖库在RN工程根目录下,创建package.json文件 12345678{ \"name\": \"AnNativeApp\", \"version\": \"0.0.1\", \"private\": true, \"scripts\": { \"start\": \"node node_modules/react-native/local-cli/cli.js start\" }} 12345678910111213## 若 yarn 不存在,安装## brew install yarnyarn add react-native## 安装React# warning \" &gt; react-native@0.58.5\" has unmet peer dependency \"react@16.6.3\".# 而且原来使用``WebStorm``生成的``package.json``中包含的``react``和``react-native``,所以``react``也选16.6.3# \"dependencies\": {# \"react\": \"16.6.3\",# \"react-native\": \"0.58.5\"# },yarn add react@version_printed_above 把node_modules添加到.gitignore文件中 12# 将``WebStorm``生成的.gitignore复制到``RN``根目录下即可cp .gitignore ~/Desktop/AnNativeApp/ 使用CocoaPods集成在ios目录下,初始化pod init配置 1pod init 123456789101112131415161718192021222324252627282930313233343536platform :ios, '9.0'target 'AnNativeApp' do # Uncomment the next line if you're using Swift or would like to use dynamic frameworks # use_frameworks! # Your 'node_modules' directory is probably in the root of your project, # but if not, adjust the `:path` accordingly pod 'React', :path =&gt; '../node_modules/react-native', :subspecs =&gt; [ 'Core', 'CxxBridge', # Include this for RN &gt;= 0.47 'DevSupport', # Include this to enable In-App Devmenu if RN &gt;= 0.43 'RCTText', 'RCTNetwork', 'RCTWebSocket', # Needed for debugging 'RCTAnimation', # Needed for FlatList and animations running on native UI thread # Add any other subspecs you want to use in your project ] # Explicitly include Yoga if you are using RN &gt;= 0.42.0 pod 'yoga', :path =&gt; '../node_modules/react-native/ReactCommon/yoga' # Third party deps podspec link pod 'DoubleConversion', :podspec =&gt; '../node_modules/react-native/third-party-podspecs/DoubleConversion.podspec' pod 'glog', :podspec =&gt; '../node_modules/react-native/third-party-podspecs/glog.podspec' pod 'Folly', :podspec =&gt; '../node_modules/react-native/third-party-podspecs/Folly.podspec' target 'AnNativeAppTests' do inherit! :search_paths # Pods for testing end target 'AnNativeAppUITests' do inherit! :search_paths # Pods for testing endend 1pod install 可能会碰到如下的错误 1234567891011...Installing boost-for-react-native (1.63.0)[!] Error installing boost-for-react-native[!] /usr/local/bin/git clone https://github.com/react-native-community/boost-for-react-native.git /var/folders/lk/znn1qp4925j412wt4t_qkplc0000gn/T/d20190222-11171-yp7x2 --template= --single-branch --depth 1 --branch v1.63.0-0Cloning into '/var/folders/lk/znn1qp4925j412wt4t_qkplc0000gn/T/d20190222-11171-yp7x2'...error: RPC failed; curl 18 transfer closed with outstanding read data remainingfatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 因为仓库太大了,搜索后大致有两种办法 方式一 1234567## man git-config## http.postBuffer## Maximum size in bytes of the buffer used by smart HTTP transports when POSTing data to the remote system. For requests larger than## this buffer size, HTTP/1.1 and Transfer-Encoding: chunked is used to avoid creating a massive pack file locally. Default is 1 MiB,## which is sufficient for most requests.git config --global http.postBuffer 524288000 方式二 123git clone http://github.com/large-repository --depth 1cd large-repositorygit fetch --unshallow 使用了方式一正常解决了。因为根据错误信息说明已经是用--depth 1去下载了,但是可以去了解一下 通过[!] Error installing作为关键词去CocoaPods搜索 CocoaPods/lib/cocoapods/downloader/cache.rb 1234567891011121314# Downloads the Pod from the given `request`## @param [Request] request# the request to be downloaded.## @return [Response] the response from downloading `request`#def download_pod(request) cached_pod(request) || uncached_pod(request)rescue Informative raiserescue raiseend 调用 12345678def cached_pod(request) cached_spec = cached_spec(request) path = path_for_pod(request) return unless cached_spec &amp;&amp; path.directory? spec = request.spec || cached_spec Response.new(path, spec, request.params)end 因为是用gem安装的 1gem env 获得gem包的安装位置,定位到cache.rb,经过一些步骤之后, cocoapods-downloader/lib/cocoapods-downloader/git.rb 123456789101112131415161718192021222324252627282930# Clones the repo. If possible the repo will be shallowly cloned.## @note The `:commit` option requires a specific strategy as it is not# possible to specify the commit to the `clone` command.## @note `--branch` command line option can also take tags and detaches# the HEAD.## @param [Bool] force_head# If any specific option should be ignored and the HEAD of the# repo should be cloned.## @param [Bool] shallow_clone# Whether a shallow clone of the repo should be attempted, if# possible given the specified {#options}.#def clone(force_head = false, shallow_clone = true) ui_sub_action('Git download') do begin git! clone_arguments(force_head, shallow_clone) update_submodules rescue DownloaderError =&gt; e if e.message =~ /^fatal:.*does not support (--depth|shallow capabilities)$/im clone(force_head, false) else raise end end endend 代码集成创建index.js &amp;&amp; 添加RN代码可以参考WebStorm创建的index.js和App.js 123456789101112131415161718192021222324252627282930313233343536import React, {Component} from 'react';import {Platform, StyleSheet, Text, View} from 'react-native';// &lt;1&gt;class RNHighScores extends React.Component { render() { var contents = this.props['scores'].map((score) =&gt; ( &lt;Text key={score.name}&gt; {score.name}:{score.value} {'\\n'} &lt;/Text&gt; )); return ( &lt;View style={styles.container}&gt; &lt;Text style={styles.highScoresTitle}&gt;2048 High Scores!&lt;/Text&gt; // &lt;2&gt; &lt;Text style={styles.scores}&gt;{contents}&lt;/Text&gt; &lt;/View&gt; ); }}const styles = StyleSheet.create({ container: { flex: 1, ... }, highScoresTitle: { fontSize: 20, ... }, scores: { textAlign: 'center', ... },}); 添加RCTRootView在Xcode的ViewController中 1234567891011121314151617181920212223// &lt;3&gt; NSURL *jsCodeLocation = [NSURL URLWithString:@\"http://192.168.31.191:8081/index.bundle?platform=ios\"]; // [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@\"index\" fallbackResource:nil]; RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL: jsCodeLocation moduleName: @\"AnNativeApp\" // &lt;4&gt; initialProperties: @{ @\"scores\" : @[ @{ @\"name\" : @\"Alex\", @\"value\": @\"42\" }, @{ @\"name\" : @\"Joel\", @\"value\": @\"10\" } ] } launchOptions: nil];// &lt;5&gt; [self.view addSubview:rootView]; 允许网络访问1234567891011&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt; &lt;key&gt;NSExceptionDomains&lt;/key&gt; &lt;dict&gt; &lt;key&gt;localhost&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSTemporaryExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/dict&gt;&lt;/dict&gt; 运行开发服务器1npm start 然后就可以运行Xcode项目,观察效果了 注意事项&lt;1&gt; 教程中是把所有的都写在index.js中的,而目前是参考WebStorm创建的工程,除了index.js还有App.js,会报错,修改 1export default class RNHighScores extends React.Component { &lt;2&gt; 获取变量的方法可以用{} &lt;3&gt; When you build a React Native application, you use the React Native packager to create an index.bundle that will be served by the React Native server. Inside index.bundle will be our RNHighScore module. So, we need to point our RCTRootView to the location of the index.bundle resource (via NSURL) and tie it to the module. 如果在真机的环境下,要替换成对应的mac(服务器)的IP &lt;4&gt; 要保证 package.json, moduleName: 后面的参数 AppRegistry.registerComponent(appName, () =&gt; App); 1234567891011121314151617181920cat package.json{ \"name\": \"AnNativeApp\",// &lt;= 这里 \"version\": \"0.0.1\", \"private\": true, \"scripts\": { \"start\": \"node node_modules/react-native/local-cli/cli.js start\" }, \"dependencies\": { \"react\": \"^16.6.3\", \"react-native\": \"^0.58.5\" }}## import {name as appName} from './app.json';cat app.json{ \"name\": \"AnNativeApp\", &lt;= 这里 \"displayName\": \"AnNativeApp\"}% 这三者是一致的 &lt;5&gt; RCTRootView继承自UIView,要设置frame 参考 给所有开发者的React Native详细入门指南（第一阶段） React Native 0.58 Getting-started Upgrade Node.js to the latest version on Mac OS iOS RN 0.45以上版本所需的第三方编译库(boost等) Supporting Xcode 10 and the new Xcode build system ‘glog/logging.h’ file not found [iOS] Fix pod install error in configure: C compiler cannot create executables React Native Config.h not found ReactNative iOS运行再次出错：No bundle URL present integration-with-existing-apps 搭建开发环境","link":"/2019/02/22/Technology-ReactNative-Intro/"},{"title":"Charles使用二三事","text":"概览 https代理 本地和远程映射 断点调试 环境 macOS Sierra 10.12.3Charles 4.0 https代理关于如何用Charles实现代理https请求,网上有很多,简单说说 macOS上下载并在钥匙串中选择信任Charles证书 iOS设备以macOS为代理,访问http://www.charlesproxy.com/getssl Charles上配置https代理的相关内容(Proxy &gt; SSL Proxying Settings) 详细的可以参考SSL Certificates 下面来说说原理 什么是http代理 HTTP 代理存在两种形式第一种是 RFC 7230 - HTTP/1.1: Message Syntax and Routing（即修订后的 RFC 2616，HTTP/1.1 协议的第一部分）描述的普通代理。这种代理扮演的是「中间人」角色，对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 HTTP 报文。 如果用Charles抓包查看请求头一般应该都是这个,所以这儿只关注这种方式的,另一种的详情可参考文章末尾的链接网站 下面这张图片来自于《HTTP 权威指南》，直观地展示了上述行为： 简单说得出的结论就是: 如果用Charles做代理,那么安装了Charles的设备(比如我的mac)就充当了服务器。 https的s先贴两张尝试说明什么是https的图 来自Wiki-传输层安全协议 来自下面的参考链接 可以知道结束ssl验证后,还是发送http明文,只要能让ssl验证通过即可,而要通过验证主要就看客户端信不信任服务器的证书。查看上面第一与第二步中得到的证书,序列号是一样的,主要目的就是为了让客户端(iOS)能信任服务器(macOS)的证书,从而通过ssl验证,得到http的内容。 本地和远程映射本地映射和远程映射可用于测试,简单说就是替换请求的响应结果,这里纯粹为了测试,简单创建一个场景 如果你使用某些应用出现了下面这种情况 应用有一种类似要求强制更新的策略,可以简单使用Charles本地映射Pass 经过一些简单的尝试,大致知道了应用弹窗的实现规则 在某个请求的响应结果的,一个字段标识是否有新版本,有则发送新版本的iTunes下载地址(给button点击使用),弹窗的内容。所以只要通过本地映射,修改返回的内容,让客户端认为没有新版本即可。 修改返回的弹窗信息 如果每次请求,服务器都会验证版本的话,那么改这个也没有什么意义,只是为了形象的说明本地映射是什么,远程映射功能也是一样的。本地映射和远程映射在Charles的Tools菜单项下可以找到 断点调试在少数π的这篇文章中利用Charles Proxy下载旧版本iOS App,其中就利用到了断点调试。获取了微信的产品号后通过设置断点,再次请求,中断,修改请求的参数,从而实现下载旧版本的应用。 总结:Charles还有其他很多的用处,比如模仿低速的网络状态,设置DNS解析等 170413 更新要使用 Charles 需要设置代理，可以用 macOS 上的 “通用剪贴板”，这样可以避免在 iPhone 输入 ip 的麻烦。 参考 刘坤的技术博客 - 数字证书 Wiki - 代理服务器 HTTP 代理原理及实现（一） Wiki - Chain of trust","link":"/2017/03/11/Technology-Something-about-Charles/"},{"title":"WoSign CA 签名的数字证书失效","text":"导语 今天服务器受到反馈，加载平台图片资源失败。原因是不信任的数字证书，公司的服务器证书是用 WoSign 签名的。 在证书交换阶段时报错了，Google 后找到一篇 Apple 官方的声明。 PKI 公钥基础设施（PKI）是创建，管理，分发，使用，存储和撤销数字证书和管理公钥加密所需的一系列角色，策略和过程。 cross-certification 来自 Wiki - cross-certification 当前的场景 名称 含义 cert 1.1 原 StartCom 证书 cert 2.1 原 WoSign 证书 cert 1 由 WoSign 生成的证书 cert 2 由 StartCom 生成的证书 cert 2.2 StartCom 数字签名的用户 cert 1.2 WoSign 数字签名的用户 目标 StartCom 签名的 cert 2.2 数字证书要被 PKI 1 信任 条件 Apple 信任 StartCom 的根证书，而不信任 WoSign 的根证书 原理 StartCom 生成一个包含 WoSign 公钥的证书 (cert 2) cert 2.2 证书链会有两条路径 (“cert2.2→cert2” 和 “cert2.2→cert2.1→cert1” ),也就会找到 cert 1.1 因为 cert 1.1 根证书是被信任的，所以 cert 2.2 也会被信任。这是一个可以对称的过程。 关于原因，Apple 的声明中可以略知一二。 后记 为什么有些会有些不会呢? 我觉得主要有两个原因: To avoid disruption to existing WoSign certificate holders and to allow their transition to trusted roots, Apple products trust individual existing certificates that were issued from this intermediate CA and published to public Certificate Transparency log servers by 2016-09-19. They will continue to be trusted until they expire, are revoked, or are untrusted at Apple’s discretion. 声明中说为了平稳的过渡，该 CA 签名的部分证书在短期内还是可用的。 被信任的根证书是放在客户端浏览器中的，证书这个应该保护的比较好，需要 SDK 升级进行统一处理可能会比较合适的。 参考 Wiki - cross-certification Wiki - Public_key_infrastructure","link":"/2017/04/10/Technology-WoSign-CA-signed-digital-certificate-is-invalid/"},{"title":"学习笔记 - Flask - 01","text":"前言4月就要待业家中,经过一两天的踌躇,觉着这其实是一个蛮好的学习与重新调整的机会,后面学习是不会有人提供薪水了，那自然可以更自由些。不过漫无目的的学习的效率比较低，可以根据BOSS上的岗位的关键词去了解相关的技术。 自己喜欢折腾,对Python也蛮有兴趣,先学习下Flask 安装1pip3 install Flask 如果遇到网的问题,可以Google搜索pip 换源,现在安装一些工具确实是没有什么门槛 显示下安装后的效果 1pip3 show Flask IDE安装 Trae 编辑器另外我们也可以下载本地的开发环境 Trae，Trae 是字节跳动推出的一款面向开发者的 AI 驱动的集成开发环境（IDE）。 访问 Trae 官网 https://www.trae.com.cn默认情况，下载按钮会自动匹配我们的电脑系统，我们也可以找到适合自己电脑操作系统的 Trae 安装包，进行下载。 Hello worldAI 自动补齐 12345678from flask import Flaskapp = Flask(__name__)@app.route('/')def index(): return 'Hello, World!'if __name__ == '__main__': app.run(debug=True) 起个本地服务 1python app.py Flask 基本概念这部分照搬原文,概念上的东西大同小异,主要看下语法 路由: URL 到 Python 函数的映射 视图函数: 处理请求并返回响应的 Python 函数 请求对象: 包含了客户端发送的请求信息,如请求方法、URL、请求头、表单数据等 响应对象: 包含了发送给客户端的响应信息，如状态码、响应头、响应体等 模板：Flask 使用 Jinja2 模板引擎来渲染 HTML 模板。模板允许你将 Python 代码嵌入到 HTML 中，从而动态生成网页。 应用工厂：应用工厂是一个 Python 函数，它创建并返回一个 Flask 应用实例。这允许你配置和初始化你的应用，并且可以创建多个应用实例。 配置对象：Flask 应用有一个配置对象，你可以使用它来设置各种配置选项，如数据库连接字符串、调试模式等。 蓝图：蓝图是 Flask 中的一个组织代码的方式，它允许你将相关的视图函数、模板和静态文件组织在一起，并且可以在多个应用中重用。 静态文件：静态文件是不会被服务器端执行的文件，如 CSS、JavaScript 和图片文件。Flask 提供了一个简单的方法来服务这些文件。 扩展：Flask 有许多扩展，可以添加额外的功能，如数据库集成、表单验证、用户认证等。 会话：Flask 使用客户端会话来存储用户信息，这允许你在用户浏览你的应用时记住他们的状态。 错误处理：Flask 允许你定义错误处理函数，当特定的错误发生时，这些函数会被调用。 路由 (Routing)1234567891011121314151617from flask import Flaskapp = Flask(__name__)@app.route('/')def index(): return 'Hello, World!'@app.route('/router/about')def about(): return 'About Page'@app.route('/router/contact')def contact(): return 'Contact Page'if __name__ == '__main__': app.run(debug=True) 视图函数 (View Functions)123@app.route('/greet/&lt;name&gt;')def greet(name): return f'Hello, {name}!' greet 就是视图函数 请求对象 (Request Object)123456from flask import request@app.route('/submit', methods=['POST'])def submit(): username = request.form.get('username') return f'Hello, {username}!' 要有个提交表单的操作才能串起来,看下面涉及到flask里python和html混合的处理逻辑 响应对象 (Response Object)响应对象包含了发送给客户端的响应信息，包括状态码、响应头和响应体。Flask 默认会将字符串、HTML 直接作为响应体。 12345678from flask import make_response@app.route('/custom_response')def custom_response(): # make_response 创建个响应对象,然后填充请求头 response = make_response('This is a custom response!') response.headers['X-Custom-Header'] = 'Value' return response 模板 (Templates)Flask 使用 Jinja2 模板引擎来渲染 HTML 模板。模板允许你将 Python 代码嵌入到 HTML 中，从而动态生成网页内容。 12345from flask import render_template@app.route('/render/&lt;name&gt;')def render(name): return render_template('render_name.html', name=name) 123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello, {{ name }}!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 直接访问 http://127.0.0.1:5000/render/Wang 报找不到模板 看了下模板文件要放在templates 目录下,新建后,将render_name.html移动到该目录下,重新刷新页面，正常显示 应用工厂 (Application Factory)应用工厂是一个 Python 函数，用于创建和配置 Flask 应用实例。这种方法允许你创建多个应用实例，或者在不同配置下初始化应用。 12345678910from flask import Flaskdef create_app(config_name): app = Flask(__name__) app.config.from_object(config_name) from . import routes app.register_blueprint(routes.bp) return app 应该是针对不同环境 配置对象 (Configuration Objects)配置对象用于设置应用的各种配置选项，如数据库连接字符串、调试模式等。可以通过直接设置或加载配置文件来配置 Flask 应用。 1234class Config: DEBUG = True SECRET_KEY = 'mysecretkey' SQLALCHEMY_DATABASE_URI = 'sqlite:///mydatabase.db' 蓝图 (Blueprints)蓝图是 Flask 中的组织代码的方式。它允许你将相关的视图函数、模板和静态文件组织在一起，并且可以在多个应用中重用。 1234567from flask import Blueprintbp = Blueprint('main', __name__)@bp.route('/')def home(): return 'Home Page' 注册蓝图 (app/__init__.py)： 1234567from flask import Flaskfrom .routes import bp as main_bpdef create_app(): app = Flask(__name__) app.register_blueprint(main_bp) return app 静态文件 (Static Files)静态文件是不会被服务器端执行的文件，如 CSS、JavaScript 和图片文件。Flask 提供了一个简单的方法来服务这些文件。 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"{{ url_for('static', filename='style.css') }}\"&gt; 静态文件目录：将静态文件放在 static 文件夹中，Flask 会自动提供服务。 扩展 (Extensions)Flask 有许多扩展，可以添加额外的功能，如数据库集成、表单验证、用户认证等。这些扩展提供了更高级的功能和第三方集成。 1234from flask_sqlalchemy import SQLAlchemyapp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///mydatabase.db'db = SQLAlchemy(app) 会话 (Sessions)Flask 使用客户端会话来存储用户信息，以便在用户浏览应用时记住他们的状态。会话数据存储在客户端的 cookie 中，并在服务器端进行签名和加密。 1234567891011121314from flask import session# 自动生成的密钥app.secret_key = 'your_secret_key_here'@app.route('/set_session/&lt;username&gt;')def set_session(username): session['username'] = username return f'Session set for {username}'@app.route('/get_session')def get_session(): username = session.get('username') return f'Hello, {username}!' if username else 'No session data' 错误处理 (Error Handling)Flask 允许你定义错误处理函数，当特定的错误发生时，这些函数会被调用。可以自定义错误页面或处理逻辑。 1234567@app.errorhandler(404)def page_not_found(e): return 'Page not found', 404@app.errorhandler(500)def internal_server_error(e): return 'Internal server error', 500 参考Flask 教程","link":"/2025/03/27/Technology-learn-flask/"},{"title":"lldb调试OC的若干辅助方法与注意","text":"输出 UIView 的层级结构输出 UIViewController 的层级结构输出类的属性与方法列表形如[0xAbc …]调用时如何出现方法提示 [161129更新]lldb 如何支持 frame 类型的输出 [161204更新] UIView的层级结构UIView+JAlldb.h1234567891011121314#import &lt;UIKit/UIKit.h&gt;@interface UIView (JAlldb)#if DEBUG/** * 输出view的层级结构 */- (void)p_recursiveView;#endif@end UIView+JAlldb.m12345678910111213141516171819#import \"UIView+JAlldb.h\"@implementation UIView (lldb)#if DEBUG- (void)p_recursiveView{ #pragma clang diagnostic push#pragma clang diagnostic ignored \"-Wundeclared-selector\" // 私有方法 NSLog(@\"%@\",[self performSelector:@selector(recursiveDescription)]); #pragma clang diagnostic pop}#endif@end UIViewController的层级结构UIViewController+JAlldb.h1234567891011121314#import &lt;UIKit/UIKit.h&gt;@interface UIViewController (JAlldb)#if DEBUG/** * 输出指定vc的层级结构 */- (void)p_recursiveController;#endif@end UIViewController+JAlldb.m12345678910111213141516171819#import \"UIViewController+JAlldb.h\"@implementation UIViewController (JAlldb)#if DEBUG- (void)p_recursiveController{#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Wundeclared-selector\" // 私有方法 NSLog(@\"%@\",[self performSelector:@selector(_printHierarchy)]); #pragma clang diagnostic pop}#endif@end 类的属性与方法列表NSObject+JAlldb.h123456789101112131415161718192021222324252627282930313233343536#import &lt;Foundation/Foundation.h&gt;@interface NSObject (JAlldb)/** 属性列表 @param recursive 是否递归 @return 属性列表 */- (NSArray *)p_propertyList:(BOOL)recursive;/** 变量列表 @param recursive 是否递归 @return 变量列表 */- (NSArray *)p_ivarList:(BOOL)recursive;/** * 方法列表 * * @param recursive 是否递归 */- (NSArray *)p_methodList:(BOOL)recursive;/** 清空缓存列表 */- (void)p_cleanCacheList;@end NSObject+JAlldb.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#import \"NSObject+JAlldb.h\"#import &lt;objc/message.h&gt;@implementation NSObject (JAlldb)const void* propertiesKey = \"com.coder.lldb-exclusive.propertiesKey\";const void* ivarKey = \"com.coder.lldb-exclusive.ivarKey\";const void* methodKey = \"com.coder.lldb-exclusive.methodKey\";- (NSArray *)p_propertyList:(BOOL)recursive { NSArray *glist = objc_getAssociatedObject([self class], propertiesKey); return glist == nil ? ^{ unsigned int count = 0; NSMutableArray *plistM = [NSMutableArray arrayWithCapacity:count]; Class cls = [self class]; do { objc_property_t *list = class_copyPropertyList(cls, &amp;count); for (int i = 0; i &lt; count; ++i) { objc_property_t pty = list[i]; const char *pname = property_getName(pty); [plistM addObject:[NSString stringWithUTF8String:pname]]; } free(list); cls = [cls superclass]; } while (cls &amp;&amp; recursive); objc_setAssociatedObject([self class],propertiesKey, plistM, OBJC_ASSOCIATION_COPY_NONATOMIC); NSLog(@\"Found %ld properties on %@\",plistM.count,[self class]); return plistM.copy; }() : glist;}- (NSArray *)p_ivarList:(BOOL)recursive{ NSArray *glist = objc_getAssociatedObject([self class], ivarKey); return glist == nil ? ^{ unsigned int count = 0; NSMutableArray *plistM = [NSMutableArray arrayWithCapacity:count]; Class cls = [self class]; do { Ivar *list = class_copyIvarList(cls, &amp;count); for (int i = 0; i &lt; count; ++i) { Ivar ity = list[i]; const char *iname = ivar_getName(ity); [plistM addObject:[NSString stringWithUTF8String:iname]]; } free(list); cls = [cls superclass]; } while (cls &amp;&amp; recursive); NSLog(@\"Found %ld ivar on %@\",plistM.count,[self class]); objc_setAssociatedObject([self class],ivarKey, plistM, OBJC_ASSOCIATION_COPY_NONATOMIC); return plistM.copy; }() : glist;}- (NSArray *)p_methodList:(BOOL)recursive { NSArray *glist = objc_getAssociatedObject([self class], methodKey); return glist == nil ? ^{ unsigned int methodCount = 0; NSMutableArray *plistM = [NSMutableArray arrayWithCapacity:methodCount]; Class cls = [self class]; do { Method *methods = class_copyMethodList(cls, &amp;methodCount); for (unsigned int i = 0; i &lt; methodCount; i++) { Method method = methods[i]; /* printf(\"\\t'%s'|'%s' of encoding '%s'\\n\", class_getName(cls), sel_getName(method_getName(method)), method_getTypeEncoding(method)); */ [plistM addObject:[NSString stringWithUTF8String:sel_getName(method_getName(method))]]; } free(methods); cls = [cls superclass]; }while (cls &amp;&amp; recursive); printf(\"Found %d methods on '%s'\\n\", methodCount, class_getName([self class])); objc_setAssociatedObject([self class],ivarKey, plistM, OBJC_ASSOCIATION_COPY_NONATOMIC); return plistM.copy; }() : glist; }- (void)p_cleanCacheList { objc_removeAssociatedObjects([self class]);}@end [0xAbc …]调用如何出现方法提示 类地址前加类型强转 12(lldb) po [(UIView *)0x117e09e80 backgroundColor] UIExtendedSRGBColorSpace 1 1 1 1 lldb如何支持frame类型的输出123$ touch ~/.lldbinit$ echo display @import UIKit &gt;&gt; ~/.lldbinit$ echo target stop-hook add -o \\”target stop-hook disable\\” &gt;&gt; ~/.lldbinit 参考 iOS-Runtime-Headers","link":"/2016/11/20/Technology-lldb-debugging-OC-a-number-of-auxiliary-methods-and-attention/"},{"title":"路由器级联放大Wifi信号","text":"前言 Wifi 信号又不行了,房间的地理位置不好,联通的路由器信号又特别差,根本不能穿墙。好久不写了博客了,一放松就一直不想写。毕竟从善如登,从恶如崩啦。原来做级联的老旧路由器需要复位,再抢救下,看有没有挽救的希望。所以正好把流程简单记录一下,虽然没啥子用。 环境 MERCURY xxx 路由器macOS Sierra 10.12.6 原理网上搜了下,就是下面的参考链接,提供了3种方案 WDS 无线桥接 当 AP (无线交换机) 使用 搭建新网络 (子网络) 因为没有联通路由器的登陆的用户名密码,就选第 3 种方案 适用环境,组网后的效果,然后操作之类的,截图如下 流程准备把我的路由器的 WAN 口与联通路由器的 LAN 用网线连接 复位路由器旁边一般有个复位键(reset),长按几秒,当指示灯全亮的时候,就代表复位成功了。 加入子网 就是上面这个 配置路由器 远程登陆上去,一般为 192.168.1.1 路由器上一般会写 要认证,一般路由器上会写 因为是配置子网,比如联通的路由器的网段是 192.168.1.x 的,那我的路由器的网段不能一样,改成 192.168.5.x 点保存后,页面会失效,因为当前的 192.168.1.1 已经不是当前路由器的 IP 地址了。关闭 wifi 再次连接,然后用 192.168.5.1 访问一下。好了,子网络已经成功了。 收尾: 添加 WAP2 密码, 修改远程登陆密码… 添加 WAP2 密码 每种品牌的路由器都会有点差异,随便点点找找就行。 因为 wifi 已经密码了,所以网络又掉线了,用新密码重新登陆 修改管理员账户 修改 wifi 热点名称 改完保存即可 总结访问又变得流畅了些。机器和人一样,一直不休息,也会宕机的,因为疲劳会不断累积,总会有根稻草压垮那只骆驼,感觉写写也是蛮开心的,虽然没什么内容。 参考多台路由器如何级联","link":"/2017/09/24/Technology-router-cascade-magnified-wifi/"},{"title":"Clang学习历程 概述","text":"ClangClang是LLVM(Low Level Virtual Machine)项目提供的工具链中的编译器的前端部分 LLVM项目是模块化和可重用的编译器和工具链技术的集合,LLVM的一大特色就是，有着独立的、完善的、严格约束的中间代码表示。这种中间代码，就是LLVM的字节码，是LLVM抽象的精髓，前端生成这种中间代码，后端自动进行各类优化分析，让用LLVM开发的编译器，都能用上最先进的后端优化技术。 编译器编译流程如下 来自《编译原理》 编译器分成前端与后端两部分 前端负责处理源代码，后端负责生成目标代码 来自参考链接3 环境 macOS Hign Sierra 10.13.6Xcode10.1 编译获取llvm源代码 1% git clone https://git.llvm.org/git/llvm.git/ 获取Clang源代码 12% cd llvm/tools% git clone https://git.llvm.org/git/clang.git/ 获取compiler-rt源代码 123## 定位到llvm工程目录下% cd llvm% git clone https://git.llvm.org/git/compiler-rt.git/ 获取libomp源代码 12% cd llvm% git clone https://git.llvm.org/git/openmp.git/ 获取libcxx和libcxxabi源代码 123% cd llvm% git clone https://git.llvm.org/git/libcxx.git/% git clone https://git.llvm.org/git/libcxxabi.git/ 获取测试用例 12% cd llvm% git clone https://git.llvm.org/git/test-suite.git/ Clang 使用CMake(一个用于构建，测试和打包软件的开源跨平台工具系列)进行构建 12345678910111213141516171819202122232425262728293031323334353637# LLVM 禁止源码内编译(in-tree build is not supported),创建一个与llvm工程同级的build目录% cd src/% mkdir build% cd build ## 安装cmake% brew install cmake## -G &lt;generator-name&gt;## Specify a build system generator.## cmake [{-D &lt;var&gt;=&lt;value&gt;}...] -P &lt;cmake-script-file&gt;## Create or update a cmake cache entry.## When cmake is first run in an empty build tree, it ## creates a CMakeCache.txt file and populates it with customizable settings for## the project. This option may be used to specify a setting that takes priority over the projectas default value. The option may## be repeated for as many cache entries as desired.## 会被存在build目录下的CMakeCache.txt中## -Wno-dev 忽略开发警告% cmake -G Ninja ../llvm/ \\ -DCMAKE_INSTALL_PREFIX=/opt/llvm \\ -DCMAKE_BUILD_TYPE=Release \\ -DLLVM_ENABLE_FFI=ON \\ -DLLVM_BUILD_LLVM_DYLIB=ON \\ -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \\ -DLLVM_TARGETS_TO_BUILD=\"host;AMDGPU\" \\ -Wno-dev## 安装 ninja## Ninja is a small build system with a focus on speed. ## It differs from other build systems in two major respects: it is designed to have its input files generated by a higher-level build system, and it is designed to run builds as fast as possible.% brew install ninja## -j N run N jobs in parallel [default=6, derived from CPUs available]## CMake Error at cmake_install.cmake:36 (file):## file INSTALL cannot set permissions on \"/opt/llvm/include/llvm\"## 加上sudo% sudo ninja -j4 install 替换Clang123456789## 查看系统的Clang的位置~% which clang/usr/bin/clang~% clang -v Apple LLVM version 10.0.0 (clang-1000.11.45.5)Target: x86_64-apple-darwin17.7.0Thread model: posixInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin 根据参考链接7 新建Xcode工程 创建用户自定义配置CC,并设置DEBUG时的值为编译完成后Clang二进制的位置。 ⌘ B 编译,查看编译输出的日志,证明已经使用了编译的Clang 错误原因: 1Unknown argument: '-index-store-path' 根据参考链接10,在Build Setting 中搜索index并将Enable Index-While-Building Functionality选项设置为NO ⌘ B 错误原因: 123456fatal error: error in backend: No available targets are compatible with triple \"arm64-apple-ios9.0.0\"clang-8: error: clang frontend command failed with exit code 70 (use -v to see invocation)clang version 8.0.0 (https://git.llvm.org/git/clang.git/ a6eb16ed631365f3bbadd0450ab52746c151794d) (https://git.llvm.org/git/llvm.git/ 1c98a2b870d058132698ae4d67ef954b13dc41b4)Target: aarch64-apple-darwin17.7.0Thread model: posixInstalledDir: /opt/llvm/bin 分析: 因为该手机架构是arm64而cmake编译时指定的是 -DLLVM_TARGETS_TO_BUILD=\"host;AMDGPU\",并没有对应的架构 HowToBuildOnARM cmake $LLVM_SRC_DIR -DCMAKE_BUILD_TYPE=Release -DLLVM_TARGETS_TO_BUILD=”ARM;X86;AArch64” 操作 12345678910111213141516## 重新编译% cmake -G Ninja ../llvm/ \\ -DCMAKE_INSTALL_PREFIX=/opt/llvm \\ -DCMAKE_BUILD_TYPE=Release \\ -DLLVM_ENABLE_FFI=ON \\ -DLLVM_BUILD_LLVM_DYLIB=ON \\ -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \\ -DLLVM_TARGETS_TO_BUILD=\"host;ARM;X86;AArch64\" \\ -Wno-dev## 确认% grep -r \"LLVM_TARGETS_TO_BUILD\" CMakeCache.txtCMakeCache.txt:LLVM_TARGETS_TO_BUILD:STRING=host;ARM;X86;AArch64## 安装 只会处理有变更的部分% sudo ninja -j4 install ⌘ B 成功 代码TryLLVM 参考 llvm.org 结构化编译器前端 Clang 介绍 编译器架构的王者LLVM cmake.org wiki-XcodeVersionInfo 下载标准库libcxx出现svn: E000104: Error running context: Connection reset by peer的解决方案 安装 LLVM + Clang 如何让Xcode使用clang的替代版本 Why can’t I create a directory under /opt without sudo compilation-error-when-using-xcode-9-0-with-clang-cannot-specify-o-when-genera","link":"/2018/12/24/Topic-Clang-Learn-Clang-01/"},{"title":"Clang学习历程 编译过程-词法分析","text":"前言《编译原理》中提到 编译器的第一个步骤是词法分析(Lexical Analysis)或扫描。词法分析器读入组成源程序的字符流,并且将它们组织成为有意义的词素(lexeme)的序列。对于每个词素,词法分析产生如下形式的词法单元(token)作为输出:&lt;token-name,attribute-value&gt;token-name 是一个语法分析步骤要使用的抽象符号attribute-value指向符号表中关于这个词法单元的条目 实验1234567891011int main(){ @autoreleasepool { int initial = 8; int six = 6; NSString* site = [[NSString alloc] initWithUTF8String:\"starming\"]; int rank = initial + six; int position = initial + rank * 60; NSLog(@\"%@ rank %d\", site, position); } return 0;} 123456789101112131415161718192021222324252627282930## 使用手工编译的clang执行如下指令## -fmodules Enable the 'modules' language feature## This will make any modules-enabled software libraries available as modules as well as introducing any modules-specific syntax.## -E Only run the preprocessor## 只运行预处理器## -Xclang &lt;arg&gt; Pass &lt;arg&gt; to the clang compiler## -dump-tokens -- man clang/ clang --help 都没不到## 参考1## http://clang.llvm.org/doxygen/namespaceclang_1_1driver_1_1options.html## enum clang::driver::options::ClangFlags## Flags specifically for clang options.## 参考2## Running the plugin## Using the cc1 command line## To run a plugin, the dynamic library containing the plugin registry # must be loaded via the -load command line option. This will load all plugins that are registered, and you can select the plugins to run by specifying the -plugin option. Additional parameters for the plugins can be passed with -plugin-arg-&lt;plugin-name&gt;.## Note that those options must reach clang’s cc1 process. There are two ways to do so:## grep -r \"dump-tokens\" src/llvm/tools/clang## src/llvm/tools/clang/include/clang/Driver/CC1Options.td:def dump_tokens : Flag&lt;[\"-\"], \"dump-tokens\"&gt;,## 根据上面的两个参考链接 + grep的结果确定-dump-tokens应该就是这么来的## grep -r \"dump_tokens\" src/llvm/tools/clang## src/llvm/tools/clang/lib/Frontend/CompilerInvocation.cpp: case OPT_dump_tokens:## static InputKind ParseFrontendArgs(FrontendOptions &amp;Opts, ArgList &amp;Args,## DiagnosticsEngine &amp;Diags,## bool &amp;IsHeaderFile) {## ...## case OPT_dump_tokens:## Opts.ProgramAction = frontend::DumpTokens; break; ~% /opt/llvm/bin/clang -fmodules -E -Xclang -dump-tokens main.m 结果如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879annot_module_include '#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) { @autoreleasepool { int initial = 8; ' Loc=&lt;main.m:9:1&gt;int 'int' [StartOfLine] Loc=&lt;main.m:11:1&gt;identifier 'main' [LeadingSpace] Loc=&lt;main.m:11:5&gt;l_paren '(' Loc=&lt;main.m:11:9&gt;int 'int' Loc=&lt;main.m:11:10&gt;identifier 'argc' [LeadingSpace] Loc=&lt;main.m:11:14&gt;comma ',' Loc=&lt;main.m:11:18&gt;const 'const' [LeadingSpace] Loc=&lt;main.m:11:20&gt;char 'char' [LeadingSpace] Loc=&lt;main.m:11:26&gt;star '*' [LeadingSpace] Loc=&lt;main.m:11:31&gt;identifier 'argv' [LeadingSpace] Loc=&lt;main.m:11:33&gt;l_square '[' Loc=&lt;main.m:11:37&gt;r_square ']' Loc=&lt;main.m:11:38&gt;r_paren ')' Loc=&lt;main.m:11:39&gt;l_brace '{' [LeadingSpace] Loc=&lt;main.m:11:41&gt;at '@' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:12:5&gt;identifier 'autoreleasepool' Loc=&lt;main.m:12:6&gt;l_brace '{' [LeadingSpace] Loc=&lt;main.m:12:22&gt;int 'int' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:13:9&gt;identifier 'initial' [LeadingSpace] Loc=&lt;main.m:13:13&gt;equal '=' [LeadingSpace] Loc=&lt;main.m:13:21&gt;numeric_constant '8' [LeadingSpace] Loc=&lt;main.m:13:23&gt;semi ';' Loc=&lt;main.m:13:24&gt;int 'int' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:14:9&gt;identifier 'six' [LeadingSpace] Loc=&lt;main.m:14:13&gt;equal '=' [LeadingSpace] Loc=&lt;main.m:14:17&gt;numeric_constant '6' [LeadingSpace] Loc=&lt;main.m:14:19&gt;semi ';' Loc=&lt;main.m:14:20&gt;identifier 'NSString' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:15:9&gt;star '*' Loc=&lt;main.m:15:17&gt;identifier 'site' [LeadingSpace] Loc=&lt;main.m:15:19&gt;equal '=' [LeadingSpace] Loc=&lt;main.m:15:24&gt;l_square '[' [LeadingSpace] Loc=&lt;main.m:15:26&gt;l_square '[' Loc=&lt;main.m:15:27&gt;identifier 'NSString' Loc=&lt;main.m:15:28&gt;identifier 'alloc' [LeadingSpace] Loc=&lt;main.m:15:37&gt;r_square ']' Loc=&lt;main.m:15:42&gt;identifier 'initWithUTF8String' [LeadingSpace] Loc=&lt;main.m:15:44&gt;colon ':' Loc=&lt;main.m:15:62&gt;string_literal '\"starming\"' Loc=&lt;main.m:15:63&gt;r_square ']' Loc=&lt;main.m:15:73&gt;semi ';' Loc=&lt;main.m:15:74&gt;int 'int' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:16:9&gt;identifier 'rank' [LeadingSpace] Loc=&lt;main.m:16:13&gt;equal '=' [LeadingSpace] Loc=&lt;main.m:16:18&gt;identifier 'initial' [LeadingSpace] Loc=&lt;main.m:16:20&gt;plus '+' [LeadingSpace] Loc=&lt;main.m:16:28&gt;identifier 'six' [LeadingSpace] Loc=&lt;main.m:16:30&gt;semi ';' Loc=&lt;main.m:16:33&gt;int 'int' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:17:9&gt;identifier 'position' [LeadingSpace] Loc=&lt;main.m:17:13&gt;equal '=' [LeadingSpace] Loc=&lt;main.m:17:22&gt;identifier 'initial' [LeadingSpace] Loc=&lt;main.m:17:24&gt;plus '+' [LeadingSpace] Loc=&lt;main.m:17:32&gt;identifier 'rank' [LeadingSpace] Loc=&lt;main.m:17:34&gt;star '*' [LeadingSpace] Loc=&lt;main.m:17:39&gt;numeric_constant '60' [LeadingSpace] Loc=&lt;main.m:17:41&gt;semi ';' Loc=&lt;main.m:17:43&gt;identifier 'NSLog' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:18:9&gt;l_paren '(' Loc=&lt;main.m:18:14&gt;at '@' Loc=&lt;main.m:18:15&gt;string_literal '\"%@ rank %d\"' Loc=&lt;main.m:18:16&gt;comma ',' Loc=&lt;main.m:18:28&gt;identifier 'site' [LeadingSpace] Loc=&lt;main.m:18:30&gt;comma ',' Loc=&lt;main.m:18:34&gt;identifier 'position' [LeadingSpace] Loc=&lt;main.m:18:36&gt;r_paren ')' Loc=&lt;main.m:18:44&gt;semi ';' Loc=&lt;main.m:18:45&gt;r_brace '}' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:19:5&gt;return 'return' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:20:5&gt;numeric_constant '0' [LeadingSpace] Loc=&lt;main.m:20:12&gt;semi ';' Loc=&lt;main.m:20:13&gt;r_brace '}' [StartOfLine] Loc=&lt;main.m:21:1&gt;eof '' Loc=&lt;main.m:21:2&gt; 1234## 《编译原理》给的例子position = initial + rate * 60## 对应词法序列&lt;id,1&gt; &lt; = &gt; &lt;id,2&gt; &lt; + &gt; &lt;id,3&gt; &lt; * &gt;&lt;60&gt; 12345678910111213## int position = initial + rank * 60;int 'int' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:17:9&gt;identifier 'position' [LeadingSpace] Loc=&lt;main.m:17:13&gt;equal '=' [LeadingSpace] Loc=&lt;main.m:17:22&gt;identifier 'initial' [LeadingSpace] Loc=&lt;main.m:17:24&gt;plus '+' [LeadingSpace] Loc=&lt;main.m:17:32&gt;identifier 'rank' [LeadingSpace] Loc=&lt;main.m:17:34&gt;star '*' [LeadingSpace] Loc=&lt;main.m:17:39&gt;numeric_constant '60' [LeadingSpace] Loc=&lt;main.m:17:41&gt;semi ';' Loc=&lt;main.m:17:43&gt;## 可以获得每个 token 的类型，值还有类似 StartOfLine 的位置类型和 Loc=main.m:11:1 这个样的具体位置。## 和《编译原理》有点不同,attribute-value没有指向符号表中关于这个词法单元的条目 实现 定义词元 遍历字符流 &amp;&amp; 输出词元 案例定义词元入门教程中中的Kaleidoscope语言 12345678910111213141516171819//===----------------------------------------------------------------------===//// Lexer//===----------------------------------------------------------------------===//// The lexer returns tokens [0-255] if it is an unknown character, otherwise one// of these for known things.// 字符流解析词元规则,要么是如下5种类型,要么返回对应的ASCII值enum Token { tok_eof = -1, // commands tok_def = -2, tok_extern = -3, // primary tok_identifier = -4, tok_number = -5};static std::string IdentifierStr; // Filled in if tok_identifierstatic double NumVal; // Filled in if tok_number 遍历字符流 &amp;&amp; 输出词元1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/// gettok - Return the next token from standard input.static int gettok() { static int LastChar = ' '; // Skip any whitespace. /// 忽略空格 while (isspace(LastChar)) LastChar = getchar(); /// 判定是否是identifier 满足正则条件[a-zA-Z][a-zA-Z0-9]* if (isalpha(LastChar)) { // identifier: [a-zA-Z][a-zA-Z0-9]* IdentifierStr = LastChar; while (isalnum((LastChar = getchar()))) IdentifierStr += LastChar; /// 排除保留的关键字 if (IdentifierStr == \"def\") return tok_def; if (IdentifierStr == \"extern\") return tok_extern; return tok_identifier; } /// 判定是否是数字 满足正则条件 [0-9.]+ if (isdigit(LastChar) || LastChar == '.') { // Number: [0-9.]+ std::string NumStr; do { NumStr += LastChar; LastChar = getchar(); } while (isdigit(LastChar) || LastChar == '.'); NumVal = strtod(NumStr.c_str(), 0); return tok_number; } /// 判定是否是注释 if (LastChar == '#') { // Comment until end of line. do LastChar = getchar(); while (LastChar != EOF &amp;&amp; LastChar != '\\n' &amp;&amp; LastChar != '\\r'); if (LastChar != EOF) return gettok(); } // Check for end of file. Don't eat the EOF. if (LastChar == EOF) return tok_eof; // Otherwise, just return the character as its ascii value. /// 返回字符的ascii值 int ThisChar = LastChar; LastChar = getchar(); return ThisChar;} 理论正则表达式正则表达式（Regular Expression，RE）是一种用来描述正则语言的更紧凑的表达方式。 每个正则表达式 r 定义（表示）一个语言，记为 L（r）。这个语言也是根据 r 的子表达式所表示的语言递归定义的。 Σ 是给定的有限字符集ε 是空串(empty string) 归纳基础: ε是一个正则表达式,L(ε) = {ε},即该语言只包含空串 如果 a ∈ Σ,那么a是一个正则表达式,且L(a) = {a}。即这个语言仅包含一个长度为1的符号串a。 归纳步骤:假设 r 和 s 都是正则表达式,表示的语言分别是L(r)和L(s) r|s 是一个正则表达式,L(r|s) = L(r)∪L(s) rs(r 和 s 的连接)是一个正则表达式,L(rs)=L(r)L(s) r* 是一个正则表达式,L(r*) = (L(r))* (r)是一个正则表达式,L((r)) = L(r),表明表达式的两边加上括号并不影响表达式所表示的语言 运算符的优先级: * , 连接 , |* 号代表字符可以不出现，也可以出现一次或者多次 有穷自动机正则表达式描述的规则人容易理解,但是要解析字符串,还需要将其转化为计算机程序能理解的模型。 有穷自动机(Finite Automata，FA)是对一类处理系统建立的数学模型。这类系统具有一系列离散的输入输出信息和有穷数目的内部状态。 数学表达: M = (S,Σ,δ,s0,F) S: 有穷状态集Σ: 字符表δ: 转换函数s0: 初始状态F: 结束/可接受状态集 表示方法有穷自动机可以用转换图来表示。 初始状态(开始状态):只有一个，有 start 箭头指向 终止状态/可接受状态:可以有多个,用双圈表示 分类 确定的有穷自动机（DFA） 不确定的有穷自动机（NFA） 非确定有穷自动机NFA 和确定的有穷自动机DFA 唯一的区别是：从状态 s 出发，能到达的状态可能有多个。（并不是唯一确定的） 因此，转换函数为集合，而不是元素。 DFA NFA 对应的正则表达式是 (a|b)*abb 从正则表达式到有穷自动机因为NFA 同一输入导出多种状态,判定接受比较麻烦,因此,一般会将NFA转换为DFA来实现 简而言之,要做的就是 RE -&gt; NFA -&gt; DFA Thompson 算法 (RE 到 NFA)正则表达式是递归定义的,通过不停的分解子表达式，即可求得最终的 NFA。 比如 r=（a|b）*abb 对应的 NFA 子集构造法 (NFA 到 DFA)子集构造法的基本思想是让构造得到的DFA的每个状态对应于NFA的一个状态集合 正则表达式 (a|b)*abb 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960状态0 记为 s0s0 输入 a 可到达状态{0,1} 记为s1s0 -&gt; a = {0,1} = s1s0 输入 b 可到到状态{0} 即s0s0 -&gt; b = {0} = s0s1 输入 a 当处于状态0时,可到达{0,1}当处于状态1时,可到达∅ 两者取并集可到达状态{0,1} 即s1(s1,a) -&gt; {0,1} = s1s1 输入 b 可到达状态{0,2} 记为s2(s1,b) -&gt; {0,2} = s2s2 输入 a当处于状态0时,可到达{0,1}当处于状态2时,可到达∅,两者取并集可到达状态{0,1} 即s1s2 输入 a 可到达{0,1}(s2,a) -&gt; {0,1} = s1s2 输入 b 当处于状态0时,可到达{0}当处于状态2时,可到达{3},两者取并集可到达状态{0,3},记为s3(s2,b) -&gt; {0,3} = s3s3 输入 a0 -&gt; {0,1}3 -&gt; ∅{0,1} U ∅ =&gt; {0,1} = s1(s3,a) -&gt; {0,1} = s1s3 输入 b0 -&gt; {0}3 -&gt; ∅{0} U ∅ =&gt; {0} = s0(s3,b) -&gt; s0到s3继续输入a|b,回到s0/s1,没有新的状态,再输入只会重新执行上面的过程,因此构造结束,包含状态3的是终止节点对上面的过程进行梳理可得s0 是初始状态s0 输入 b 到 s0 状态s0 输入 a 到 s1 状态s1 输入 a 到 s1 状态s1 输入 b 到 s2 状态s2 输入 a 到 s1 状态s2 输入 b 到 s3 状态s3 输入 a 到 s1 状态s3 输入 b 到 s0 状态 整个思考过程处理成表格的形式 状态集\\条件 a b 0 {0,1} =&gt; s1 {0} =&gt; s0 1 {0,1} =&gt; s1 {2} =&gt; s2 2 {0,1} =&gt; s1 {0,3} =&gt; s3 3 {0,1} =&gt; s1 {0} =&gt; s0 另外一种情况 NFA 中包含 ε 边比如参考链接9中举的例子 正则表达式为 a (b|c)* 123456789101112131415161718192021222324字符集为{a,b,c}设s0 = n0s0 输入a可到达状态{n1} ``ε`` 不消耗代价,可以略过,因此实际可到达为 {n1,n2,n3,n4,n6,n9} 记为 s1状态s0 通过ε转换到达的NFA状态集合ε.closure(s0) = {n1,n2,n3,n4,n6,n9} = s1 终止状态(包含了n9)观察上面的图+思考比较容易判断出,哪些情况下输入b,c得到的结果不会是∅ ,即有效的s1 输入bε.closure(Move(s1,b)) = {n5,n8,n9,n3,n4,n6} = s2 终止状态s1 输入cε.closure(Move(s1,c)) = {n7,n8,n9,n3,n4,n6} = s3 终止状态s2 输入bε.closure(Move(s2,b)) = {n5,n8,n9,n3,n4,n6} = s2s2 输入 cε.closure(Move(s2,c)) = {n7,n8,n9,n3,n4,n6} = s3s3 输入 bε.closure(Move(s3,b)) = {n5,n8,n9,n3,n4,n6} = s2s3 输入 cε.closure(Move(s3,c)) = {n5,n8,n9,n3,n4,n6} = s3 状态集\\条件 a b c s0 {n1,n2,n3,n4,n6,n9} =&gt; s1 ∅ ∅ s1 ∅ {n5,n8,n9,n3,n4,n6} =&gt; s2 {n7,n8,n9,n3,n4,n6} =&gt; s3 s2 ∅ {n5,n8,n9,n3,n4,n6} =&gt; s2 {n7,n8,n9,n3,n4,n6} =&gt; s3 s3 ∅ {n5,n8,n9,n3,n4,n6} =&gt; s2 {n7,n8,n9,n3,n4,n6} =&gt; s3 参考链接9 12345678910111213141516171819202122/// 子集构造算法: 工作表算法 /// 初始状态s0 &lt;- eps_closure(n0)Q &lt;- {s0}/// 将初始状态添加到工作表中workList &lt;- s0while (workList != []) /// 将该状态添加到 remove s from workList foreach (character c) /** 1.遍历状态集s在输入条件c下得到的状态集合 2.通过e-closure扩展边界,然后取并集,得到最终的状态集 */ t &lt;- e-closure(delta(s,c)) D[s,c] &lt;- t /** 判断标准: 经过e-closure 转换,发现新的状态,继续进行子集构造操作, 否则证明这条分支的转换结束,继续判断工作列表中是否为空 */ if (t not in Q) add t to Q and workList 因为有限集合的子集是有限的,N个元素的集合,最多有2^N个子集,每次遍历都会将状态加入到Q中,所以循环最终会结束。 DFA的状态数有可能是NFA状态数的指数,在这种情况下,我们在试图实现这个DFA时会遇到困难。然而,基于自动机的词法分析方法的处理部分源于如下事实:对于一个真实的语言,它的NFA和DFA的状态数量大致相同,状态数量呈指数关系的情形尚未在实践中出现过— 《编译原理》 Hopcroft 算法 (最小化 DFA)经过前面两步,已经将 RE,转换成DFA,但是还需要进行最小化的操作 参考链接9 123456789101112131415split(s) foreach(character c) /** 输入字符c到状态集合s中,每种状态输出的状态集存在不一致的情况,证明字符c可以切割这个状态集合s */ if (c can split s) split s into T1,...,Tk hopcroft() /** 首次划分: N非结束状态,A结束状态 */ split all nodes into N,A while (set is still changes) split(s) 将所有终止状态合并为状态s4 该状态s4接收字符b,c 123456789用字符b尝试切割状态1 输入 b 得到状态2 在状态s4中状态2 输入 b 得到状态2 在状态s4中状态3 输入 b 空集 忽略无法通过字符b找到一个不属于状态s4的状态对字符c同理,因此可以合并 Clang 中的实现要解决的问题是: Clang 是如何进行词法分析的? 如何使用lldb 调试Clang 工程在上面的实验分析,发现终端在执行clang 指令时,最终会传递到CompilerInvocation.cpp 这个文件的ParseFrontendArgs方法中。指令的完成后,进程就结束了,并不像iOS 应用会有运行循环。 因此在CompilerInvocation.cpp文件中 123456789引入 #include &lt;unistd.h&gt; 头文件添加延时的操作case OPT_dump_tokens: Opts.ProgramAction = frontend::DumpTokens; sleep(20); break;重新sudo ninja -j4 install 窗口A执行 12## 定位到工程目录中/opt/llvm/bin/clang-8 -fmodules -E -Xclang -dump-tokens main.mm 窗口B执行 123456~ % ps -ef | grep clang## 会有类似下面的输出% ps -ef | grep clang-8 501 497 3105 0 11:11AM ttys000 0:00.01 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn clang-8 501 384 13315 0 11:11AM ttys001 0:00.06 /opt/llvm/bin/clang-8 -fmodules -E -Xclang -dump-tokens main.mm 501 392 384 0 11:11AM ttys001 0:00.01 /opt/llvm/bin/clang-8 -cc1 -triple x86_64-apple-macosx10.13.0 -Wdeprecated-objc-isa-usage -Werror=deprecated-objc-isa-usage -E -disable-free -disable-llvm-verifier -discard-value-names -main-file-name main.mm -mrelocation-model pic -pic-level 2 -mthread-model posix -mdisable-fp-elim -masm-verbose -munwind-tables -target-cpu penryn -dwarf-column-info -debugger-tuning=lldb -ggnu-pubnames -target-linker-version 409.12 -resource-dir /opt/llvm/lib/clang/8.0.0 -stdlib=libc++ -internal-isystem /opt/llvm/include/c++/v1 -fdeprecated-macro -fdebug-compilation-dir /Users/Jason/Desktop/TryLLVM/prj/LLVM_02/LLVM_02 -ferror-limit 19 -fmessage-length 158 -stack-protector 1 -fblocks -fencode-extended-block-signature -fmodules -fimplicit-module-maps -fmodules-cache-path=/var/folders/lk/znn1qp4925j412wt4t_qkplc0000gn/C/org.llvm.clang.Jason/ModuleCache -fmodules-validate-system-headers -fregister-global-dtors-with-atexit -fobjc-runtime=macosx-10.13.0 -fobjc-exceptions -fcxx-exceptions -fexceptions -fmax-type-align=16 -fdiagnostics-show-option -fcolor-diagnostics -dump-tokens -o - -x objective-c++ main.mm 窗口C执行 123456## 进入lldb 交互环境~% lldb ## attach到对应的进程上 选带cc1的那个进程~% process attach --pid 392## 查看调用栈~% bt all 查看源代码,经过整理后,大致是这样的 12345## CompilerInvocation.cppCompilerInvocation::CreateFromArgs 调用ParseFrontendArgs 调用## FrontendAction.cppDumpTokensAction::ExecuteAction 1234567891011void DumpTokensAction::ExecuteAction() { Preprocessor &amp;PP = getCompilerInstance().getPreprocessor(); // Start preprocessing the specified input file. Token Tok; PP.EnterMainSourceFile(); do { PP.Lex(Tok); PP.DumpToken(Tok, true); llvm::errs() &lt;&lt; \"\\n\"; } while (Tok.isNot(tok::eof));} 123456789101112131415161718192021222324252627282930313233void Preprocessor::Lex(Token &amp;Result) { // We loop here until a lex function returns a token; this avoids recursion. bool ReturnedToken; do { switch (CurLexerKind) { case CLK_Lexer: ReturnedToken = CurLexer-&gt;Lex(Result); break; case CLK_TokenLexer: ReturnedToken = CurTokenLexer-&gt;Lex(Result); break; case CLK_CachingLexer: CachingLex(Result); ReturnedToken = true; break; case CLK_LexAfterModuleImport: LexAfterModuleImport(Result); ReturnedToken = true; break; } } while (!ReturnedToken); if (Result.is(tok::code_completion) &amp;&amp; Result.getIdentifierInfo()) { // Remember the identifier before code completion token. setCodeCompletionIdentifierInfo(Result.getIdentifierInfo()); setCodeCompletionTokenRange(Result.getLocation(), Result.getEndLoc()); // Set IdenfitierInfo to null to avoid confusing code that handles both // identifiers and completion tokens. Result.setIdentifierInfo(nullptr); } LastTokenWasAt = Result.is(tok::at);} 1234567891011121314151617181920212223void Preprocessor::DumpToken(const Token &amp;Tok, bool DumpFlags) const { llvm::errs() &lt;&lt; tok::getTokenName(Tok.getKind()) &lt;&lt; \" '\" &lt;&lt; getSpelling(Tok) &lt;&lt; \"'\"; if (!DumpFlags) return; llvm::errs() &lt;&lt; \"\\t\"; if (Tok.isAtStartOfLine()) llvm::errs() &lt;&lt; \" [StartOfLine]\"; if (Tok.hasLeadingSpace()) llvm::errs() &lt;&lt; \" [LeadingSpace]\"; if (Tok.isExpandDisabled()) llvm::errs() &lt;&lt; \" [ExpandDisabled]\"; if (Tok.needsCleaning()) { const char *Start = SourceMgr.getCharacterData(Tok.getLocation()); llvm::errs() &lt;&lt; \" [UnClean='\" &lt;&lt; StringRef(Start, Tok.getLength()) &lt;&lt; \"']\"; } llvm::errs() &lt;&lt; \"\\tLoc=&lt;\"; DumpLocation(Tok.getLocation()); llvm::errs() &lt;&lt; \"&gt;\";} 在CompilerInvocation::CreateFromArgs 方法上也做类似延时的操作,然后设置断点 1(lldb) br set --name ParseFrontendArgs 参数Token的结构如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354namespace clang {class IdentifierInfo;/// Token - This structure provides full information about a lexed token./// It is not intended to be space efficient, it is intended to return as much/// information as possible about each returned token. This is expected to be/// compressed into a smaller form if memory footprint is important.////// The parser can create a special \"annotation token\" representing a stream of/// tokens that were parsed and semantically resolved, e.g.: \"foo::MyClass&lt;int&gt;\"/// can be represented by a single typename annotation token that carries/// information about the SourceRange of the tokens and the type object.class Token { /// The location of the token. This is actually a SourceLocation. unsigned Loc; // Conceptually these next two fields could be in a union. However, this // causes gcc 4.2 to pessimize LexTokenInternal, a very performance critical // routine. Keeping as separate members with casts until a more beautiful fix // presents itself. /// UintData - This holds either the length of the token text, when /// a normal token, or the end of the SourceRange when an annotation /// token. /// token 的长度 unsigned UintData; /// PtrData - This is a union of four different pointer types, which depends /// on what type of token this is: /// Identifiers, keywords, etc: /// This is an IdentifierInfo*, which contains the uniqued identifier /// spelling. /// Literals: isLiteral() returns true. /// This is a pointer to the start of the token in a text buffer, which /// may be dirty (have trigraphs / escaped newlines). /// Annotations (resolved type names, C++ scopes, etc): isAnnotation(). /// This is a pointer to sema-specific data for the annotation token. /// Eof: // This is a pointer to a Decl. /// Other: /// This is null. /// token的内容 void *PtrData; /// Kind - The actual flavor of token this is. /// token的类型 tok::TokenKind Kind; /// Flags - Bits we track about this token, members of the TokenFlags enum. unsigned short Flags;public: ... tok::TokenKind 的声明 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576TokenKinds.hnamespace tok {/// Provides a simple uniform namespace for tokens from all C languages.enum TokenKind : unsigned short {#define TOK(X) X,#include \"clang/Basic/TokenKinds.def\" NUM_TOKENS};/// Provides a namespace for preprocessor keywords which start with a/// '#' at the beginning of the line.enum PPKeywordKind {#define PPKEYWORD(X) pp_##X,#include \"clang/Basic/TokenKinds.def\" NUM_PP_KEYWORDS};/// Provides a namespace for Objective-C keywords which start with/// an '@'.enum ObjCKeywordKind {#define OBJC_AT_KEYWORD(X) objc_##X,#include \"clang/Basic/TokenKinds.def\" NUM_OBJC_KEYWORDS};// clang/Basic/TokenKinds.def...// C99 6.4.2: Identifiers.TOK(identifier) // abcde123TOK(raw_identifier) // Used only in raw lexing mode.// C99 6.4.4.1: Integer Constants// C99 6.4.4.2: Floating ConstantsTOK(numeric_constant) // 0x123// C99 6.4.4: Character ConstantsTOK(char_constant) // 'a'TOK(wide_char_constant) // L'b'// C++17 Character ConstantsTOK(utf8_char_constant) // u8'a'// C++11 Character ConstantsTOK(utf16_char_constant) // u'a'TOK(utf32_char_constant) // U'a'// C99 6.4.5: String Literals.TOK(string_literal) // \"foo\"TOK(wide_string_literal) // L\"foo\"TOK(angle_string_literal)// &lt;foo&gt;// C++11 String Literals.TOK(utf8_string_literal) // u8\"foo\"TOK(utf16_string_literal)// u\"foo\"TOK(utf32_string_literal)// U\"foo\"// C99 6.4.6: Punctuators.PUNCTUATOR(l_square, \"[\")PUNCTUATOR(r_square, \"]\")PUNCTUATOR(l_paren, \"(\")PUNCTUATOR(r_paren, \")\")PUNCTUATOR(l_brace, \"{\")PUNCTUATOR(r_brace, \"}\")PUNCTUATOR(period, \".\")PUNCTUATOR(ellipsis, \"...\")PUNCTUATOR(amp, \"&amp;\")PUNCTUATOR(ampamp, \"&amp;&amp;\")PUNCTUATOR(ampequal, \"&amp;=\")PUNCTUATOR(star, \"*\")PUNCTUATOR(starequal, \"*=\")PUNCTUATOR(plus, \"+\")PUNCTUATOR(plusplus, \"++\")PUNCTUATOR(plusequal, \"+=\")... 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/// Lexer.cpp/// LexTokenInternal - This implements a simple C family lexer. It is an/// extremely performance critical piece of code. This assumes that the buffer/// has a null character at the end of the file. This returns a preprocessing/// token, not a normal token, as such, it is an internal interface. It assumes/// that the Flags of result have been cleared before calling this./// 词法分析的方法bool Lexer::LexTokenInternal(Token &amp;Result, bool TokAtPhysicalStartOfLine)...// Read a character, advancing over it. char Char = getAndAdvanceChar(CurPtr, Result); tok::TokenKind Kind;/// 遍历字符 switch (Char) {...case '\\n': // If we are inside a preprocessor directive and we see the end of line, // we know we are done with the directive, so return an EOD token. if (ParsingPreprocessorDirective) { // Done parsing the \"line\". ParsingPreprocessorDirective = false; // Restore comment saving mode, in case it was disabled for directive. if (PP) resetExtendedTokenMode(); // Since we consumed a newline, we are back at the start of a line. IsAtStartOfLine = true; IsAtPhysicalStartOfLine = true; /// 比如\\n类型就判断tok::end类型 Kind = tok::eod; break; }... // C99 6.4.4.1: Integer Constants. // C99 6.4.4.2: Floating Constants. // 整形常量 case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': // Notify MIOpt that we read a non-whitespace/non-comment token. MIOpt.ReadToken(); return LexNumericConstant(Result, CurPtr);... // C99 6.4.2: Identifiers. 是不是标识符 case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G': case 'H': case 'I': case 'J': case 'K': /*'L'*/case 'M': case 'N': case 'O': case 'P': case 'Q': /*'R'*/case 'S': case 'T': /*'U'*/ case 'V': case 'W': case 'X': case 'Y': case 'Z': case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g': case 'h': case 'i': case 'j': case 'k': case 'l': case 'm': case 'n': case 'o': case 'p': case 'q': case 'r': case 's': case 't': /*'u'*/ case 'v': case 'w': case 'x': case 'y': case 'z': case '_': // Notify MIOpt that we read a non-whitespace/non-comment token. MIOpt.ReadToken(); return LexIdentifier(Result, CurPtr);/// LexNumericConstant - Lex the remainder of a integer or floating point/// constant. From[-1] is the first character lexed. Return the end of the/// constant.bool Lexer::LexNumericConstant(Token &amp;Result, const char *CurPtr) {.../// 类型设置为 tok::numeric_constantFormTokenWithChars(Result, CurPtr, tok::numeric_constant);.../// 判断是否是标识符bool Lexer::LexIdentifier(Token &amp;Result, const char *CurPtr) { // Match [_A-Za-z0-9]*, we have already matched [_A-Za-z$] unsigned Size; unsigned char C = *CurPtr++;... 参考 LLVM Tutorial 第一章 教程简介与词法分析器 深入剖析 iOS 编译 Clang LLVM Lexical_analysis 编译原理（3）：词法分析 Wiki Regular expression 编译原理：有穷自动机（DFA与NFA） 【编译原理】:NFA转变为DFA的子集构造法 网易云课堂 - 编译原理 状态图制作网站 64位汇编参数传递","link":"/2018/12/28/Topic-Clang-Learn-Clang-02/"},{"title":"iOS崩溃日志分析","text":"环境 macOS Mojave 10.14.3Xcode10.1iPhone6S 10.0.1 获得崩溃日志方式一:Xcode菜单 &gt; Window &gt; Devices and Simulators 选择设备并查看设备日志(View Device Logs) 方式二:手机设置 &gt; 隐私 &gt; 诊断与用量 &gt; 诊断与用量数据 崩溃日志的结构头部(Header) Incident Identifier: 崩溃日志的唯一标识 CrashReporter Key: 匿名的设备标识 Process:进程名 Path:二进制文件路径 Identifier:包名 Version:应用版本号 Code Type: 目标架构 Role:进程终止时进程被赋予的task_role枚举值… 1234567891011121314151617Incident Identifier: F21EC10C-018D-494F-997D-E9C9D82B2F7FCrashReporter Key: ab7fcdf6938542fd82446362e0481f7fddba141fHardware Model: iPhone6,2Process: JACrash [27195]Path: /private/var/containers/Bundle/Application/EDDDCB8E-75CE-4638-84CA-5B7971F6EFE0/JACrash.app/JACrashIdentifier: com.ishepherdme.JACrashVersion: 1 (1.0)Code Type: ARM-64 (Native)Role: ForegroundParent Process: launchd [1]Coalition: com.ishepherdme.JACrash [4182]Date/Time: 2019-02-08 13:03:58.7771 +0800Launch Time: 2019-02-08 13:03:58.3811 +0800OS Version: iPhone OS 10.0.1 (14A403)Report Version: 104 异常信息(Exception Information) Triggered by Thread: 产生崩溃的线程 Exception Type: 崩溃类型… 1234Exception Type: EXC_CRASH (SIGABRT)Exception Codes: 0x0000000000000000, 0x0000000000000000Exception Note: EXC_CORPSE_NOTIFYTriggered by Thread: 0 其他诊断信息 Application Specific Information:在进程终止时框架捕获的错误信息… 12345Application Specific Information:abort() calledFiltered syslog:None found 线程回溯罗列崩溃时每个线程的调用栈情况 12345678910111213141516Thread 0 name: Dispatch queue: com.apple.main-threadThread 0 Crashed:0 libsystem_kernel.dylib 0x000000018af0e014 __pthread_kill + 81 libsystem_pthread.dylib 0x000000018afd5460 pthread_kill + 1122 libsystem_c.dylib 0x000000018ae823f4 abort + 1403 libc++abi.dylib 0x000000018a94d2d4 __cxa_bad_cast + 04 libc++abi.dylib 0x000000018a96acc0 default_unexpected_handler+ 126144 () + 05 libobjc.A.dylib 0x000000018a978844 _objc_terminate+ 34884 () + 1246 libc++abi.dylib 0x000000018a96766c std::__terminate(void (*)+ 112236 ()) + 167 libc++abi.dylib 0x000000018a967234 __cxa_rethrow + 1448 libobjc.A.dylib 0x000000018a97871c objc_exception_rethrow + 449 CoreFoundation 0x000000018be1a0bc CFRunLoopRunSpecific + 56010 UIKit 0x0000000191df37cc -[UIApplication _run] + 60811 UIKit 0x0000000191dee550 UIApplicationMain + 20812 JACrash 0x000000010007de90 0x100078000 + 2420813 libdyld.dylib 0x000000018adfc5b8 start + 4 线程状态列出崩溃线程的线程状态。这是一个寄存器列表及其执行停止时的值。在阅读崩溃报告时，无需了解线程状态，但可以使用此信息更好地了解崩溃的情况。 12345678910Thread 0 crashed with ARM Thread State (64-bit): x0: 0x0000000000000000 x1: 0x0000000000000000 x2: 0x0000000000000000 x3: 0x00000001740e9737 x4: 0x000000018a96bbc3 x5: 0x000000016fd87520 x6: 0x000000000000006e x7: 0xffffffffffffffec x8: 0x0000000008000000 x9: 0x0000000004000000 x10: 0x000000000000000b x11: 0x0000000000000010 x12: 0x000000018ae99792 x13: 0x0000000000000000 x14: 0x0000030000000300 x15: 0x0000000000000000 x16: 0x0000000000000148 x17: 0x0000000000000000 x18: 0x0000000000000000 x19: 0x0000000000000006 x20: 0x00000001b0bf8c40 x21: 0x000000016fd87520 x22: 0x00000001b0bffbb8 x23: 0x0000000000000001 x24: 0x0000000170011110 x25: 0x0000000000000000 x26: 0x0000000000000001 x27: 0x0000000000000000 x28: 0x000000016fd87b80 fp: 0x000000016fd87480 lr: 0x000000018afd5460 sp: 0x000000016fd87460 pc: 0x000000018af0e014 cpsr: 0x00000000 二进制镜像进程二进制文件加载的地址区间,动态库加载的地址区间 1234567Binary Images:0x100078000 - 0x10007ffff JACrash arm64 &lt;2fd461c16e7239489a037c6c1141c134&gt; /var/containers/Bundle/Application/A55333A1-CD62-41A2-AE96-F3411ECD3447/JACrash.app/JACrash0x10009c000 - 0x10009ffff MobileSubstrate.dylib arm64 &lt;3134cfb2f722310ea2c742ae4dc131ab&gt; /Library/MobileSubstrate/MobileSubstrate.dylib0x1000a8000 - 0x1000affff libswiftCoreFoundation.dylib arm64 &lt;47deeaa1967b3e339dfcb48535a994e1&gt; /var/containers/Bundle/Application/A55333A1-CD62-41A2-AE96-F3411ECD3447/JACrash.app/Frameworks/libswiftCoreFoundation.dylib0x1000bc000 - 0x1000cbfff libswiftCoreGraphics.dylib arm64 &lt;25fe91aa901b3cf6a443b498012ab5af&gt; /var/containers/Bundle/Application/A55333A1-CD62-41A2-AE96-F3411ECD3447/JACrash.app/Frameworks/libswiftCoreGraphics.dylib0x1000f0000 - 0x1000f7fff libswiftCoreImage.dylib arm64 .... 关于异常类型(Exception Type)野指针(Bad Memory Access [EXC_BAD_ACCESS // SIGSEGV // SIGBUS])尝试访问了非法的内存地址,或访问了受保护的地址 123456Exception Type: EXC_BAD_ACCESS (SIGSEGV)Exception Subtype: KERN_INVALID_ADDRESS at 0x000000064229beb8Termination Signal: Segmentation fault: 11Termination Reason: Namespace SIGNAL, Code 0xbTerminating Process: exc handler [0]Triggered by Thread: 0 比如在MRC环境下尝试发送消息给已释放的对象,调用栈的特点是objc_msgSend/objc_release在调用栈顶 异常退出(Abnormal Exit [EXC_CRASH // SIGABRT])1234567891011121314151617@implementation ViewController- (void)viewDidLoad { [super viewDidLoad]; [self callCrashMethod];}- (void)callCrashMethod { [self arrayOutOfBounds];}- (void)arrayOutOfBounds { NSArray *arr = @[@\"0\",@\"1\"]; NSLog(@\"%@\",arr[2]);}@end 1234Exception Type: EXC_CRASH (SIGABRT)Exception Codes: 0x0000000000000000, 0x0000000000000000Exception Note: EXC_CORPSE_NOTIFYTriggered by Thread: 0 崩溃会直接到main,因为调用栈中包含objc_exception_rethrow栈帧,根据参考1,进行如下的配置,设置异常的断点 The Exception BreakpointSo how do you find the line in the code that made the app crash? Well, whenever you get a stacktrace like this, an exception was thrown by the app. (You can tell because one of the functions in the call stack is named objc_exception_rethrow.) 追踪陷阱(Trace Trap [EXC_BREAKPOINT // SIGTRAP])这个异常是为调试器提供在进程执行的特定点中断进程的机会。 123456Exception Type: EXC_BREAKPOINT (SIGTRAP)Exception Codes: 0x0000000000000001, 0x000000010006e588Termination Signal: Trace/BPT trap: 5Termination Reason: Namespace SIGNAL, Code 0x5Terminating Process: exc handler [0]Triggered by Thread: 0 非法指令(Illegal Instruction)进程试图执行非法或未定义指令。这个进程可能试图通过一个配置错误的函数指针，跳到一个无效的地址。 1234567Exception Type: EXC_CRASH (SIGILL)Exception Codes: 0x0000000000000000, 0x0000000000000000Exception Note: EXC_CORPSE_NOTIFYTermination Signal: Illegal instruction: 4Termination Reason: Namespace SIGNAL, Code 0x4Terminating Process: neteasemusic [6562]Triggered by Thread: 0 被杀死(Killed[SIGKILL])12345Exception Type: EXC_CRASH (SIGKILL)Exception Codes: 0x0000000000000000, 0x0000000000000000Exception Note: EXC_CORPSE_NOTIFYTermination Reason: Namespace SPRINGBOARD, Code 0x8badf00dTriggered by Thread: 0 资源限制(Resource Limit [EXC_RESOURCE])这个进程超出了资源消耗的限制。 符号化 来自参考3 方式一:dSYM文件DWARF 即Debugging with Attributed Record Formats,Xcode使用它来生成符号表,生成的符号表放在.dSYM文件中,在Debug模式下,默认不会生成.dSYM文件,可以在Build Settings中进行设置 编译后,在工程中Product目录下,选择应用程序,Show in Finder,会发现生成了应用的.dSYM文件 获取UUID12Binary Images:0x1000f8000 - 0x1000fffff JACrash arm64 &lt;2fd461c16e7239489a037c6c1141c134&gt; /var/containers/Bundle/Application/7B72F18F-930E-42CB-B69C-FED75161A03F/JACrash.app/JACrash UUID:2fd461c16e7239489a037c6c1141c134 123% dwarfdump --uuid path/to/Your.app.dSYM/Contents/Resources/DWARF/JACrash...UUID: 2FD461C1-6E72-3948-9A03-7C6C1141C134 (arm64) /Users/Jason/Library/Developer/Xcode/DerivedData/JACrash-bntjxfwsvrraeuevozrbvraorxqv/Build/Products/Debug-iphoneos/JACrash.app.dSYM/Contents/Resources/DWARF/JACrash 两者UDID一致即可 定位崩溃地址123% atos -o path/to/Your.app.dSYM/Contents/Resources/DWARF/Your -arch arm64 -l 0x1000f8000 0x1000fdda8-[ViewController arrayOutOfBounds] (in JACrash) (ViewController.m:33) 0x1000f8000: 运行时应用基地址0x1000fdda8: 运行时崩溃地址(待符号化的地址) 支持bitcode 支持bitcode的情况下,因为最终的二进制文件由Apple Store后台生成,本地是没有对应的.dSYM文件,可以从Xcode或iTunes Connect上下载 方式二:崩溃日志 + Hopper如果没有.dSYM文件,但有崩溃日志的情况时 崩溃地址 = 基地址 + ASLR + 方法偏移地址 方法相对基地址的偏移地址是不变的,因此只要把ASLR从崩溃地址中移除,再加上方法的偏移地址即可 用hopper找出基地址,再加上方法偏移地址 异常捕获监听12345/// 函数指针,用于自定义捕获异常后要进行的操作typedef void NSUncaughtExceptionHandler(NSException *exception);FOUNDATION_EXPORT NSUncaughtExceptionHandler * _Nullable NSGetUncaughtExceptionHandler(void);FOUNDATION_EXPORT void NSSetUncaughtExceptionHandler(NSUncaughtExceptionHandler * _Nullable); 在程序启动时加上一个异常捕获监听，用来处理程序崩溃时的回调动作 123456789101112void exceptionHandler(NSException *exception) { NSLog(@\"%@\", [exception reason]); NSLog(@\"%@\", [exception userInfo]); NSLog(@\"%@\", [exception callStackSymbols]);}int main(int argc, char * argv[]) { NSSetUncaughtExceptionHandler(&amp;exceptionHandler); @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); }} 参考 My App Crashed, Now What? – Part 1 手动解析CrashLog之—-方法篇 Understanding and Analyzing Application Crash Reports Address space layout randomization NSSetUncaughtExceptionHandler not catch all errors on iPhone","link":"/2019/02/09/iOSer-Analysis-iOS-Crash/"},{"title":"浅析iOS启动图动画","text":"概要 启动图的价值 ?如何设置启动图 ?常见的启动图形式 ? 启动图的价值 A launch screen appears instantly when your app starts up. The launch screen is quickly replaced with the first screen of your app, giving the impression that your app is fast and responsive. The launch screen isn’t an opportunity for artistic expression. It’s solely intended to enhance the perception of your app as quick to launch and immediately ready for use. Every app must supply a launch screen. 启动屏主要是为了优化用户体验的 在启动屏上显示文字或广告的行为在Apple的设计规范上并不提倡 如何设置启动图 iOS8以下 针对不同尺寸的设备通过静态图片进行设置 也可以将图片命名成系统指定的名称,程序运行时会默认使用该文件可参考demo中的LaunchAnimate 注意:这两种方式都要把工程中的Launch Screen File内容置空,默认该配置的优先级最高 iOS8以上(包括iOS8) 可以使用LaunchScreen.storyboard进行设置 启动图片将在运行时生成? WWDC 2014 Platform State of the Union 通过Xcode导出沙盒文件,显示包内容AppData/Library/Cache/Snapshots/包名/xxx@3x.ktx或xxx@2x.png 一般只有几百字节到2,3KB,虽然称之为快照,但是看上去和原图差别还是挺大的,酷狗的启动图,只生成一张纯白的图,而纯色的启动图看上去确实进行了截屏,算是证明会在运行时生成启动图吧? 常见的启动图形式 静态图片,比如微信 启动图上有动态文字或动画,比如酷狗音乐,手机京东 启动图内容可变化(产品宣传/节日祝福/广告等),比如新浪微博,喜马拉雅 微信 酷狗启动图 微博 启动图动画设置限制:由上可知,LaunchScreen.storyboard方式下,运行时会生成截图,以后启动就会直接使用该截图,因此应用启动后的初识样式在设置后是不能改变的,然后在LaunchScreen.Storyboard不能是自定义的控制器,也不能放置自定义的视图。 方案:根据限制,不要琢磨往真正的启动图上去添加动态文字或是动画,而采用当启动图结束后再进行操作,从iOS8开始通过LaunchScreen.storyboard可以获得一个UIViewController,虽然不能绑定自定义类,但是既然是控制器,自然有它的view,可以选择获取启动图的view,然后添加到合适的父视图中(差不多就是UIWindow,其他的视图如果有导航栏效果会不好),最后执行其他操作,可实现添加动态文字与动画的效果,iOS8以下也类似,只要确保启动图消失后新出现的视图和原来一致即可 如何实现启动图有广告/节日图的效果呢? 原理也差不多,启动图上半部分淡色一些,可以是纯白,底部有公司名称,logo等信息,全白肯定不好看,等启动图消失后,请求广告,如果有,就把广告加到视图的上半部分,本地有一张占位图,没广告或祝福就显示那一张,广告可以做个预加载,效果会好一些,至于底部同样是公司名称,logo等信息 启动图动态文字与动画123456789101112131415161718192021// - 别忘了在LaunchScreen.storyboard文件中要添加标记UIViewController *viewController = [[UIStoryboard storyboardWithName:@\"LaunchScreen\" bundle:nil] instantiateViewControllerWithIdentifier:@\"LaunchScreen\"];// - 获取viewUIView *launchView = viewController.view;[self compatibleWithLaunchView:launchView]; UIWindow *mainWindow = [UIApplication sharedApplication].keyWindow;launchView.frame = [UIApplication sharedApplication].keyWindow.frame;[launchView addSubview:self.dynamicLabel];[mainWindow addSubview:launchView];// - 动画[UIView animateWithDuration:1.0f delay:0.5f options:UIViewAnimationOptionCurveLinear animations:^{ launchView.alpha = 0.0f; launchView.layer.transform = CATransform3DScale(CATransform3DIdentity, 2.0f, 2.0f, 1.0f);} completion:^(BOOL finished) { [launchView removeFromSuperview];}]; 启动图添加广告/节日祝福123456789101112131415161718192021222324252627282930- (void)viewDidLoad { [super viewDidLoad]; [self.view addSubview:self.splashView]; // 忽略有广告时状态栏需要隐藏再出现 BOOL hasAd = arc4random() % 3 == 1 ? true : false; if (hasAd) { // - 可以把下一张广告图也请求下来,实现预加载,看上去效果会比较好 [self.adImgView sd_setImageWithURL:[NSURL URLWithString:@\"https://ooo.0o0.ooo/2017/01/20/58821a46b366e.png\"]]; [self.splashView addSubview:self.adImgView]; [self.splashView addSubview:self.splashImgView]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ [self.splashView removeFromSuperview]; }); }else { [self.splashView addSubview:self.avatorImgView]; [UIView animateWithDuration:1.5 animations:^{ self.avatorImgView.transform = CGAffineTransformMakeTranslation(0, -60); } completion:^(BOOL finished) { [self.splashView removeFromSuperview]; }]; } // - 显示控制器页面逻辑...} 效果图 更新 170419注意点测试过程中发现, LaunchScreen.storyboard 时,顶部约束要离 Top Layout Guide 20 个点,不然显示时能有变形感觉。 代码demo 参考 iOS Human Interface Guidelines - Launch Screen iOS开发时如何使用 Launch Screen Storyboard 通过LaunchScreen自定义启动动画 LaunchScreenTest","link":"/2017/01/21/iOSer-An-Analysis-of-iOS-Animation/"},{"title":"浅析UIButton的imageEdgeInsets与titleEdgeInsets","text":"导语 系统的 UIButton 默认状态下的样式是图标在左标题在右，但有时候可能需要不同的排版。当然可以通过继承添加子视图来实现需求，但本文打算通过理解 UIButton 自带的 imageEdgeInsets 和 titleEdgeInsets 属性实现该功能。 主要内容包含以下两点: 浅析 imageEdgeInsets 和 titleEdgeInsets 的属性的原理 [个人观点] 简单实现图标在右标题在左,图标在上标题在下。 环境 macOS Sierra 10.12.4Xcode 8.3.2iPhone 6S (10.1.1) 流程 先从苹果官方对该方法的注释入手 The inset or outset margins for the rectangle around the button’s title text. 使用此属性可调整按钮标题的有效绘图矩形的大小并重新定位。(来自 google 翻译) Use this property to resize and reposition the effective drawing rectangle for the button title. You can specify a different value for each of the four insets (top, left, bottom, right). A positive value shrinks, or insets, that edge—moving it closer to the center of the button. A negative value expands, or outsets, that edge. Use the UIEdgeInsetsMake function to construct a value for this property. The default value is UIEdgeInsetsZero. 关于 UIEdgeInsetsMake 的 top, left, bottom, right ，正数表明更靠近按钮的中心，负数表示更靠近按钮的边缘，默认为 UIEdgeInsetsZero 。 问题 1 margins 是边距的含义，那原始的位置在哪? 测试代码 1234567891011121314151617181920212223242526272829303132333435363738#import &lt;UIKit/UIKit.h&gt;@interface JAButton : UIButton@end#import \"JAButton.h\"@implementation JAButton- (instancetype)initWithFrame:(CGRect)frame { if (self = [super initWithFrame:frame]) { self.layer.borderColor = [UIColor blueColor].CGColor; self.layer.borderWidth = 1; [self setTitleColor:[UIColor redColor] forState:UIControlStateNormal]; // [1] [self setTitle:@\"测试\" forState:UIControlStateNormal]; // [2] [self setImage:[UIImage imageNamed:@\"arrow\"] forState:UIControlStateNormal]; } return self;}- (void)layoutSubviews { [super layoutSubviews]; // [3] self.titleEdgeInsets = UIEdgeInsetsMake(0, 0, 0, 10); // [4] self.imageEdgeInsets = UIEdgeInsetsMake(0, 0, 0, 10);}@end...JAButton *b = [[JAButton alloc] initWithFrame:CGRectMake(10, 100, 100, 40)];[self.view addSubview:b]; 测试 1 只有标题 [注释 2 3 4] 标题的位置如下 标题居中 测试 2 只有图标 [注释 1 3 4] 图标位置信息如下 图标居中 测试 3 标题 + 图标 [注释 3 4] 图标 标题 为了维持居中就要将标题和图标看做一个整体即宽度和为 37 + 10 = 47 ，用 UIButton 的宽度来减去总宽度再乘以 0.5 即可实现整体居中，因此图标的 X 就是 (100 - 47) * 0.5 = 26.5 测试 4 只调整 titleEdgeInsets [注释 2 4] 标题的位置信息如下 测试 5 只调整 imageEdgeInsets [注释 1 3] 图标的位置信息如下 问题 2 比较测试 4 与测试 1 会发现 titleEdgeInsets 的 right 设置了 10 , X 却向左偏移了 5 ? 同样对比 测试 5 与测试 2 会发现 imageEdgeInsets 的 right 设置了 10 , X 却向左偏移了 5 为什么会有这种减半的现象呢? 寻找 &amp; 分析 在搜索后，这篇 博客对我有所启发 回答 1 它们只是image和button相较于原来位置的偏移量，那什么是原来的位置呢？就是这个 没有设置edgeInset时候的位置了。如要要image在右边，label在左边，那image的左边相对于button的左边右移了labelWidth的距离，image的右边相对于label的左边右移了labelWidth的距离所以，self.oneButton.imageEdgeInsets = UIEdgeInsetsMake(0, labelWidth, 0, -labelWidth); 为什么是负值呢？因为这是contentInset，是偏移量，不是距离同样的，label 的右边相对于 button 的右边左移了 imageWith 的距离，label 的左边相对于 image 的右边左移了 imageWith 的距离所以 self.oneButton.titleEdgeInsets = UIEdgeInsetsMake(0, -imageWith, 0, imageWith); 这样就完成image在右边，label在左边的效果了。 但是对下面的前置知识点，感觉有些疑惑 前置知识点：titleEdgeInsets是title相对于其上下左右的inset，跟tableView的contentInset是类似的，如果只有title，那它上下左右都是相对于button的，image也是一样；如果同时有image和label，那这时候image的上左下是相对于button，右边是相对于label的；title的上右下是相对于button，左边是相对于image的。 我认为虽然两者都在 UIButton 中，但 Apple 既然将 imageEdgeInsets 和 titleEdgeInsets 拆成两个属性，两者的位置应该不互相依赖才对，即使依赖，也应该依赖 UIButton 这个父视图比较合适。 测试 6 在标题和图标同时存在的情况下，调整 titleEdgeInsets [注释 4] 标题 图标 测试 7 在标题和图标同时存在的情况下，调整 imageEdgeInsets [注释 3] 标题 图标 测试 8 在标题和图标同时存在的情况下，调整 imageEdgeInsets 和 titleEdgeInsets [不注释] 标题 图标 小结 将测试 3 和 测试 6 或 测试 3 和测试 7 对比会发现即使在标题和图标同时存在的情况下，单独调整 imageEdgeInsets 或 titleEdgeInsets 都只会对对应的视图的位置产生影响，而且影响同样是 减半 的。而通过将测试 3 和 测试 8 比较， titleEdgeInsets 和 imageEdgeInsets 同时作用的情况下也是一样的。 佐证 上面的参考博客中提到 Aligning text and image on UIButton with imageEdgeInsets and titleEdgeInsets 是 StackOverflow 上关于这个问题的一个讨论。里面有这样一段话，对我有所启发 I believe that this documentation was written imagining that the button has no title, just an image. It makes a lot more sense thought of this way, and behaves how UIEdgeInsets usually do. Basically, the frame of the image (or the title, with titleEdgeInsets) is moved inwards for positive insets and outwards for negative insets。 官方的注释也许正如上面这段话所表达的，只是在告诉我们 imageEdgeInsets/titleEdgeInsets 其实只是描述了父视图(UIButton)与它们各自视图的间距。 回答 2 在理解了 imageEdgeInsets/titleEdgeInsets 的独立性后，我尝试用自己的话来说明为什么会存在”减半”的效果。 比如下面的代码 1self.titleEdgeInsets = UIEdgeInsetsMake(0, 0, 0, 10); 在水平方向上 titleLabel 左侧偏移量为 0，titleLabel 右侧偏移量为 10 ，但是偏移量 ≠ X 的变化量。 X 左移 10 那么实际上的偏移属性值应该为 (0,-10,0,10) : 左偏移量(相对于 button 左侧)，title 从原始向目标是往边缘方向，所以是负值(参考本文最初的文档理解)，偏移量为 10*，右偏移量(相对 *button 右侧)，从原始到目标是往中间方向，所以是正值。 因此上面的代码表明 titleLabel 相对 UIButton 左侧不改变，右侧改变 10 ，应该是做不到的，左侧间距增加1，右侧间距必然会减少1。会被等价转换为 1self.titleEdgeInsets = UIEdgeInsetsMake(0, -5, 0, 5); 个人推测 如何转换? 参考 iOS 的坐标系，水平向右为 X 轴正方向 ，垂直向下为 Y 正方向,要根据 titleEdgeInsets / imageEdgeInsets 去计算 title 和 image 的坐标，可以对 UIEdgeInsets 结构体的四个成员( top , left , bottom , right ) 进行处理 (在负方向留正偏移量即是往正方向偏移)。 公式如下 水平方向上 X 的偏移量: (left + (-1) * right) / 2 垂直方向上 Y 的偏移量: (top + (-1) * bottom) / 2 直白点的话: 负间距(left,top)更靠近，正间距(left,top)更远离，原始状态就是 UIEdgeInsets 全为 0 即你不去操作 titleEdgeInsets / imageEdgeInsets 时。 个人推测 实践 实践是检验真理的唯一标准；不管黑猫白猫，能抓老鼠的就是好🐱… 图标在右标题在左 根据上面的猜想，要实现图标与标题的位置交换，很简单: imageView 左侧相对于 UIButton 向中央移动了 titleLabel 的宽度，记为 titleLabel.w*，右侧相对于 *UIButton 向边缘同样移动了 titleLabel.w 因此 123456789101112- (void)layoutSubviews { [super layoutSubviews]; // [3]// self.titleEdgeInsets = UIEdgeInsetsMake(0, 0, 0, 10);// // // [4]// self.imageEdgeInsets = UIEdgeInsetsMake(0, 0, 0, 10); self.imageEdgeInsets = UIEdgeInsetsMake(0, self.titleLabel.frame.size.width, 0, -self.titleLabel.frame.size.width); self.titleEdgeInsets = UIEdgeInsetsMake(0, -self.imageView.frame.size.width, 0, self.imageView.frame.size.width);} 标题 图标 但是如果用直接去设置 UIButton 的 123456789UIButton *b = [[UIButton alloc] initWithFrame:CGRectMake(10, 100, 100, 40)];b.layer.borderColor = [UIColor blueColor].CGColor;b.layer.borderWidth = 1;[b setTitleColor:[UIColor redColor] forState:UIControlStateNormal];[b setTitle:@\"测试\" forState:UIControlStateNormal];[b setImage:[UIImage imageNamed:@\"arrow\"] forState:UIControlStateNormal]; [self.view addSubview:b]; b.imageEdgeInsets = UIEdgeInsetsMake(0, b.titleLabel.frame.size.width, 0, -b.titleLabel.frame.size.width); b.titleEdgeInsets = UIEdgeInsetsMake(0, -b.imageView.frame.size.width, 0, b.imageView.frame.size.width); 你会发现效果并不如意，原因是因为 titleLabel 的尺寸不正确 我想到的解决方法有三种 继承 UIButton ，在子类的 layoutSubviews 中进行处理 参考上面博客的作者在 Demo_ButtonImageTitleEdgeInsets 提供的，sizeWithFont:来实现，通过字符串计算出 titlelabel 的尺寸，来设置 titleEdgeInsets ，详情见代码段 1 第三种通过 sizeToFit 和第二种思路是一样的，详情见代码段 2 代码段 1 123456789@interface NSString(UIStringDrawing)// Single line, no wrapping. Truncation based on the NSLineBreakMode.- (CGSize)sizeWithFont:(UIFont *)font NS_DEPRECATED_IOS(2_0, 7_0, \"Use -sizeWithAttributes:\") __TVOS_PROHIBITED;...CGFloat labelWidth = [self.titleLabel.textsizeWithFont:self.titleLabel.font].width; 代码段 2 12345678910111213UIButton *b = [[UIButton alloc] initWithFrame:CGRectMake(10, 100, 100, 40)];b.layer.borderColor = [UIColor blueColor].CGColor;b.layer.borderWidth = 1;[b setTitleColor:[UIColor redColor] forState:UIControlStateNormal];[b setTitle:@\"测试\" forState:UIControlStateNormal];[b setImage:[UIImage imageNamed:@\"arrow\"] forState:UIControlStateNormal];[self.view addSubview:b];// 看这里 --- [b.titleLabel sizeToFit];b.imageEdgeInsets = UIEdgeInsetsMake(0, b.titleLabel.frame.size.width, 0, -b.titleLabel.frame.size.width);b.titleEdgeInsets = UIEdgeInsetsMake(0, -b.imageView.frame.size.width, 0, b.imageView.frame.size.width); 虽然位置不对，但尺寸已经是正确的了，也能实现合适的效果。 图标在下标题在上 根据上面的原理，应该可以比较简单的推算出的 imageEdgeInsets 和 titleEdgeInsets 要求: imageView 和 titleLabel 都居中，且 imageVeiw 在上 两者都存在的情况下，原始的左右间距是( UIButton 的宽度 - 两者的宽度之和) * 0.5， imageView 的 X 要向右移动 ((UIButton 的宽度 - imageView 的宽度) - (UIButton 的宽度 - 两者的宽度之和)) * 0.5 titleLable 的宽度 * 0.5 阶段 1 12self.imageEdgeInsets = UIEdgeInsetsMake(0, self.titleLabel.frame.size.width * 0.5, 0, -self.titleLabel.frame.size.width * 0.5);self.titleEdgeInsets = UIEdgeInsetsMake(0, -self.imageView.frame.size.width * 0.5, 0, self.imageView.frame.size.width * 0.5); 两者都居中了，然后调整垂直方向 阶段 2 12self.imageEdgeInsets = UIEdgeInsetsMake(-5, self.titleLabel.frame.size.width * 0.5, 5, -self.titleLabel.frame.size.width * 0.5);self.titleEdgeInsets = UIEdgeInsetsMake(5, -self.imageView.frame.size.width * 0.5, -5, self.imageView.frame.size.width * 0.5); 效果有点丑… 说明: 这里忽略了 UIButton 放不下 titleLabel 或者用 xib 创建有 intrinsicSize 引用的问题。 假想的实现 123456789CGFloat imageX = (CGRectGetWidth(self.imageView.frame)+ CGRectGetWidth(self.titleLabel.frame)) * 0.5 + (self.imageEdgeInsets.left - self.imageEdgeInsets.right) / 2;CGFloat imageY = (CGRectGetHeight(self.frame) - self.imageView.image.size.height) * 0.5 + (self.imageEdgeInsets.top - self.imageEdgeInsets.bottom) / 2;CGFloat imageW = self.imageView.image.size.width;CGFloat imageH = self.imageView.image.size.height; CGFloat titleX = (CGRectGetWidth(self.titleLabel.frame) + CGRectGetWidth(self.titleLabel.frame) * 0.5) + (self.titleEdgeInsets.left - self.titleEdgeInsets.right) / 2;CGFloat titleY = (CGRectGetWidth(self.frame) - CGRectGetHeight(self.titleLabel.frame)) * 0.5 + (self.titleEdgeInsets.top - self.titleEdgeInsets.bottom) / 2;CGFloat titleW = CGRectGetWidth(self.titleLabel.frame);CGFloat titleH = CGRectGetHeight(self.titleLabel.frame); 总结 本文通过控制变量法😷 测试了 UIButton 的 imageEdgeInsets 和 titleEdgeInsets 属性的作用效果，发现两者是相互独立且只参考父视图 ( UIButton ) ，同时对实现图标在右标题在上，图标在上标题在下这两种样式提供了一点思路。 参考 UIButton的titleEdgeInsets属性和imageEdgeInsets属性实现图片文字按要求排列 Aligning text and image on UIButton with imageEdgeInsets and titleEdgeInsets","link":"/2017/05/20/iOSer-Analysis-of-UIButton-s-imageEdgeInsets-with-titleEdgeInsets/"},{"title":"越狱 iPhone 设备导出 ipa && 重签名","text":"前言 以前想获取应用的 .ipa 文件可以从 iTunes 下载，macOS 上的 iTunes 升级成 12.7 后,无法再获得 .ipa 文件, 而iOS 9 后就不能从 iTools 之类的辅助工具中导出 .ipa 文件。 后面 Apple 官网又提供了一个 12.6.3 的链接 出于好奇心,想试试直接导出.ipa文件,并重签名安装到未越狱的设备上。 环境 macOS Sierra 10.12.6iPhone 6 Plus (11.0)Xcode Version 9.0 (9A235)iPhone 5s(9.3.3 已越狱) 越狱设备中导出 .ipaSSH 到越狱设备,使用Cycript 找到xxx.app 的位置 123iPhone:~ root# ps -ef | grep WeChat 501 714 1 0 0:00.00 ?? 0:29.04 /var/containers/Bundle/Application/41A6836F-CFC9-4DC1-8A9C-ED4DE09F9A66/WeChat.app/WeChat 0 807 805 0 0:00.00 ttys001 0:00.01 grep WeChat 找到后使用 tar 将 xxx.app 打包 123456789101112iPhone:~ root# cd /var/containers/Bundle/Application/41A6836F-CFC9-4DC1-8A9C-ED4DE09F9A66/iPhone:/var/containers/Bundle/Application/41A6836F-CFC9-4DC1-8A9C-ED4DE09F9A66 root# lsWeChat.app iTunesArtwork iTunesMetadata.plistiPhone:/var/containers/Bundle/Application/41A6836F-CFC9-4DC1-8A9C-ED4DE09F9A66 root# tar -cvf /tmp/WeChat.tar ./././.com.apple.mobile_container_manager.metadata.plist./WeChat.app/./WeChat.app/AppIcon60x60@2x.png..../WeChat.app/zh_TW.lproj/network_setting.html./iTunesArtwork./iTunesMetadata.plist 使用 scp 发送打包文件到 mac 上 123➜ ~ scp root@192.168.199.132:/tmp/WeChat.tar ~/Desktop/WeChat.tarroot@192.168.199.132's password:WeChat.tar 100% 97MB 1.7MB/s 00:58 重签名要求可执行文件要先脱壳 1234567891011121314151617181920212223242526272829303132// 获得沙盒地址iPhone:~ root# cycript -p WeChatcy# [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0]#\"file://s\"cy# exit(0)// 获得应用地址iPhone:~ root# ps -ef | grep WeChat 501 714 1 0 0:00.00 ?? 0:03.25 /var/containers/Bundle/Application/41A6836F-CFC9-4DC1-8A9C-ED4DE09F9A66/WeChat.app/WeChat 0 717 699 0 0:00.00 ttys000 0:00.01 grep WeChat// DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib path/to/AppiPhone:/var/mobile/Containers/Data/Application/E7DE74DA-2FC9-4A86-A4D7-F993A88AB225/Documents root# su mobileiPhone:~/Containers/Data/Application/E7DE74DA-2FC9-4A86-A4D7-F993A88AB225/Documents mobile$ DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/containers/Bundle/Application/41A6836F-CFC9-4DC1-8A9C-ED4DE09F9A66/WeChat.app/WeChatmach-o decryption dumperDISCLAIMER: This tool is only meant for security research purposes, not for application crackers.[+] detected 64bit ARM binary in memory.[+] offset to cryptid found: @0x100028ca8(from 0x100028000) = ca8[+] Found encrypted data at address 00004000 of length 56131584 bytes - type 1.[+] Opening /private/var/containers/Bundle/Application/41A6836F-CFC9-4DC1-8A9C-ED4DE09F9A66/WeChat.app/WeChat for reading.[+] Reading header[+] Detecting header type[+] Executable is a plain MACH-O image[+] Opening WeChat.decrypted for writing.[+] Copying the not encrypted start of the file[+] Dumping the decrypted data into the file[+] Copying the not encrypted remainder of the file[+] Setting the LC_ENCRYPTION_INFO-&gt;cryptid to 0 at offset ca8[+] Closing original file[+] Closing dump file 原版的 dumpdecrypted 无法应对有 Frameworks 的情况,不过有一个分支版本dumpdecrypted 提供了解决的方法,但是还有Plugins,幸而还有一个分支提供了使用dumpdecryptd 对 .extension 文件进行脱壳(today那种小插件,用这个版本脱壳尝试不成功,找了XX助手去下载脱壳的部分),详情可参考App Extension的脱壳办法。都能支持的版本也已经有了dumpdecrypted 分支对 dumpdecrypted 有些部分的代码不理解 原版的 dumptofile 的函数参数是怎么来的? Frameworks分支版本做了什么? extension 分支版本做了什么? 在这个dumpdecrypted的Frameworks 分支版本中 12345__attribute__((constructor))static void dumpexecutable() { ... _dyld_register_func_for_add_image(&amp;image_added);} __attribute__((constructor))根据 attribute((constructor))用法解析,得到的GNU的文档 可知 dumpexecutable() 方法在 main 函数之前执行 _dyld_register_func_for_add_image找了 github 上的 dyld 123456789101112131415161718/* * _dyld_register_func_for_add_image registers the specified function to be * called when a new image is added (a bundle or a dynamic shared library) to * the program. When this function is first registered it is called for once * for each image that is currently part of the program. */void_dyld_register_func_for_add_image(void (*func)(const struct mach_header *mh, intptr_t vmaddr_slide)){ DYLD_LOCK_THIS_BLOCK; typedef void (*callback_t)(const struct mach_header *mh, intptr_t vmaddr_slide); static void (*p)(callback_t func) = NULL; if(p == NULL) _dyld_func_lookup(\"__dyld_register_func_for_add_image\", (void**)&amp;p); p(func);} dyld 会负责传递 mh 和 intptr_t 参数 1234// usr/include/sys/_types/_intptr_t.htypedef __darwin_intptr_t intptr_t;// usr/include/arm/_types.htypedef long __darwin_intptr_t; 因此 intptr_t 就是 long 类型 12345static void image_added(const struct mach_header *mh, intptr_t slide) { Dl_info image_info; int result = dladdr(mh, &amp;image_info); dumptofile(image_info.dli_fname, mh);} 调用 dumptofile 函数, 在 _dyld_register_func_for_add_image 函数的注释中提到了 called when a new image is added (a bundle or a dynamic shared library) 因此可以将 framework 也一起导出。 查找 dyld 后发现在 ImageLoader.h 头文件中,有 1typedef void (*Initializer)(int argc, const char* argv[], const char* envp[], const char* apple[], const ProgramVars* vars); 在 ImageLoaderMachO.cpp 中有如下的函数实现 1234567891011121314151617181920212223void ImageLoaderMachO::doImageInit(const LinkContext&amp; context){ if ( fHasDashInit ) { const uint32_t cmd_count = ((macho_header*)fMachOData)-&gt;ncmds; const struct load_command* const cmds = (struct load_command*)&amp;fMachOData[sizeof(macho_header)]; const struct load_command* cmd = cmds; for (uint32_t i = 0; i &lt; cmd_count; ++i) { switch (cmd-&gt;cmd) { case LC_ROUTINES_COMMAND: Initializer func = (Initializer)(((struct macho_routines_command*)cmd)-&gt;init_address + fSlide); // &lt;rdar://problem/8543820&amp;9228031&gt; verify initializers are in image if ( ! this-&gt;containsAddress((void*)func) ) { dyld::throwf(\"initializer function %p not in mapped image for %s\\n\", func, this-&gt;getPath()); } if ( context.verboseInit ) dyld::log(\"dyld: calling -init function %p in %s\\n\", func, this-&gt;getPath()); func(context.argc, context.argv, context.envp, context.apple, &amp;context.programVars); break; } cmd = (const struct load_command*)(((char*)cmd)+cmd-&gt;cmdsize); } }} 根据函数命名知道这应该是给镜像做初始化的,里面 func 函数是 Initializer 类型的,通过 context 参数获取上下文信息,原版的 dumptofile 函数的参数列表为什么会是 (int argc, const char **argv, const char **envp, const char **apple, struct ProgramVars *pvars) 到这里就可知一二。 .extension 脱壳的 dumpdecrypted 版本与原版的区别主要是 123456...strlcpy(npath, cachePath.UTF8String, sizeof(npath));strlcat(npath, tmp, sizeof(npath));strlcat(npath, \".decrypted\", sizeof(npath));strlcpy(buffer, npath, sizeof(buffer));... 指明将脱壳的包导出到应用沙盒的 .../Library/Caches 目录下 /Library/MobileSubstrate/DynamicLibraries/ 下的动态库会被MobileSubstrate.dylib 自动加载。 在原版的 dumpdecrypted 添加一些输出,使用 printf 时,据说在后面添加一个 \\n 可以在日志中看到,但是试了似乎没效果,因此使用 NSLog 进行输出,添加 1#import &lt;Foundation/Foundation.h&gt; 同时修改 Makefile 文件, 指明要链接 Foundation 框架 1-framework Foundation make &amp;&amp; ldid 签名,发送到 /Library/MobileSubstrate/DynamicLibraries/ 配置好对应的 .plist 文件,启动,然后闪退,查看日志 123456789Nov 20 09:13:29 Jasons-iPhone QQReaderUI[1237] &lt;Notice&gt;: MS:Notice: Injecting: com.tencent.qqreaderiphone [QQReaderUI] (1290.11)Nov 20 09:13:29 Jasons-iPhone QQReaderUI[1237] &lt;Notice&gt;: MS:Notice: Loading: /Library/MobileSubstrate/DynamicLibraries/dumpdecrypted.dylibNov 20 09:13:29 Jasons-iPhone QQReaderUI[1237] &lt;Warning&gt;: [TEST]:rpath = /private/var/containers/Bundle/Application/E276C2C9-20FE-4450-915A-86EBE07798AC/QQReaderUI.app/QQReaderUINov 20 09:13:29 Jasons-iPhone QQReaderUI[1237] &lt;Warning&gt;: [TEST]:fd = 4Nov 20 09:13:29 Jasons-iPhone QQReaderUI[1237] &lt;Warning&gt;: [TEST]:npath = QQReaderUINov 20 09:13:29 Jasons-iPhone QQReaderUI[1237] &lt;Warning&gt;: [TEST]:npath = QQReaderUI.decryptedNov 20 09:13:29 Jasons-iPhone QQReaderUI[1237] &lt;Warning&gt;: [TEST]:outfd = -1Nov 20 09:13:29 Jasons-iPhone QQReaderUI[1237] &lt;Warning&gt;: [TEST]:outfd = -1Nov 20 09:13:29 Jasons-iPhone com.apple.xpc.launchd[1] (UIKitApplication:com.tencent.qqreaderiphone[0xc2a3][1237]) &lt;Warning&gt;: Service exited with abnormal code: 1 第一个 outfd = -1 12outfd = open(npath, O_RDWR|O_CREAT|O_TRUNC, 0644);NSLog(@\"[TEST]:outfd = %d\\n\",outfd); 尝试在当前目录下(/Library/MobileSubstrate/DynamicLibraries/),打开(创建)一个 QQReaderUI.decrypted,因为权限的问题失败了。 第二个 outfd = -1 后面 dumpdecrypted.dylib 还会判断是不是在/private/var/mobile/Applications(通过AppStore和iTunes安装的程序都在里面。),但显然不是,因此也失败了 调用 _exit(1) 闪退 找到一个比较具体的解释,排版不太好… 回到正题将脱壳后的可执行文件同样的发送到 mac 上 123456➜ ~ scp root@192.168.199.132:/var/mobile/Containers/Data/Application/E7DE74DA-2FC9-4A86-A4D7-F993A88AB225/Documents/WeChat.decrypted ~/Desktoproot@192.168.199.132's password:WeChat.decrypted 100% 68MB 444.4KB/s 02:36➜ ~ cd Desktop➜ Desktop file WeChat.decryptedWeChat.decrypted: Mach-O 64-bit executable arm64 如何判断是否已脱壳判断二进制是否被加密可以使用 otool 工具 otool - object file displaying tool otool可以输出app的load commands，然后通过查看cryptid这个标志位来判断app是否被加密。1代表加密了，0代表被解密了 1234567891011121314151617// 直接从手机中导出的 WeChat ➜ Wechat otool -l WeChat.app/WeChat | grep -B 2 crypt(standard input)-489- cmd LC_ENCRYPTION_INFO(standard input)-490- cmdsize 20(standard input):491: cryptoff 16384(standard input):492: cryptsize 46907392(standard input):493: cryptid 1// 脱壳后的 WeChat➜ Wechat otool -l WeChat.decrypted | grep -B 2 crypt(standard input):1:WeChat.decrypted:--(standard input)-489- cmd LC_ENCRYPTION_INFO(standard input)-490- cmdsize 20(standard input):491: cryptoff 16384(standard input):492: cryptsize 46907392(standard input):493: cryptid 0 可以看出手机导出的只有当前架构的,而脱壳也只针对当前运行的架构,直接从 iTunes 下载的 .ipa 文件中的二进制文件大小大约是从手机导出的两倍,因为它包含了其他的架构。 了解重签名学习一般都是从模仿开始的,看看 Xcode 是怎么签名的,创建新工程,⌘ + B 编译一下,然后查看日志 1234567891011121314151617/// 签名CodeSign /Users/Jason/Library/Developer/Xcode/DerivedData/JustForTest-ggxnkdgkdklojofwwsifymqzfwqo/Build/Products/Debug-iphoneos/JustForTest.app/// cd 到工程目录 cd path/to/project/// 扩展环境变量 export CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate export PATH=\"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\"/// 签名的身份 + 描述文件说明 Signing Identity: \"iPhone Developer: 开发者名 (开发者ID)\"Provisioning Profile: \"iOS Team Provisioning Profile: com.coder.bk123\" (c8748c6c-9d07-41ce-8d55-ff5ca9999999)// 使用 codesign 执行签名操作 /usr/bin/codesign --force --sign 签名值 --entitlements /Users/Jason/Library/Developer/Xcode/DerivedData/JustForTest-ggxnkdgkdklojofwwsifymqzfwqo/Build/Intermediates.noindex/JustForTest.build/Debug-iphoneos/JustForTest.build/JustForTest.app.xcent --timestamp=none /Users/Jason/Library/Developer/Xcode/DerivedData/JustForTest-ggxnkdgkdklojofwwsifymqzfwqo/Build/Products/Debug-iphoneos/JustForTest.app --force强制代替已存在的签名 --timestamp时间戳 --sign123-s, --sign identity Sign the code at the path(s) given using this identity. See SIGNING IDENTI- TIES below. 详情可使用 man codesign 查看 打开钥匙串应用,找到开发者证书,因为我是Debug状态下运行的,所以看开发证书,sign 的值就是指纹中的 SHA1 签名,20个16进制 正好是40位 --entitlements参数值对应的 xxx.app.xcent 文件内容如下 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;application-identifier&lt;/key&gt; &lt;string&gt;XXXXX.包名&lt;/string&gt; &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt; &lt;string&gt;XXXXX&lt;/string&gt; &lt;key&gt;get-task-allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;keychain-access-groups&lt;/key&gt; &lt;array&gt; &lt;string&gt;XXXXX.包名&lt;/string&gt; &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt; 其中 XXXXX 是发布证书中开发者的身份ID 即 com.apple.developer.team-identifier 中的字段值 在 WWDC16 Session 401 What’s New in Xcode App Signing 有如下的内容 There are three things that you need in order to sign your apps. The first thing is a signing certificate. Signing certificates establish your identity as a developer.Provisioning profiles are all about your apps, and they grant permissions. And entitlements declare support for capabilities.Like iCloud or Wallet. So certificates. These are issued by Apple.And this is important because the device needs a trust chain back to Apple so it can install the app. And certificates come in two forms. signing certificate: 开发者身份是否可信Provisioning profiles: 哪些设备可安装entitlements: 有哪些能力,比如推送,应用间分享…. 在新创建的工程 Product 目录下 Show in Finder 来查看 xxx.app 文件,可以发现里面包含一个 embedded.mobileprovision 文件,可以通过 1➜ security cms -D -i embedded.mobileprovision 结果如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;AppIDName&lt;/key&gt; &lt;string&gt;Resign01&lt;/string&gt; &lt;key&gt;ApplicationIdentifierPrefix&lt;/key&gt; &lt;array&gt; &lt;string&gt;发布时的开发者ID&lt;/string&gt; &lt;/array&gt; &lt;key&gt;CreationDate&lt;/key&gt; &lt;date&gt;2017-11-15T03:42:41Z&lt;/date&gt; &lt;key&gt;Platform&lt;/key&gt; &lt;array&gt; &lt;string&gt;iOS&lt;/string&gt; &lt;/array&gt; &lt;key&gt;DeveloperCertificates&lt;/key&gt; &lt;array&gt; &lt;data&gt;签名证书&lt;/data&gt; &lt;data&gt;...&lt;/data&gt; &lt;/array&gt; &lt;key&gt;Entitlements&lt;/key&gt; &lt;dict&gt; &lt;key&gt;keychain-access-groups&lt;/key&gt; &lt;array&gt; &lt;string&gt;发布时的开发者ID.*&lt;/string&gt; &lt;/array&gt; &lt;key&gt;get-task-allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;application-identifier&lt;/key&gt; &lt;string&gt;发布时的开发者ID.com.coder.Resign01&lt;/string&gt; &lt;key&gt;com.apple.developer.healthkit&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.security.application-groups&lt;/key&gt; &lt;array&gt; &lt;string&gt;group.com.coder.Resign01&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt; &lt;string&gt;发布时的开发者ID&lt;/string&gt; &lt;key&gt;aps-environment&lt;/key&gt; &lt;string&gt;development&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;ExpirationDate&lt;/key&gt; &lt;date&gt;2018-11-15T03:42:41Z&lt;/date&gt; &lt;key&gt;Name&lt;/key&gt; &lt;string&gt;iOS Team Provisioning Profile: com.coder.Resign01&lt;/string&gt; &lt;key&gt;ProvisionedDevices&lt;/key&gt; &lt;array&gt; &lt;string&gt;允许安装的设备的UDID&lt;/string&gt; &lt;string&gt;....&lt;/string&gt; &lt;/array&gt; &lt;key&gt;TeamIdentifier&lt;/key&gt; &lt;array&gt; &lt;string&gt;发布时的开发者ID&lt;/string&gt; &lt;/array&gt; &lt;key&gt;TeamName&lt;/key&gt; &lt;string&gt;开发者名&lt;/string&gt; &lt;key&gt;TimeToLive&lt;/key&gt; &lt;integer&gt;365&lt;/integer&gt; &lt;key&gt;UUID&lt;/key&gt; &lt;-- 描述文件 --&gt; &lt;string&gt;c8748c6c-9d07-41ce-8d55-ff5ca999999&lt;/string&gt; &lt;key&gt;Version&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt;&lt;/dict&gt;&lt;/plist&gt; 通过 Xcode 日志的描述文件序列号在 ~/Library/MobileDevice/Provisioning Profiles/ 目录查找,然后用对比工具进行比较,发现两者是相同的, 从中可以看出,开发的情况下,签名的过程会将我们从 Apple 开发者后台下载的描述文件embedded.mobileprovision 放到包中,用于安装时的验证。 我们在 Apple 开发者后台生成证书时要求上传一个 .csr 文件,Certificate_signing_request Before creating a CSR, the applicant first generates a key pair, keeping the private key secret. The CSR contains information identifying the applicant (such as a distinguished name in the case of an X.509 certificate) which must be signed using the applicant’s private key. The CSR also contains the public key chosen by the applicant. The CSR may be accompanied by other credentials or proofs of identity required by the certificate authority, and the certificate authority may contact the applicant for further information. 创建 .csr 文件前,会用非对称加密算法生成一对密钥,分别是公钥和私钥,私钥存放在本地,而公钥与一些表明能自身身份的信息一起用于生成 .csr 文件。 Apple 开发者后台相当于一个 CA Trusted certificates can be used to create secure connections to a server via the Internet. A certificate is essential in order to circumvent a malicious party which happens to be on the route to a target server which acts as if it were the target. Such a scenario is commonly referred to as a man-in-the-middle attack. The client uses the CA certificate to authenticate the CA signature on the server certificate, as part of the authorizations before launching a secure connection. Usually, client software—for example, browsers—include a set of trusted CA certificates. This makes sense, as many users need to trust their client software. A malicious or compromised client can skip any security check and still fool its users into believing otherwise. 关于签名的原理,请看下图 来自-iOS App 签名的原理 测试环境下(Ad Hoc)如何保证应用能正常运行? 来自 developer.apple.com 证书和 device ID 一般应该都不会有问题,都是从 Apple 开发者后台获取的,所以主要去考虑的是 bundle ID 和 entitlements 后面实践发现对 entitlements.plist 文件添加权限,删除权限,会影响到对应的embedded.mobileprovision,但是依然可以成功安装并运行。 看了文字的说明 The app successfully launches if the app’s bundle ID matches the App ID, the signature matches the distribution certificate, and the device is in the device list of the ad hoc provisioning profile. 只提到了 3 点,包名匹配,证书匹配(--sign 对应的证书签名embedded.mobileprovision 文件中包含的证书),描述文件的设备列表包含当前设备 哪些文件需要参与签名 Nested code , 比如 .a 静态库, .frameworks (先签名)Mach-O executables , 二进制可执行文件Resources , 资源文件，就是 CodeResources 的部分To apply the signature, the codesign utility adds the signature directly to the executable file. .ipa 包里有一个 _CodeSignature 的文件夹，其中有个 CodeResources 文件 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;files&lt;/key&gt; &lt;dict&gt; ... &lt;/dict&gt; &lt;key&gt;files2&lt;/key&gt; &lt;dict&gt; ... &lt;/dict&gt; &lt;key&gt;rules&lt;/key&gt; &lt;dict&gt; ... &lt;/dict&gt; &lt;key&gt;rules2&lt;/key&gt; &lt;dict&gt; ... &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt; rules 和 files 是为老版本准备的，而 files2 和 rules2是为新的第二版的代码签名准备的。最主要的区别是在新版本中你无法再将某些资源文件排除在代码签名之外。+二进制的签名会被放到可执行文件中 参考的那篇文章的链接挂了… https://xiuchundao.me/post/code-resources-and-embedded-mobileprovision-included-in-ipa-file Mach-O executables. … To apply the signature, the codesign utility adds the signature directly to the executable file. 可以知道二进制文件的签名确实是直接在文件中的 总结 签名工具: codesign,需要提供 证书的SHA1签名值 和 entitlements.plist embedded.mobileprovision 就是从 Apple 开发者后台下载的描述文件, 同时在编译时会被拷贝到包中 重签名的应用要成功运行要保证包名匹配,证书匹配(--sign 对应的证书签名embedded.mobileprovision 文件中包含的证书),描述文件的设备列表包含当前设备 参与签名的有内嵌的框架,资源文件,二进制可执行文件 参考 Wiki-SHA1 App Distribution Guide - Adding Capabilities iOSAppHook Code Signing Tasks Maintaining Identifiers, Devices, and Profiles AppDistributionGuide-Introduction attribute((constructor))用法解析 How do you compile and run an objective-c file outside Xcode?","link":"/2017/11/28/iOSer-Escape-iPhone-device-export-ipa-resign/"},{"title":"Wiki - 通过配置获取iPhone的UDID","text":"仅记录123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt; &lt;dict&gt; &lt;key&gt;PayloadContent&lt;/key&gt; &lt;dict&gt; &lt;key&gt;URL&lt;/key&gt; &lt;string&gt;http://dev.skyfox.org/udid/receive.php&lt;/string&gt; &lt;!--接收数据的接口地址--&gt; &lt;key&gt;DeviceAttributes&lt;/key&gt; &lt;array&gt; &lt;string&gt;UDID&lt;/string&gt; &lt;string&gt;IMEI&lt;/string&gt; &lt;string&gt;ICCID&lt;/string&gt; &lt;string&gt;VERSION&lt;/string&gt; &lt;string&gt;PRODUCT&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;key&gt;PayloadOrganization&lt;/key&gt; &lt;string&gt;dev.skyfox.org&lt;/string&gt; &lt;!--组织名称--&gt; &lt;key&gt;PayloadDisplayName&lt;/key&gt; &lt;string&gt;查询设备UDID&lt;/string&gt; &lt;!--安装时显示的标题--&gt; &lt;key&gt;PayloadVersion&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;key&gt;PayloadUUID&lt;/key&gt; &lt;string&gt;3C4DC7D2-E475-3378-489C-0BB8D737A653&lt;/string&gt; &lt;!--自己随机填写的唯一字符串--&gt; &lt;key&gt;PayloadIdentifier&lt;/key&gt; &lt;string&gt;dev.skyfox.profile-service&lt;/string&gt; &lt;key&gt;PayloadDescription&lt;/key&gt; &lt;string&gt;本文件仅用来获取设备ID&lt;/string&gt; &lt;!--描述--&gt; &lt;key&gt;PayloadType&lt;/key&gt; &lt;string&gt;Profile Service&lt;/string&gt; &lt;/dict&gt;&lt;/plist&gt;","link":"/2022/12/11/iOSer-Get-iPhone-udid/"},{"title":"免密码远程登陆iOS设备","text":"前提条件 越狱设备 设备已安装OpenSSH 流程 生成RSA证书 推送公钥到iOS设备 配置~/.ssh/config文件 远程SSH登陆 生成RSA证书ssh-keygen1234567891011121314151617181920212223$ ssh-keygen// 默认为id_rsa 可另取名比如 iPadMini 密码Apple$%^321Generating public/private rsa key pair.Enter file in which to save the key (/Users/Jason/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in iPadMini.Your public key has been saved in iPadMini.pub.The key fingerprint is:SHA256:6lL+mpTksDTg4CsPiqD1WIemisd1BeoLtbXmgKuhjto Jason@BJ-iAirThe key's randomart image is:+---[RSA 2048]----+| || . ||. . . . ||.o .o . . || ..++o.oS || +.=B=o ||=o.+=O* ||X*+*o+o. ||&amp;=E ..+o. |+----[SHA256]-----+ 将RSA证书移动到~/.ssh/目录下12$ mv iPadMini ~/.ssh/$ mv iPadMini.pub ~/.ssh/ 推送公钥到iOS设备~/.ssh/ 目录是否存在12345$ ssh root@your_device_ip// 没有.ssh目录时$ cd ~$ mkdir .ssh 推送公钥1234$ scp ~/.ssh/iPadMini.pub root@your_device_ip:/var/root/.ssh/root@192.168.5.105's password:iPadMini.pub 100% 395 0.4KB/s 00:00 修改公钥文件名1234$ cd ~/.ssh/// 当不存在authorized_keys该文件时 可以$ mv iPadMini.pub authorized_keys// 当存在时,可用cat将公钥加到authorized_keys文件尾 配置~/.ssh/config文件12345// 进行远程登陆操作的计算机(比如 Mac OS)$ cd ~/.ssh/// 查看config文件是否存在,不存在则创建$ mkdir config config内容格式:12345Host aMini HostName your_device_ip ## 设备ip User root ## 用户名 PreferredAuthentications publickey IdentityFile ~/.ssh/iPadMini ## 指定RSA私钥文件 远程登陆123$ ssh aMiniEnter passphrase for key '/Users/Jason/.ssh/iPadMini':niya:~ root# 已经能免密码SSH登陆了","link":"/2016/11/20/iOSer-Free-password-to-remotely-access-iOS-devices/"},{"title":"喜马拉雅音频文件导出","text":"前言 平时喜欢用喜马拉雅听广播一般都离线下载后听,但是手机的空间不足,有些音频又不想删,因此想把音频文件导出,然后就可以任性删啦。 环境 iPad Mini 2(8.4,已越狱)macOS Sierra 10.12.3喜马拉雅v5.4.57 流程 ssh登录到iPad上 cycripyt寻找喜马拉雅的进程并注入 寻找沙盒路径 寻找音频文件 导出音频文件 后续处理 准备先用喜马拉雅下载一些感兴趣的音频 ssh登录1ssh root@your_device_ip cycripyt找进程为避免干扰,先关闭其他进程,打开喜马拉雅应用,用ps指令获取当前运行进程列表 根据路径加名字判断那个ting进程即为喜马拉雅的进程 使用cycript注入 1iPad:~ root# cycript -p ting 直接输出UIApp 看应用单例对象是什么 12cy# UIApp#\"&lt;XMUIApplication: 0x144e228a0&gt;\" 是喜马拉雅的全拼,应该就是这个了,如果还要确定,可以输入exit(0)就会发现喜马拉雅被关闭了。 寻找沙盒路径1[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0] 结果如下 1#\"file:///var/mobile/Containers/Data/Application/88888888-0E68-49E6-AB14-457891C5BCFF/Documents/\" 沙盒路径找到了,接下来找音频路径 可以离开cycript了 寻找音频路径 我们知道iOS沙盒一般包含了3个目录 Documents Library tmp StoreKit应该是内购而创建的 排除tmp,StoreKit,第一感觉是音频文件在Documents,cd到该目录查看,反正错了也不要紧,再试就好了 .db数据库文件排除,umengrt应该是友盟统计,分享之类的,chat聊天的 有一个iDoc的目录,尝试进入, 有Download目录,那应该很明显了,进去 尝试过直接发送到电脑,确实是音频 12$ file /Users/Jason/Desktop/Download/00a6b52f49f757bece6676c658789222/Users/Jason/Desktop/Download/00a6b52f49f757bece6676c658789222: ISO Media, Apple iTunes ALAC/AAC-LC (.M4A) Audio 但音频文件的命名是确有点奇怪,应该是使用了类似SDWebImage那种网络图片缓存框架,音频名可能用了md5之类避免冲突,没关系,在应用显示出正常的音频名称,所以肯定会有地方保存映射关系的,上一级在Documents中,发现了名为ting.sqlite的文件,是个sqlite文件,看是不是在数据库保存着映射关系 因为手机上不太好执行sqlite,先用cat看看数据库文件大概的内容 看上去应该是是在该文件中映射关系 导出音频文件关于导出音频文件,可以使用iTools或直接使用终端先打包再使用scp发送 12iPad:xxx# tar -cvzf apps.tar.gz ./Download... 在mac上执行 1» ~ scp root@192.168.1.174:/var/mobile/Containers/Data/Application/88888888-0E68-49E6-AB14-45710CC5BCFF/Documents/iDoc/apps.tar.gz ~/Desktop/apps.tar.gz 传输成功到mac上,接着就进入后续处理操作 类似的得到ting.sqlite文件 后续处理主要是根据根据ting.sqlite处理音频的文件名 打开终端 12345» ~/Desktop sqlite3 ting.sqliteEnter \".help\" for usage hints.sqlite&gt; .tablesadData_table download_tablesqlite&gt; 查询download_table 1sqlite&gt; select * from download_table; 记录的格式如下: 里面确实包含的文件名 证明:映射关系确实存在 先要了解sqlite3与shell的脚本怎么交互,即从sqlite中得到的数据如何传递到shell中 查了一下 sqlite3 与 shell交互大概 有两种方式 echo / cat 通过管道传输进去 此时sqlite3 作为 接收端 sqlite3 xxx ‘查表语句’ 直接sqlite3执行查表语句,最后可以通过管道传给shell处理 在这里选择了第2种 sqlite3文档 大致思路是用awk + sed得到音频名与乱码名,在用mv去修改名称 参考脚本如下 123456789101112131415161718192021222324252627282930313233343536#!/bin/bash## modify the path when you change the place which to store the music file## 工程目录,自定义music_file_path=\"xxx_Path\"cd ${music_file_path}## obtain datassqlite3 ting.sqlite 'select * from download_table' | awk -F \"|\" -v OFS='|' '{print $18,$3,$2}' &gt; mappersed -i \"\" \"s/ /_/g\" ./mappersed -i \"\" \"s/：/_/g\" ./mappersed -i \"\" \"s/:/_/g\" ./mappersed -i \"\" \"s/-/_/g\" ./mappersed -i \"\" \"s/，/_/g\" ./mappersed -i \"\" \"s/－/_/g\" ./mappersed -i \"\" \"s/？/_/g\" ./mappersed -i \"\" \"s/、/_/g\" ./mapper## foreach the download directory to find the music namefor f in ./download/*do ## .download文件 代表还未下载 过掉 # echo ${f##*.} if [ ${f##*.}x != \"download\"x ]; then cache_name=`basename ${f}` music_name=$(grep -r ${cache_name} ./mapper | awk -F \"|\" -v OFS='|' '{print $3}') echo ${cache_name} echo ${music_name} # echo ./download/${music_name}.mp3 mv ./download/${cache_name} ./download/${music_name}.mp3 fidone 效果图 最后试听了一下,音频文件能正常播放,没有问题 参考 shell脚本–if判断（数字条件、字符串条件） Passing Command Line Variables to awk [simple awk tutorial](http://www.hcs.harvard.edu/ ~dholland/computers/awk.html) How to pass variables from awk to shell awk变量传递给SHELL Set variable in current shell from awk Shell获取文件后缀名 Linux shell 之 提取文件名和目录名的一些方法 How to replace space with comma using sed?","link":"/2017/02/18/iOSer-Himalayan-audio-file-export/"},{"title":"iOS9上如何导出其他应用的.ipa文件","text":"在iOS9以下,可以用iTools,PP助手等工具导出其他应用的iPa,但是iOS9开始就不行了 搜索后,根据ios9越狱后如何备份ipa？这篇帖子,尝试用mac版的PP助手在越狱的5s(9.3.2)上导出iPa 报错 安装了afc2add iPa iOS7.x patches依然无法导出,也许win版的可以 从开发者的角度,应该只是想获取其他应用的iPa文件,提供一个方法,其实和iOS的版本没有关系,在mac上用iTunes在AppStore*搜索并下载该应用,下载的.ipa文件会保存在~/Music/iTunes/iTunes Media/Mobile Applications,至于沙盒信息,开发者自己开发的可以通过Xcode*导出,别人别发的,越狱环境下也可以看到。 更新 20170925在 iTunes 12.7 中, Apple 移除了下载 App 的功能,目前已失效","link":"/2017/01/21/iOSer-How-to-export-the-ipa-file-for-other-apps-on-iOS9/"},{"title":"越狱环境下iOS如何制作.deb类型的应用","text":"前言 一般的iOS*应用都是.ipa格式的,Deb格式是Linux下的一种打包方式,相比于.ipa格式需要证书验证那些步骤,在越狱设备下.deb*文件的安装和卸载都比较容易,用终端指令即可。 环境 macOS Sierra 10.12.3 流程大致分为 创建工程 编译 安装 创建工程 越狱环境下创建工程一般有两种,一种是有GUI模板的iOSOpenDev,Github地址已经比较久时间不更新了,安装后的效果图大致如下: 还有一种是用theos,这个在《iOS应用逆向工程》中见到的比较多,本文主要也就用这种方式创建工程。 bla,bla,bla在成功安装theos后,就可以开始了 创建好的工程目录如下 依次进行简单说明 control 描述了这个deb包的一些信息 xxx.h xxx.m这个不用说,iOS工程师应该都知道 Makefile 描述了该工程如何进行编译,引入thoes*的一些文件,参与编译的.m文件(比如*DEBAppDelegate.m),要链接的库文件(比如 UIKit),安装成功后要kill的进程,当然还有其他字段,比如处理器的架构,SDK的版本,这些在《iOS应用逆向工程》中也有说明 编译bla,bla,bla 在.h,.m*中写完代码后,到工程目录下 *make package 如果是第一次安装编译,可能编译的过程会出现不通过的情况,只要根据报错的原因,上Google或stackoverflow搜索一般就能解决。虽然也想贴图说明我遇到的问题,但是当时没有记录下来,以后有空会再试试,换个角度想,为什么写blog呢?如果不写的话,以后忘了,就没有地方找了,一开始多留心些,后面大概就可以省力些吧。 编译成功后 多了两个目录obj和packages,package下就是编译后的deb*包名,每编译一次,后面的-1,就会++*,记录你是第几次成功编译这个包吧 安装 因为生成deb包还是要到手机上运行才行的,所以需要用到scp这个指令,越狱设备一般都会装openssh这个插件,提供远程登陆,方便数据传输。 1scp ./packages/com.coder.createdeb_0.0.1-1+debug_iphoneos-arm.deb root@192.168.5.105:/var/root/ 这个问题大致是因为IP*没变,设备变了,而/.ssh/known_hosts文件中记录的是原来设备的信息,解决方法,删除/.ssh/known_hosts*中的记录 再试一次 ssh登陆设备后,查看root的家目录 已经在设备上了 1dpkg -i dpkg -i com.coder.createdeb_0.0.1-1+debug_iphoneos-arm.deb 当然也可以一条龙服务,直接在Markfile的最上一行加上远程设备的IP地址 1THEOS_DEVICE_IP = 远程设备的IP 安装指令改为 1make package install 然后ssh输入密码的过程也可以去掉 安装成功后,手机桌面可能没有出现安装的deb文件,这时候可以执行以下指令 1su mobile -c uicache 应用截图","link":"/2017/02/07/iOSer-How-to-create-a-deb-type-of-application-in-iOS/"},{"title":"ObjC Runtime 中 Weak 属性的实现 (上)","text":"前言 OC 中的 weak 属性是怎么实现的，为什么在对象释放后会自动变成 nil？本文对这个问题进行了一点探讨。 环境 mac OS Sierra 10.12.4objc709 参考答案 搜索后发现runtime 如何实现 weak 属性给出了一个参考答案。 runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为 0 的时候会 dealloc，假如 weak 指向的对象内存地址是 a ，那么就会以 a 为键， 在这个 weak 表中搜索，找到所有以 a 为键的 weak 对象，从而设置为 nil 。 测试 代码 123456789101112131415161718192021222324252627282930313233#import &lt;Foundation/Foundation.h&gt;@interface WeakProperty : NSObject@property (nonatomic,weak) NSObject *obj;@end@implementation WeakProperty- (void)dealloc { NSLog(@\"%s\",__func__);}@endint main(int argc, const char * argv[]) { @autoreleasepool { WeakProperty *property = [[WeakProperty alloc] init]; NSObject *obj = [[NSObject alloc] init]; property.obj = obj; NSLog(@\"%@\",property.obj); // 会触发函数 ``id objc_initWeak(id *location, id newObj)`` // NSObject *obj = [[NSObject alloc] init]; // __weak NSObject *obj2 = obj; // 会触发函数 ``void objc_copyWeak(id *dst, id *src)`` // __weak NSObject *obj3 = obj2; } return 0;} 结果 对象的 weak 属性调用 setter 时 调用 id objc_storeWeak(id *location, id newObj) 调用 static id storeWeak(id *location, objc_object *newObj)… 使用 NSLog 输出 property.obj 属性时 调用 id objc_loadWeakRetained(id *location) 当 dealloc 释放对象时 调用 void objc_destroyWeak(id *location) 相关函数 查看 NSObject.mm 源码发现 id objc_storeWeak(id *location, id newObj) id objc_storeWeakOrNil(id *location, id newObj) id objc_initWeak(id *location, id newObj) id objc_initWeakOrNil(id *location, id newObj) void objc_destroyWeak(id *location) 都调用了 static id storeWeak(id *location, objc_object *newObj) , objc_xxxWeakOrNil 多了一点额外的处理，但并不影响整体的理解。而 void objc_destroyWeak(id *location) 在调用 static id storeWeak(id *location, objc_object *newObj) 时 newObj 参数传递的是 nil 这一点与上面提到的参考答案中关于 dealloc 释放对象时，将哈希表中指定的键对应的值设置为 nil 是符合的。 小结 storeWeak 函数用于为 weak 属性赋值 (包括销毁) objc_loadWeakRetained 函数用于获取 weak 属性 观察 &amp; 分析 对于函数 storeWeak 主要分析两种情况下的调用 赋值，即 id objc_storeWeak(id *location, id newObj) 销毁，即 void objc_destroyWeak(id *location) 而对于 weak 属性的获取主要分析 函数 id objc_loadWeakRetained(id *location) 观察: id objc_storeWeak(id *location, id newObj) 123456789101112131415/** * This function stores a new value into a __weak variable. It would * be used anywhere a __weak variable is the target of an assignment. * * @param location The address of the weak pointer itself * @param newObj The new object this weak ptr should now point to * * @return \\e newObj */idobjc_storeWeak(id *location, id newObj){ return storeWeak&lt;DoHaveOld, DoHaveNew, DoCrashIfDeallocating&gt; (location, (objc_object *)newObj);} 该函数单纯的调用了 storeWeak 函数 观察: void objc_destroyWeak(id *location) 1234567891011121314151617/** * Destroys the relationship between a weak pointer * and the object it is referencing in the internal weak * table. If the weak pointer is not referencing anything, * there is no need to edit the weak table. * * This function IS NOT thread-safe with respect to concurrent * modifications to the weak variable. (Concurrent weak clear is safe.) * * @param location The weak pointer address. */voidobjc_destroyWeak(id *location){ (void)storeWeak&lt;DoHaveOld, DontHaveNew, DontCrashIfDeallocating&gt; (location, nil);} 该函数也只是单纯的调用了 storeWeak 函数 函数 storeWeak 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687template &lt;HaveOld haveOld, HaveNew haveNew, CrashIfDeallocating crashIfDeallocating&gt;static id storeWeak(id *location, objc_object *newObj){ assert(haveOld || haveNew); if (!haveNew) assert(newObj == nil); Class previouslyInitializedClass = nil; id oldObj; SideTable *oldTable; SideTable *newTable; // Acquire locks for old and new values. // Order by lock address to prevent lock ordering problems. // Retry if the old value changes underneath us. retry: if (haveOld) { oldObj = *location; oldTable = &amp;SideTables()[oldObj]; } else { oldTable = nil; } if (haveNew) { newTable = &amp;SideTables()[newObj]; } else { newTable = nil; } SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); if (haveOld &amp;&amp; *location != oldObj) { SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); goto retry; } // Prevent a deadlock between the weak reference machinery // and the +initialize machinery by ensuring that no // weakly-referenced object has an un-+initialized isa. if (haveNew &amp;&amp; newObj) { Class cls = newObj-&gt;getIsa(); if (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) { SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); _class_initialize(_class_getNonMetaClass(cls, (id)newObj)); // If this class is finished with +initialize then we're good. // If this class is still running +initialize on this thread // (i.e. +initialize called storeWeak on an instance of itself) // then we may proceed but it will appear initializing and // not yet initialized to the check above. // Instead set previouslyInitializedClass to recognize it on retry. previouslyInitializedClass = cls; goto retry; } } // Clean up old value, if any. if (haveOld) { weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); } // Assign new value, if any. if (haveNew) { newObj = (objc_object *) weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, crashIfDeallocating); // weak_register_no_lock returns nil if weak store should be rejected // Set is-weakly-referenced bit in refcount table. if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) { newObj-&gt;setWeaklyReferenced_nolock(); } // Do not set *location anywhere else. That would introduce a race. *location = (id)newObj; } else { // No new value. The storage is not changed. } SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); return (id)newObj;} 可以结合 lldb 边调试边对其进行分析， 分析: id objc_storeWeak(id *location, id newObj) 123// Template parameters.enum HaveOld { DontHaveOld = false, DoHaveOld = true };enum HaveNew { DontHaveNew = false, DoHaveNew = true }; 对于模板参数，传递的是 DoHaveOld(true) &amp; DoHaveNew(true) 在64位汇编中，当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。此处 location 和 newObj 分别来自 rdi 和 rsi。 根据注释加地址比较，可知 location 为 指向弱引用的地址，newObj 为要求 弱引用指向的地址，在当前场景下为赋值给 WeakProperty 的 obj 属性的 obj 变量。 在当前场景下即为执行 storeWeak 后，内存地址 0x0000000101301638 上保存的值为 0x0000000101301490 铺垫: SideTable 关于结构体 SideTable，在本文中当做黑盒来处理 123456789101112131415161718192021222324struct SideTable { spinlock_t slock; RefcountMap refcnts; weak_table_t weak_table; SideTable() { memset(&amp;weak_table, 0, sizeof(weak_table)); } ~SideTable() { _objc_fatal(\"Do not delete SideTable.\"); } void lock() { slock.lock(); } void unlock() { slock.unlock(); } void forceReset() { slock.forceReset(); } // Address-ordered lock discipline for a pair of side tables. template&lt;HaveOld, HaveNew&gt; static void lockTwo(SideTable *lock1, SideTable *lock2); template&lt;HaveOld, HaveNew&gt; static void unlockTwo(SideTable *lock1, SideTable *lock2);}; 关于 spinlock_t，Wiki 上关于 Spinlock 词条的解释如下 In software engineering, a spinlock is a lock which causes a thread trying to acquire it to simply wait in a loop (“spin”) while repeatedly checking if the lock is available. Since the thread remains active but is not performing a useful task, the use of such a lock is a kind of busy waiting. Once acquired, spinlocks will usually be held until they are explicitly released, although in some implementations they may be automatically released if the thread being waited on (that which holds the lock) blocks, or “goes to sleep. 例子 1234567891011121314151617181920212223242526272829303132333435363738; Intel syntaxlocked: ; The lock variable. 1 = locked, 0 = unlocked. dd 0 ; 定义 lock 变量 默认为 0 spin_lock: mov eax, 1 ; Set the EAX register to 1. ; 设置 EAX 寄存器的值为 1 xchg eax, [locked] ; Atomically swap the EAX register with ; the lock variable. ; This will always store 1 to the lock, leaving ; the previous value in the EAX register. ; 交换 eax 与 lock 变量的值，根据上一步可知，lock 肯定会被赋值为1 test eax, eax ; Test EAX with itself. Among other things, this will ; set the processor's Zero Flag if EAX is 0. ; If EAX is 0, then the lock was unlocked and ; we just locked it. ; Otherwise, EAX is 1 and we didn't acquire the lock. ; 将 EAX 与 自身比较，如果 EAX 是 0 则设置 Zeor Flag ，表明当前未加锁，只要加锁操作即可，反之证明已被加锁，不设置 Zero Flag。 jnz spin_lock ; Jump back to the MOV instruction if the Zero Flag is ; not set; the lock was previously locked, and so ; we need to spin until it becomes unlocked. ; 如果 Zero Flag 未被设置，则跳转继续 spin_lock ret ; The lock has been acquired, return to the calling ; function. ; 获得锁后，继续执行; 当获得所的操作执行完成后，则 locked 变成 0，另一个线程再次进行 spin_lock 操作 locked 为 0，导致 EAX 为0 ，重新获得了锁，同时 locked 变成 1...spin_unlock: mov eax, 0 ; Set the EAX register to 0. xchg eax, [locked] ; Atomically swap the EAX register with ; the lock variable. ret ; The lock has been released. 配合 google 的翻译可知，自旋锁会循环等待直到锁可用。 从 weak_table_t 结构体的注释说明了，它会保存 ids 和 keys 的形式保存对象 12345678910/** * The global weak references table. Stores object ids as keys, * and weak_entry_t structs as their values. */struct weak_table_t { weak_entry_t *weak_entries; size_t num_entries; uintptr_t mask; uintptr_t max_hash_displacement;}; 结构体 SideTable 可看做是一个带加锁功能的集合，其中的元素以键值对的形式存放。 在 ObjC 的入口函数 _objc_init 会调用函数 arr_init 来初始化 SideTableBuf 静态变量 正文: id objc_storeWeak(id *location, id newObj) 进入 if (haveOld) 条件 创建新元素，因此 location 地址的原值为 nil 进入 SideTables() 函数 123static StripedMap&lt;SideTable&gt;&amp; SideTables() { return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);} 关于 reinterpret_cast 的讨论 reinterpret_cast is the most dangerous cast, and should be used very sparingly. It turns one type directly into another - such as casting the value from one pointer to another, or storing a pointer in an int, or all sorts of other nasty things. Largely, the only guarantee you get with reinterpret_cast is that normally if you cast the result back to the original type, you will get the exact same value (but not if the intermediate type is smaller than the original type). There are a number of conversions that reinterpret_cast cannot do, too. It’s used primarily for particularly weird conversions and bit manipulations, like turning a raw data stream into actual data, or storing data in the low bits of an aligned pointer. 它是一种类型强转的方式 SideTableBuf 是大小为 4096 的 SideTable 缓存数组， oldTable 的赋值相当于在取数组元素，nil 可看成 0 ，即取第一个元素。 同理，haveNew 为 true ，newTable 是以 newObj 为索引在 SideTabBuf 中 查找元素。 调用 SideTable::lockTwo 方法 1SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); 进入 SideTable::lockTwo 方法 123456template&lt;&gt;void SideTable::lockTwo&lt;DoHaveOld, DoHaveNew&gt; (SideTable *lock1, SideTable *lock2){ spinlock_t::lockTwo(&amp;lock1-&gt;slock, &amp;lock2-&gt;slock);} 进入 lockTwo 方法 1234567891011// Address-ordered lock discipline for a pair of locks.static void lockTwo(mutex_tt *lock1, mutex_tt *lock2) { if (lock1 &lt; lock2) { lock1-&gt;lock(); lock2-&gt;lock(); } else { lock2-&gt;lock(); if (lock2 != lock1) lock1-&gt;lock(); }} 判断 if (haveOld &amp;&amp; *location != oldObj) 条件 haveOld &amp;&amp; *location != oldObj ，oldObj 被赋值为 *location 正常情况下，两者相等，不等说明出了问题，算是容错。 判断 if (haveNew &amp;&amp; newObj) 条件 haveNew &amp;&amp; newObj 根据注释可知也是一个容错的处理 清除旧值 123if (haveOld) { weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);} 赋予新值 123456789101112131415161718// Assign new value, if any.if (haveNew) { newObj = (objc_object *) weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, crashIfDeallocating); // weak_register_no_lock returns nil if weak store should be rejected // Set is-weakly-referenced bit in refcount table. if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) { newObj-&gt;setWeaklyReferenced_nolock(); } // Do not set *location anywhere else. That would introduce a race. *location = (id)newObj;}else { // No new value. The storage is not changed.} 以 location 为 key,以 newObj 为值保存到对应的 weak_table_t 的结构体中 调用 SideTable::unlockTwo 方法 1SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); 分析: void objc_destroyWeak(id *location) 因为传递的模板参数为 DontHaveNew ，当释放掉旧值后，不会再进入 if (haveNew) 条件中获得新值。 分析: id objc_loadWeakRetained(id *location) 1234567retry: // fixme std::atomic this load obj = *location; ... result = obj; ... return result 通过 * 取值符号操作 location ，获得弱引用指向的地址。 总结 本文通过对 ObjC 运行时粗略分析，来了解 weak 属性是如何进行存储，使用与释放的。ObjC 的类结构中一个静态的键值对表变量，它保存着对象的弱引用属性，其中的键为指向弱引用的内存地址，值为弱引用，当对象销毁时通过键查表，然后将对应的弱引用从表中移除。 参考 When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used? The LLDB Debugger 64位汇编参数传递 Wiki - Spinlock alignas specifier 4.3.7. MOV and MVN","link":"/2017/05/29/iOSer-Implementation-of-Weak-Attribute-in-ObjC-Runtime-Part1/"},{"title":"ObjC Runtime 中 Weak 属性的实现 (中)","text":"导语 在上一篇中简单分析了 Weak 属性是如何被存储，获取和销毁的，其中的 SideTable 结构体当做黑盒进行处理。本文尝试对 SideTable 的结构进行一些分析。 观察 123456789101112131415161718192021222324struct SideTable { spinlock_t slock; RefcountMap refcnts; weak_table_t weak_table; SideTable() { memset(&amp;weak_table, 0, sizeof(weak_table)); } ~SideTable() { _objc_fatal(\"Do not delete SideTable.\"); } void lock() { slock.lock(); } void unlock() { slock.unlock(); } void forceReset() { slock.forceReset(); } // Address-ordered lock discipline for a pair of side tables. template&lt;HaveOld, HaveNew&gt; static void lockTwo(SideTable *lock1, SideTable *lock2); template&lt;HaveOld, HaveNew&gt; static void unlockTwo(SideTable *lock1, SideTable *lock2);}; SideTable 主要分为 3 部分 weak_table_t: weak 引用的全局 hash 表 RefcountMap : 引用计数的 hash 表 slock: 保证原子操作的自旋锁 在 static id storeWeak(id *location, objc_object *newObj) 方法中有 123456789101112131415// Assign new value, if any.if (haveNew) { newObj = (objc_object *) weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, crashIfDeallocating); // weak_register_no_lock returns nil if weak store should be rejected // Set is-weakly-referenced bit in refcount table. if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) { newObj-&gt;setWeaklyReferenced_nolock(); } // Do not set *location anywhere else. That would introduce a race. *location = (id)newObj;} 可知对于弱引用变量的保存，主要还是看 weak_table 这个属性 测试代码 1234567891011121314151617181920212223242526272829303132333435363738394041#import &lt;Foundation/Foundation.h&gt;@interface WeakProperty : NSObject@property (nonatomic,weak) NSObject *obj;@property (nonatomic,weak) NSObject *obj2;@property (nonatomic,weak) NSObject *obj3;@property (nonatomic,weak) NSObject *obj4;@property (nonatomic,weak) NSObject *obj5;@end@implementation WeakProperty- (void)dealloc { NSLog(@\"%s\",__func__);}@endint main(int argc, const char * argv[]) { @autoreleasepool { WeakProperty *property = [[WeakProperty alloc] init]; NSObject *obj = [[NSObject alloc] init]; property.obj = obj; NSLog(@\"%@\",property.obj); // [1] property.obj2 = obj; // [2] property.obj3 = obj; property.obj4 = obj; property.obj5 = obj; // [3] property.obj = nil; } return 0;} 结构体: weak_table_t weak_table_t 的定义在 objc-weak.h 中 12345678910/** * The global weak references table. Stores object ids as keys, * and weak_entry_t structs as their values. */struct weak_table_t { weak_entry_t *weak_entries; size_t num_entries; uintptr_t mask; uintptr_t max_hash_displacement;}; 说明: 一个指向 weak_entry_t 的指针 size_t(即 unsigned ) 类型的 num_entries ，用于描述 hash 表的长度 uintptr_t(即 unsigned long) 类型的 mask(掩码) uintptr_t(即 unsigned long) 类型的 max_hash_displacement 结构体: weak_entry_t 12345678910111213141516171819202122232425262728293031323334struct weak_entry_t { DisguisedPtr&lt;objc_object&gt; referent; union { struct { weak_referrer_t *referrers; uintptr_t out_of_line_ness : 2; uintptr_t num_refs : PTR_MINUS_2; uintptr_t mask; uintptr_t max_hash_displacement; }; struct { // out_of_line_ness field is low bits of inline_referrers[1] weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; }; }; bool out_of_line() { return (out_of_line_ness == REFERRERS_OUT_OF_LINE); } weak_entry_t&amp; operator=(const weak_entry_t&amp; other) { memcpy(this, &amp;other, sizeof(other)); return *this; } weak_entry_t(objc_object *newReferent, objc_object **newReferrer) : referent(newReferent) { inline_referrers[0] = newReferrer; for (int i = 1; i &lt; WEAK_INLINE_COUNT; i++) { inline_referrers[i] = nil; } }}; 在 C++ 中，结构体是由关键词 struct 定义的一种数据类型。他的成员和基类默认为公有的（public）。由关键词 class 定义的成员和基类默认为私有的（private）。这是 C++ 中 结构体和类仅有的区别。 类: DisguisedPtr 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// DisguisedPtr&lt;T&gt; acts like pointer type T*, except the // stored value is disguised to hide it from tools like `leaks`.// nil is disguised as itself so zero-filled memory works as expected, // which means 0x80..00 is also disguised as itself but we don't care.// Note that weak_entry_t knows about this encoding.template &lt;typename T&gt;class DisguisedPtr { uintptr_t value; // unsigned long static uintptr_t disguise(T* ptr) { return -(uintptr_t)ptr; } static T* undisguise(uintptr_t val) { return (T*)-val; } public: DisguisedPtr() { } DisguisedPtr(T* ptr) : value(disguise(ptr)) { } DisguisedPtr(const DisguisedPtr&lt;T&gt;&amp; ptr) : value(ptr.value) { } DisguisedPtr&lt;T&gt;&amp; operator = (T* rhs) { value = disguise(rhs); return *this; } DisguisedPtr&lt;T&gt;&amp; operator = (const DisguisedPtr&lt;T&gt;&amp; rhs) { value = rhs.value; return *this; } // 重载了一些指针的运算符 operator T* () const { return undisguise(value); } T* operator -&gt; () const { return undisguise(value); } T&amp; operator * () const { return *undisguise(value); } T&amp; operator [] (size_t i) const { return undisguise(value)[i]; } // pointer arithmetic operators omitted // because we don't currently use them anywhere}; 1234// The address of a __weak variable.// These pointers are stored disguised so memory analysis tools// don't see lots of interior pointers from the weak table into objects.typedef DisguisedPtr&lt;objc_object *&gt; weak_referrer_t; 小结 weak_entry_t 包含一个 DisguisedPtr&lt;objc_object&gt;,Disguised 是伪装的意思，根据注释可知，可以将 DisguisedPtr&lt;T&gt; 当成 T * 指针类型即可，在当前场景可看作是一个指向 objc_object 的指针类型 weak_referrer_t 是 DisguisedPtr&lt;objc_object *&gt; 可以看成是 objc_object 指针的地址 接着是一个 union ，out_of_line_ness 与 inline_referrers[1] 共用了低 2 位，因为 123456// out_of_line_ness field overlaps with the low two bits of inline_referrers[1].// inline_referrers[1] is a DisguisedPtr of a pointer-aligned address.// The low two bits of a pointer-aligned DisguisedPtr will always be 0b00// (disguised nil or 0x80..00) or 0b11 (any other address).// Therefore out_of_line_ness == 0b10 is used to mark the out-of-line state.#define REFERRERS_OUT_OF_LINE 2 注释说明了 DisuisedPtr 的低 2 位不是 0b00 就是 0b11，所以要表示 out-of-line 只能使用 out_of_line_ness == 0b10 (当 out_of_line_ness 为 0b01 或 0b10 会分别得到 false 和 true ) num_refs 占 30 (32位系统) / 62(64位系统) 位mask 和 max_hash_displacement 在 weak_table_t 中也有。 out_of_line() 方法在上面算是已经说过了 weak_entry_t&amp; operator=(const weak_entry_t&amp; other) {...} 重载运算符 = The memcpy() function copies n bytes from memory area srcto memory area dest. The memory areas may not overlap.Use memmove(3) if the memory areas do overlap. 从参数 other 所指的内存地址的起始位置开始拷贝 sizeof(other) 字节到 this 指针指向的当前对象的起始地址。 weak_entry_t(objc_object *newReferent, objc_object **newReferrer) : referent(newReferent) : referent(newReferent) 是初始化列表，代表用参数 newReferent来初始化结构体中的 referent 属性。联合类型中的 inline_referrers[0] 接收参数 newReferrer ，并将剩下的 1，2，3 都置为 nil 函数: weak_register_no_lock 注释 [2] &amp; [3] 1234/// Adds an (object, weak pointer) pair to the weak table./// 添加一个 (对象，弱引用指针）到 weak hash 表中id weak_register_no_lock(weak_table_t *weak_table, id referent, id *referrer, bool crashIfDeallocating); 具体实现如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Registers a new (object, weak pointer) pair. Creates a new weak * object entry if it does not exist. * * @param weak_table The global weak table. * @param referent The object pointed to by the weak reference. * @param referrer The weak pointer address. */id weak_register_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id, bool crashIfDeallocating){ objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; if (!referent || referent-&gt;isTaggedPointer()) return referent_id; // ensure that the referenced object is viable bool deallocating; if (!referent-&gt;ISA()-&gt;hasCustomRR()) { deallocating = referent-&gt;rootIsDeallocating(); } else { BOOL (*allowsWeakReference)(objc_object *, SEL) = (BOOL(*)(objc_object *, SEL)) object_getMethodImplementation((id)referent, SEL_allowsWeakReference); if ((IMP)allowsWeakReference == _objc_msgForward) { return nil; } deallocating = ! (*allowsWeakReference)(referent, SEL_allowsWeakReference); } if (deallocating) { if (crashIfDeallocating) { _objc_fatal(\"Cannot form weak reference to instance (%p) of \" \"class %s. It is possible that this object was \" \"over-released, or is in the process of deallocation.\", (void*)referent, object_getClassName((id)referent)); } else { return nil; } } // now remember it and where it is being stored weak_entry_t *entry; if ((entry = weak_entry_for_referent(weak_table, referent))) { append_referrer(entry, referrer); } else { weak_entry_t new_entry(referent, referrer); weak_grow_maybe(weak_table); weak_entry_insert(weak_table, &amp;new_entry); } // Do not set *referrer. objc_storeWeak() requires that the // value not change. return referent_id;} 弱引用属性 obj 在函数 weak_register_no_lock 中传递给行参 referent_id， 赋值给局部变量 referent ，location 传递给形参 referrer_id，赋值给局部变量 referrer。 经过一些检查，比如是否允许弱引用，弱引用对象是否可用。 123456789101112131415161718192021222324252627282930313233/** * Return the weak reference table entry for the given referent. * If there is no entry for referent, return NULL. * Performs a lookup. * * @param weak_table * @param referent The object. Must not be nil. * * @return The table of weak referrers to this object. */static weak_entry_t *weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent){ assert(referent); weak_entry_t *weak_entries = weak_table-&gt;weak_entries; if (!weak_entries) return nil; size_t begin = hash_pointer(referent) &amp; weak_table-&gt;mask; size_t index = begin; size_t hash_displacement = 0; while (weak_table-&gt;weak_entries[index].referent != referent) { index = (index+1) &amp; weak_table-&gt;mask; if (index == begin) bad_weak_table(weak_table-&gt;weak_entries); hash_displacement++; if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) { return nil; } } return &amp;weak_table-&gt;weak_entries[index];} 根据 referent 为 key ，在 weak_table 中通过遍历 weak_entries 数组，对referent 属性值进行比较的方式来查找元素，未找到，走 else 12345678weak_entry_t(objc_object *newReferent, objc_object **newReferrer) : referent(newReferent){ inline_referrers[0] = newReferrer; for (int i = 1; i &lt; WEAK_INLINE_COUNT; i++) { inline_referrers[i] = nil; }} 执行 weak_entry_t 结构体的初始化 通过强转操作来伪装指针。接收 newReferrer 即 referrer 为 inline_referrers[0] 在这里 *referrer 等于 nil 所以 inline_referres 数组元素全指向 nil，因为是无符号长整数，因此就是 0。 函数: weak_grow_maybe 当弱引用的 hash 表的空间使用率达到 3/4 后，扩充 hash 表 12345678910// Grow the given zone's table of weak references if it is full.static void weak_grow_maybe(weak_table_t *weak_table){ size_t old_size = TABLE_SIZE(weak_table); // Grow if at least 3/4 full. if (weak_table-&gt;num_entries &gt;= old_size * 3 / 4) { weak_resize(weak_table, old_size ? old_size*2 : 64); }} 函数: weak_entry_insert 添加元素到弱引用的 hash 表中 12345678910111213141516171819202122232425/** * Add new_entry to the object's table of weak references. * Does not check whether the referent is already in the table. */static void weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry){ weak_entry_t *weak_entries = weak_table-&gt;weak_entries; assert(weak_entries != nil); size_t begin = hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask); size_t index = begin; size_t hash_displacement = 0; while (weak_entries[index].referent != nil) { index = (index+1) &amp; weak_table-&gt;mask; if (index == begin) bad_weak_table(weak_entries); hash_displacement++; } weak_entries[index] = *new_entry; weak_table-&gt;num_entries++; if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) { weak_table-&gt;max_hash_displacement = hash_displacement; }} 获取 new_entry 的 referent 属性，即弱引用的 obj 属性，以其地址的无符号长整数取相反数来做参数，通过移位与位移进行 hash 操作，通过 weak_table-&gt;mask(63 = 0b111111) 掩码保留 hash 操作后的低 6 位( 64 位系统),作为索引，接下来用 while (weak_entries[index].referent != nil) {...} ，解决 hash 碰撞的问题。然后添加到 hash 表中，修改表的长度 效果如上图所示，static id storeWeak(id *location, objc_object *newObj) 的 location 和 newObj 分别被保存到 weak_table_t 结构体的 referent ，inline_referrers 数组的首位。 查找 referent 是否存在的条件是 12345678while (weak_table-&gt;weak_entries[index].referent != referent) { index = (index+1) &amp; weak_table-&gt;mask; if (index == begin) bad_weak_table(weak_table-&gt;weak_entries); hash_displacement++; if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) { return nil; }} 注释 [2] &amp; [3] 进入 append_referrer 函数后 12345678if (! entry-&gt;out_of_line()) { // Try to insert inline. for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { if (entry-&gt;inline_referrers[i] == nil) { entry-&gt;inline_referrers[i] = new_referrer; return; } } 因为 entry-&gt; out_of_line() 等于 false 会尝试添加到 (entry-&gt;inline_referrers 数组中。 取消 [2] 的注释，因为已经达到 4 个，所以在 obj5 时，会扩充。 1234567891011// Couldn't insert inline. Allocate out of line.weak_referrer_t *new_referrers = (weak_referrer_t *) calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t));// This constructed table is invalid, but grow_refs_and_insert// will fix it and rehash it.for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { new_referrers[i] = entry-&gt;inline_referrers[i];}entry-&gt;referrers = new_referrers;entry-&gt;num_refs = WEAK_INLINE_COUNT;entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE; 会设置 entry-&gt;out_of_line_ness 为 REFERRERS_OUT_OF_LINE 结合注释 1234567/** * The internal structure stored in the weak references table. * It maintains and stores * a hash set of weak references pointing to an object. * If out_of_line_ness != REFERRERS_OUT_OF_LINE then the set * is instead a small inline array. */ 可知当 weak 变量引用数量不多于 4 个时，会使用数组方式进行存储，而多于 4 个后会用 hash 表的方式进行存储。 函数: weak_unregister_no_lock123/// Removes an (object, weak pointer) pair from the weak table./// 从 weak hash 表中移除一个(对象，弱引用指针）void weak_unregister_no_lock(weak_table_t *weak_table, id referent, id *referrer); 具体实现如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Unregister an already-registered weak reference. * This is used when referrer's storage is about to go away, but referent * isn't dead yet. (Otherwise, zeroing referrer later would be a * bad memory access.) * Does nothing if referent/referrer is not a currently active weak reference. * Does not zero referrer. * * FIXME currently requires old referent value to be passed in (lame) * FIXME unregistration should be automatic if referrer is collected * * @param weak_table The global weak table. * @param referent The object. * @param referrer The weak reference. */voidweak_unregister_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id){ objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; weak_entry_t *entry; if (!referent) return; if ((entry = weak_entry_for_referent(weak_table, referent))) { remove_referrer(entry, referrer); bool empty = true; if (entry-&gt;out_of_line() &amp;&amp; entry-&gt;num_refs != 0) { empty = false; } else { for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { if (entry-&gt;inline_referrers[i]) { empty = false; break; } } } if (empty) { weak_entry_remove(weak_table, entry); } } // Do not set *referrer = nil. objc_storeWeak() requires that the // value not change.} 同样是使用 weak_entry_for_referent 函数查找弱引用是否存在 注释 [1] &amp; [2] ，取消注释 [3] 1234567891011121314151617181920212223242526272829303132333435363738/** * Remove old_referrer from set of referrers, if it's present. * Does not remove duplicates, because duplicates should not exist. * * @todo this is slow if old_referrer is not present. Is this ever the case? * * @param entry The entry holding the referrers. * @param old_referrer The referrer to remove. */static void remove_referrer(weak_entry_t *entry, objc_object **old_referrer){ if (! entry-&gt;out_of_line()) { for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { if (entry-&gt;inline_referrers[i] == old_referrer) { entry-&gt;inline_referrers[i] = nil; return; } } ... objc_weak_error(); return; } size_t begin = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask); size_t index = begin; size_t hash_displacement = 0; while (entry-&gt;referrers[index] != old_referrer) { index = (index+1) &amp; entry-&gt;mask; if (index == begin) bad_weak_table(entry); hash_displacement++; if (hash_displacement &gt; entry-&gt;max_hash_displacement) { ... return; } } entry-&gt;referrers[index] = nil; entry-&gt;num_refs--;} 移除时，是以 referrer 属性来比较，发现地址相同，将其置为 nil 来实现移除的效果。 函数: weak_clear_no_lock123/// Called on object destruction. Sets all remaining weak pointers to nil./// 在对象调用析构方法时，设置所有留下的弱引用指针为nilvoid weak_clear_no_lock(weak_table_t *weak_table, id referent); 具体实现如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Called by dealloc; nils out all weak pointers that point to the * provided object so that they can no longer be used. * * @param weak_table * @param referent The object being deallocated. */void weak_clear_no_lock(weak_table_t *weak_table, id referent_id) { objc_object *referent = (objc_object *)referent_id; weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == nil) { /// XXX shouldn't happen, but does with mismatched CF/objc //printf(\"XXX no entry for clear deallocating %p\\n\", referent); return; } // zero out references weak_referrer_t *referrers; size_t count; if (entry-&gt;out_of_line()) { referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); } else { referrers = entry-&gt;inline_referrers; count = WEAK_INLINE_COUNT; } for (size_t i = 0; i &lt; count; ++i) { objc_object **referrer = referrers[i]; if (referrer) { if (*referrer == referent) { *referrer = nil; } else if (*referrer) { _objc_inform(\"__weak variable at %p holds %p instead of %p. \" \"This is probably incorrect use of \" \"objc_storeWeak() and objc_loadWeak(). \" \"Break on objc_weak_error to debug.\\n\", referrer, (void*)*referrer, (void*)referent); objc_weak_error(); } } } weak_entry_remove(weak_table, entry);} 会被 dealloc 调用，根据注释和代码可知同样以 referent 为 key 遍历,然后依次将置为 nil，但是测试时，走的都是 if (entry == nil) 然后直接 return。 总结 弱引用查找根据 referent 属性，首次会被存储到 weak_table_t 结构体 referent 和 inline_referrers[0],当继续添加时，如果引用次数不大于 4 个保存在数组inline_referrers 中，当超过 4 个后以 hash 表的形式进行存储。移除时，根据 referrer 从 inline_referrers 中移除。 参考 int - What is size_t in C? - Stack Overflow wiki - C++类 wiki - 位段 Linux Programmer’s Manual memcpy inline bool objc_object::isTaggedPointer(); How does the function work? PHP哈希表碰撞攻击原理 wiki - 掩码 wiki - 哈希表 When to use reinterpret_cast? OSObject c++ operator操作符的两种用法：重载和隐式类型转换，string转其他基本数据类型的简洁实现string_cast c++中冒号（:）和双冒号（::）的用法 ARC 引用计数之weak","link":"/2017/06/04/iOSer-Implementation-of-Weak-Attribute-in-ObjC-Runtime-Part2/"},{"title":"iOS 颜色宏","text":"前言 平常用的颜色宏大概如下 1#define RGBHex(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) &gt;&gt; 16))/255.0 green:((float)((rgbValue &amp; 0xFF00) &gt;&gt; 8))/255.0 blue:((float)(rgbValue &amp; 0xFF))/255.0 alpha:1.0] 考虑到蓝湖中获得的十六进制颜色值为#FF0000,cv时需要先删除#再添加0x,想省略这部分 实现 C语言宏中’#’称之为字符串化操作符(Stringizing Operator)，它将函数宏的实际参数转换为对应的字符串常量。利用这个特点定义如下的颜色宏 123456789101112131415161718#define HEXA(COLOR,A) ({ \\ char *color = #COLOR;\\ NSString *colorString = [NSString stringWithUTF8String:color]; \\ colorString = [colorString stringByReplacingOccurrencesOfString:@\"#\" withString:@\"\"]; \\ colorString = [colorString stringByReplacingOccurrencesOfString:@\"0x\" withString:@\"\"]; \\ unsigned int red,green,blue; \\ NSRange range; \\ range.length = 2; \\ range.location = 0; \\ [[NSScanner scannerWithString:[colorString substringWithRange:range]] scanHexInt:&amp;red]; \\ range.location = 2; \\ [[NSScanner scannerWithString:[colorString substringWithRange:range]] scanHexInt:&amp;green]; \\ range.location = 4; \\ [[NSScanner scannerWithString:[colorString substringWithRange:range]] scanHexInt:&amp;blue]; \\ [UIColor colorWithRed:red/255.0f green:green/255.0f blue:blue/255.0f alpha:A]; \\})#define HEX(COLOR) HEXA(COLOR,1.0) 支持0xFF0000/#FF0000/FF0000这三种格式","link":"/2019/11/25/iOSer-OC-Color-macro/"},{"title":"实践 - Touch ID 解锁功能","text":"导语iOS 8 引入了 Touch ID 认证的方式来解决输入密码的麻烦操作，Swift 最低需要 iOS 8*，因此本文会用 *Swift 来实现 Touch ID 功能 环境 macOS Sierra 10.12.4Xcode 8.3.1Swift 3.0iPhone 6S 10.1.1 Touch ID 需要硬件支持 LocalAuthentication.frameworkTouch ID 认证依赖的框架，引入即可 LAContextTouch ID 认证的上下文对象 有两个方法 能不能?1open func canEvaluatePolicy(_ policy: LAPolicy, error: NSErrorPointer) -&gt; Bool LAPolicy12345678public enum LAPolicy : Int {/// Device owner was authenticated using a biometric method (Touch ID).@available(iOS 8.0, *) case deviceOwnerAuthenticationWithBiometrics /// Device owner was authenticated by Touch ID or device passcode.@available(iOS 9.0, *) case deviceOwnerAuthentication 具体用那种策略去验证。 NSErrorPointer1public typealias NSErrorPointer = AutoreleasingUnsafeMutablePointer&lt;NSError?&gt;? 流程(显示什么,结果如何?)1open func evaluatePolicy(_ policy: LAPolicy, localizedReason: String, reply: @escaping (Bool, Error?) -&gt; Swift.Void) localizedReason 要求 Touch ID 验证的原因 reply返回的结果后的回调 LAError失败的原因有 认证失败(比如用了未被认证的手指) 用户取消 用户取消选择了输入密码 系统取消(比如另一个程序切换至前台) 未设置密码 设备不支持 未设置 Touch ID (手指没设置) iOS 9 上又添加了 3 种情况 失败次数过多 被取消 ( 上一次认证过程还未结束 ) LAContext 上下文对象有不合法 具体详情可以查看 LAError 枚举的定义 Code12345678910111213141516171819202122232425262728293031323334func authenticateUser() { // Get the local authentication context. let context = LAContext() // Declare a NSError variable. var error: NSError? // Set the reason string that will appear on the authentication alert. let reasonString = \"请画押🐾\" if context.canEvaluatePolicy(LAPolicy.deviceOwnerAuthenticationWithBiometrics, error: &amp;error) { _ = [context .evaluatePolicy(LAPolicy.deviceOwnerAuthenticationWithBiometrics, localizedReason: reasonString, reply: { (success: Bool, evalPolicyError: Error?) -&gt; Swift.Void in if success { print(\"Authentication success\") } else{ let err : LAError = LAError(_nsError: evalPolicyError! as NSError) switch err.code.rawValue { case LAError.systemCancel.rawValue: print(\"Authentication was cancelled by the system\") case LAError.userCancel.rawValue: print(\"Authentication was cancelled by the user\") case LAError.userFallback.rawValue: print(\"User selected to enter custom password\") default: print(\"Authentication failed\") break } } } )] }} Demo 总结 Touch ID 功能的设计其实比较直观，实现也挺容易的，遇到的干扰主要是 Swift 由于版本迭代语法上的差异。 参考 Working with Touch ID API in iOS 8 SDK What’s New in iOS 8.0 Touch ID Xcode 8 / Swift 3: “Expression of type UIViewController? is unused” warning","link":"/2017/04/29/iOSer-Practice-Touch-ID-unlock-function/"},{"title":"OC & Swift 混编","text":"导语 本文主要简单描述了在 OC &amp; Swift 混编工程中，两者是如何相互调用的，顺便实现在 Swift 中获取类的属性。 环境 macOS Sierra 10.12.4Xcode 8.3.1Swift 3.0 流程Swift 调用 OC 在 OC 编程语言编写的源工程中，当创建 Swift 文件时，根据提示创建好桥接文件。在桥接文件中有如下注释 Use this file to import your target’s public headers that you would like to expose to Swift. 通过在该文件引入头文件可以顺利实现在 Swift 中调用 OC 方法。 OC 调用 Swift 查看 Build Settings ，其中有一项 Swift Compiler - General 如下图所示 其中 Objective-C Bridging Header 字段即为桥接文件。下面的 Objective-C Generated interface Header Name 字段就是 OC 中调用 Swift 类时需要引入的头文件。该字段的值的规则为 工程名-Swift.h 123456// 引入头文件#import \"Daily_modules-Swift.h\"// 使用Swift文件[[TouchIDViewController alloc] init]; 按住 ⌘ 进入 TouchIDViewController 123456789101112131415@import UIKit;#endif#pragma clang diagnostic ignored \"-Wproperty-attribute-mismatch\"#pragma clang diagnostic ignored \"-Wduplicate-method-arg\"@class NSBundle;@class NSCoder;SWIFT_CLASS(\"_TtC13Daily_modules21TouchIDViewController\")@interface TouchIDViewController : UIViewController- (void)viewDidLoad;- (void)didReceiveMemoryWarning;- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;@end 在运行时工程的 objc-runtime-new.h 头文件中 12345678910111213141516struct objc_class : objc_object { ... class_data_bits_t bits; ...}struct class_data_bits_t { ... bool isSwift() { return getBit(FAST_IS_SWIFT); } ...}// class is a Swift class#define FAST_IS_SWIFT (1UL&lt;&lt;0) 可以了解到 Swift 编写的类也就会被运行时处理。 Swift 的类的名称 比如当前工程的 _TtC13Daily_modules21TouchIDViewController 如何来的。 前缀 _TtC工程名的长度: 13工程名: Daily_modles类名的长度: 21类名: TouchIDViewController 12345678910111213extension NSObject { // create a static method to get a swift class for a string name public class func swiftClassFromString(className: String) -&gt; AnyClass! { // get the project name if let appName = Bundle.main.object(forInfoDictionaryKey: \"CFBundleName\") as! String? { // generate the full name of your class (take a look into your \"YourProject-swift.h\" file) let classStringName = \"_TtC\\(appName.lengthOfBytes(using: String.Encoding.utf8))\\(appName)\\(className.lengthOfBytes(using: String.Encoding.utf8))\\(className)\" // return the class! return NSClassFromString(classStringName) } return nil; }} 上面是一个获取 Swift 类的 extension Swift 版获取类的属性12345678910111213141516171819public class func getPropertiesInfo(cls:AnyClass?, recursive:Bool) -&gt; Any! { var clsM = cls var glist = [String]() var outCount:UInt32 = 0; repeat { let properties:UnsafeMutablePointer&lt;objc_property_t?&gt; = class_copyPropertyList(clsM, &amp;outCount); for index in 0..&lt;outCount { let property = property_getName(properties[Int(index)]) let result = String(cString: property!) glist.append(result) } clsM = clsM?.superclass() print(clsM! == NSObject.self); }while (clsM! != NSObject.self &amp;&amp; recursive) return glist} 只能获取 public / open 访问范围的属性 + OC 原有的属性 总结在 Swift 的注释中如下的一段话 /// Accessing Objective-C Methods and Properties/// ============================================////// When you use AnyObject as a concrete type, you have at your disposal/// every @objc method and property—that is, methods and properties/// imported from Objective-C or marked with the @objc attribute. Because/// Swift can’t guarantee at compile time that these methods and properties/// are actually available on an AnyObject instance’s underlying type, these/// @objc symbols are available as implicitly unwrapped optional methods and/// properties, respectively. 这一点和参考链接中提到的表达是有关的 纯Swift类的函数调用已经不再是Objective-c的运行时发消息，而是类似C++的vtable，在编译时就确定了调用哪个函数，所以没法通过runtime获取方法、属性。 TestSwiftVC继承自UIViewController，基类NSObject，而Swift为了兼容Objective-C，凡是继承自NSObject的类都会保留其动态性，所以我们能通过runtime拿到他的方法。 Swift 不能通过运行时获取对应类的属性和方法，但是如果是继承自 NSObject( imported from Objective-C ) 或被标记了 @objc 则可以被获取,能被获取到的属性也是有所限制的。 参考 Swift language NSClassFromString Swift Runtime 分析：还像 OC Runtime 一样吗？ I can’t get properties of a Class using swift by class_copyPropertyList List of class’s properties in swift","link":"/2017/04/25/iOSer-OC-Swift-Mixed/"},{"title":"实践篇：iOS 应用重签名 (下)","text":"导语 本文主要描述了在包含多 target 与 注入 dylib 的场景下该如何进行重签名的操作。 环境 &amp; 工具 macOS Sierra 10.12.4Xcode 8.3.1Jailbreak iPad 8.4No Jailbreak iPhone 10.1.1yololibtheosmobiledeviceWechat 6.5.7 多 target 在 Apple 官方的Code Signing Guide 中提到参与签名的有二进制文件，库文件，资源文件。微信的 .ipa 包中包含了 PlugIns 目录，里面包含了插件的二进制文件，Watch 目录，其中包含了应用在 Watch OS 平台下的二进制文件。 该如何签名呢? 创建一个工程，添加了 ShareExtension + Watch OS 的 target*，然后 *Archive 看看 Xcode 是如何执行签名流程的。 从上面的截图可知 Xcode 签名的所需要的内容，还是和上篇中说的一致，但是多 target 环境下需要对二进制由内到外进行签名操作，同时每个 target 都需要有各自的描述文件。 用 otool -l path/to/unix_exec_file | grep -B 2 crypt 来确定是否被加壳了。经过测试发现 Plugins 目录下的二进制是加密的，而 Watch 目录下的二进制并没有被加密 因为加壳的代码要脱壳才能进行重签名，一般会用类似 dumpdecrypted 的工具在运行时通过 dump 的方式来获得脱壳后的文件，因此在这里可以将 Plugins 和 Watch 目录删除，这样处理后，应用就从多 target 就转换为单 target 了。 以微信 6.5.7 版本为例，准备好 AdHoc 类型的描述文件之后，进行如下操作: 删除应用中的 _CodeSignature 目录 用脱壳后的二进制文件替换掉原应用的二进制文件 copy 描述文件到应用目录中 修改 info.plist 中的包名替换为重签名的描述文件对应的包名 对整个应用的二进制进行签名（ codesign ...） 拖拽到 iTunes 生成 .ipa 文件 安装 .ipa 结果成功。 注入 dylib 用 Xcode 中的 OpenDev 模板(需要单独下载)，生成要注入到微信中的 dylib，在生成的工程中添加类似下面的方法。 123456789@implementation Dylib__attribute__((constructor))static void entry() { NSLog(@\"hello, world!\");}@end ⌘ B 编译生成动态库,用 yololib 将动态库注入到微信的二进制。同时将该动态库拷贝到微信应用的目录中 1./yololib 目标可执行文件 需注入的dylib 同样进行重签名操作，拖到 iTunes 中生成 .ipa 文件。用 mobiledevice 工具进行安装操作。 1$ mobiledevice install_app /path/to/.ipa ❎ 安装失败 错误一: dylib 未重签名 查看设备日志,发现如下输出,可以看出是动态库没有进行签名操作 12&lt;Notice&gt;: SystemUI unknown identifier: 'com.coder.demo'Apr 17 10:53:17 xiaoguai amfid[12845] &lt;Notice&gt;: /private/var/containers/Bundle/Application/89E48C85-CC8E-4A9E-B6C0-9E1329DDF2AD/WeChat.app/Dylib.dylib not valid: 0xe800801c: No code signature found. 解决方法1# codesign --force --sign xxxxxx -a arm64 Dylib.dylib 因为我脱壳的是 arm64 的二进制,所以可以通过 -a 指定对动态库的具体架构进行签名操作。 错误二: dylib 路径错误 因为 yololib 注入后动态库的执行路径由 @executable_path 指明，所以要确认在执行时能找到对应的动态库二进制。下面就是一个错误的路径 如果动态库执行路径错误时，可以安装，但是运行就会闪退 解决方法 cd 到 WeChat.app 目录下,确保 yololib 注入后，动态库的执行路径为 @executable_path /Dylib.dylib 结果 查看设备日志，可以看到动态库已成功注入 总结 要注意的是，由于中国的开发者利用免费的证书大量对应用进行重签名，所以目前苹果加上了许多限制，免费开发者的provisioning证书有效时间从之前的30天改为7天，过期后需要重新签名。另外就是一个星期内最多只能申请到10个证书。 本文通过 Xcode 的一次多 target 的工程签名流程入手，了解多 target 的签名顺序。因为重签名需要进行脱壳的操作，因此对多 target 的应用，在不影响的情况下，可删除其他 target 文件，将其转换为单 target*。注入的 *dylib 需要独立签名，同时使用 yololib 时需要注意执行路径的问题。 最后把整体流程再整理下: 删除应用中的 _CodeSignature 目录 用脱壳后的二进制文件替换掉原应用的二进制文件 copy 描述文件到应用目录中 修改 info.plist 中的包名替换为重签名的描述文件对应的包名 使用 Xcode 的 OpenDev 模板生成 dylib 文件 对动态库进行签名 使用 yololib 将动态库注入到二进制文件中 对整个应用的二进制进行签名（ codesign ...） 拖拽到 iTunes 生成 .ipa 文件 使用 mobiledevice 安装 ipa 文件 参考 一步一步实现iOS微信自动抢红包(非越狱) linux连接iOS设备并且安装ipa应用 libimobiledevice iOSAppHook","link":"/2017/04/17/iOSer-Practice-articles-iOS-application-re-signature-next/"},{"title":"实践篇：iOS 应用重签名(上)","text":"环境 &amp; 工具 macOS Sierra 10.12.4Xcode 8.3.1Jailbreak iPad 8.4No Jailbreak iPhone 10.1.1 影响因素 _CodeSignature 二进制文件 embedded.mobileprovision entitlements 手动Developer 环境 AppStore 上下载的应用是加壳的，是不能直接用于重签名的。为什么呢? 现在的我不清楚，如果我去实现的话，可以在 codesign 在签名时可以判断代码段是否已经加密了，如果加密过证明已经处理了，就不去签名。二进制的签名依然是苹果服务器上的私钥的签名，在安装过程中，去验证二进制的签名时，无法匹配，因此安装失败。 重签名需要已经脱壳的应用，可以手动/商店下载一个已经脱壳的应用。 以酷狗音乐为例 解压 .iPa cd 到 kugou.app 中 删除应用中的 _CodeSignature 目录 从自己的其他应用的 .app 文件中，拷贝一份 embedded.mobileprovision 到 kugou.app 目录下 用脱壳后的二进制文件替换掉原来的。 找到重签名的 sign 值(钥匙串)与 entitlement 文件 用 codesign 完成签名操作 entitlement 文件的示例如下: 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;application-identifier&lt;/key&gt; &lt;string&gt;XXXX.包名&lt;/string&gt; &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt; &lt;string&gt;XXXX&lt;/string&gt; &lt;key&gt;get-task-allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;keychain-access-groups&lt;/key&gt; &lt;array&gt; &lt;string&gt;XXXX.包名&lt;/string&gt; &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt; 123➜ blog-52 /usr/bin/codesign --force --sign 签名值 --entitlements Runtrace.app.xcent --timestamp=none kugou.appkugou.app: replacing existing signature➜ blog-52 签名完 .app 需要打包成 .ipa 文件,可以将 .app 拖入到 .iTunes 来生成 .ipa 。 在越狱设备上报 在非越狱设备上报 修改 info.plist 的包名，重新制作 .ipa ，再次尝试 在越狱与非越狱设备上都能正常安装，打开不闪退，表明已经过了 Apple 的签名检查了。 AdHoc 环境 操作与 Developer 环境类似，但 embedded.mobileprovision 需要换成 AdHoc 的描述文件，同时 entitlement 文件需要处理，再 Xcode 直接 Archive 工程，照着日志中的路径查找，得到的 entitlement 还是开发环境的，在当前环境下是无效的。 下面是一个 entitlement 的示例 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;application-identifier&lt;/key&gt; &lt;string&gt;XXXX.包名&lt;/string&gt; &lt;key&gt;aps-environment&lt;/key&gt; &lt;string&gt;production&lt;/string&gt; &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt; &lt;string&gt;XXXX&lt;/string&gt; &lt;key&gt;get-task-allow&lt;/key&gt; &lt;false/&gt; &lt;key&gt;keychain-access-groups&lt;/key&gt; &lt;array&gt; &lt;string&gt;XXXX.包名&lt;/string&gt; &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt; 与上面不同之处在于 get-task-allow 为 false ,同时增加了 aps-environment 这个节点。如何找到的？主要还是通过对比工具比较出用 ios-app-signer 工具签名与 codesign 签名后，两个 .app 包的 4 个影响因素的差异，最后发现两者的决定性差异在二进制文件中。 小插曲 在越狱设备上，用开发的 sign 签名也能成功安装，但在非越狱上无法安装，目标主要还是在非越狱设备上，越狱应该是会影响应用签名认证的这个过程。 工具 关于重签名的工具还是挺多的，就说我使用过的。在非越狱设备上要过签名的认证，本质上来说应该都是依赖于 codesign 这个原生的工具的。 ios-app-signerSwift 开发，主界面如下 选签名证书 + 描述文件就可以了，操作也非常简单 1234567891011121314151617181920212223242526272829//MARK: Codesigning func codeSign(file: String, certificate: String, entitlements: String?,before:((file: String, certificate: String, entitlements: String?)-&gt;Void)?, after: ((file: String, certificate: String, entitlements: String?, codesignTask: AppSignerTaskOutput)-&gt;Void)?)-&gt;AppSignerTaskOutput{ let useEntitlements: Bool = ({ if entitlements == nil { return false } else { if fileManager.fileExistsAtPath(entitlements!) { return true } else { return false } } })() if let beforeFunc = before { beforeFunc(file: file, certificate: certificate, entitlements: entitlements) } var arguments = [\"-vvv\",\"-fs\",certificate,\"--no-strict\"] if useEntitlements { arguments.append(\"--entitlements=\\(entitlements!)\") } arguments.append(file) let codesignTask = NSTask().execute(codesignPath, workingDirectory: nil, arguments: arguments) if let afterFunc = after { afterFunc(file: file, certificate: certificate, entitlements: entitlements, codesignTask: codesignTask) } return codesignTask} 其中 codesignPath 就是 let codesignPath = “/usr/bin/codesign” 。大致也是利用 codesign 进行签名。 fastlane sigh resign 来自 帖子 fastlane 是一个很棒的工具集，能辅助去解决 iOS，Mac 和 Android 一些繁琐的任务，比如生成截图处理配置文件以及发布应用程序等。 命令行的操作也非常简单，只是一般在重签名时要传一个 .ipa 地址，这需要处理一下，不像直接用 codesign 或者 ios-app-signer 可以传 .app 文件，中间可能需要用 iTunes 处理下。 操作流程是: .ipa 地址 选择 sign 12345678910[WARNING] You are calling sigh directly. Usage of the tool name without the `fastlane` prefix is deprecated in fastlane 2.0Please update your scripts to use `fastlane sigh resign` instead.Path to ipa file: /Users/Jason/Music/iTunes/iTunes\\ Media/Mobile\\ Applications/kugou.ipa[00:05:56]: Available identities: iPhone Developer: xxxx xxxxx (576J77ZA38) DE64343206CB84E95C5CF22F1C5D346664171B5A iPhone Developer: xxx@126.com (VRZB43ZE67)...Signing Identity: 里面在对动态库签名时，有如下的代码 12345678910111213for framework in \"$FRAMEWORKS_DIR\"/*do if [[ \"$framework\" == *.framework || \"$framework\" == *.dylib ]] then log \"Resigning '$framework'\" # Must not qote KEYCHAIN_FLAG because it needs to be unwrapped and passed to codesign with spaces # shellcheck disable=SC2086 /usr/bin/codesign ${VERBOSE} ${KEYCHAIN_FLAG} -f -s \"$CERTIFICATE\" \"$framework\" checkStatus else log \"Ignoring non-framework: $framework\" fidone 总结 本文主要以 codesign 指令的方式实现了重签名中比较简单的一种情况，同时介绍了几个比较有效的重签名的工具。 参考 ios打包ipa的四种实用方法(.app转.ipa) iOS证书及ipa包重签名探究 最简单的重签名应用的方法 iOS: Already installed app is not launching and crashing everytime in launching","link":"/2017/04/10/iOSer-Practice-articles-iOS-application-re-signature/"},{"title":"快速生成iOS应用的图标","text":"目标 shell脚本自动生成应用的图标 前提 .png格式的图片进行缩小操作不会失真 应用的图标尺寸是可预先确定 流程 Q: 如何调整图标尺寸? 找指令寻找合适的指令,最好是系统自带的,搜索得知指令 sips 可用于调整图片的尺寸 12345678$ man sipsNAME sips -- scriptable image processing system.DESCRIPTION This tool is used to query or modify raster image files and ColorSync ICC profiles. Its functionality can also be used through the \"Image Events\" AppleScript suite. sips 是一个可脚本化的图片执行系统,通常可用于查询或修改图片文件 1234-z pixelsH pixelsW --resampleHeightWidth pixelsH pixelsW Resample image at specified size. Image apsect ratio may be altered. sips 指令有个-z参数,后面跟调整后的尺寸高与宽 Q:如何确定有哪些尺寸? 应用图标尺寸 generate_app_icon.sh1234567891011121314151617181920212223242526#!/bin/bashscale_config=( \"iTunesArtwork.png\" 512 \"iTunesArtwork@2x.png\" 1024 \"Icon-60@2x.png\" 120 \"Icon-60@3x.png\" 180 \"Icon-76.png\" 76 \"Icon-76@2x.png\" 152 \"Icon-Small-40.png\" 40 \"Icon-Small-40@2x.png\" 80 \"Icon-Small-40@3x.png\" 120 \"Icon-Small.png\" 29 \"Icon-Small@2x.png\" 58 \"Icon-Small@3x.png\" 87 # extra )num=${#scale_config[@]}for (( i = 0; i &lt; num; i++ )); do cache_img=${scale_config[i]} cp logo.png ${cache_img} i=$((${i}+1)) sips -Z ${scale_config[i]}x${scale_config[i]} ${cache_img}done 代码 参考 shell 整型变量自增（加1）的几种方法 shell 数组长度 应用图标尺寸","link":"/2016/12/08/iOSer-Quickly-generate-icons-for-iOS-apps/"},{"title":"iOS上实现 3D Touch 功能","text":"前言在 WWDC 2016 - Session 228 - iOS 中提到了 3D Touch,对它简单定义是 3D Touch 为 iOS 用户界面添加了一个全新的维度，并引入了一种全新的与 iPhone 交互的方式。 设备限制: iPhone 6s+ 系统限制: iOS 9+ 环境 macOS Sierra 10.12.3Xcode 8.2.1iPhone 6s 10.1.1 应用场景在 3d Touch APIs 文档中,提到了 The Home screen quick action API is for adding shortcuts to your app icon that anticipate and accelerate a user’s interaction with your app.The UIKit peek and pop API lets you provide easy access, within your app, to additional content while maintaining the user’s context. Use the peek quick actions API to provide a press-enabled replacement to your app’s touch-and-hold actions.The Web view peek and pop API lets you enable system-mediated previews of HTML link destinations.The UITouch force properties let you add customized force-based user interaction to your app. 3d Touch 大概有 3 个应用场景,主屏快速启动,而 UIKit peek and pop 和 Web view peek and pop 可以合并为一个预览的功能， 可以根据 force properties 按压属性值做其它交互上的操作。 主屏快速启动(Home Screen Quick Actions)关于这个功能,很多应用都是有的，长按并保持几秒就可以触发，算是一个应用功能的快速入口，当你觉得应用的某些功能很重要时，让用户能快速定位到这个功能，就可以添加到这儿。 关于数量上的限制，我查了一下资料，在 Class - UIApplication​Shortcut​Item 中有如下内容 The system limits the number quick actions displayed when a user presses a Home screen app icon. Within the limited set of displayed quick action titles, your* static quick actions are shown first, starting at the topmost position in the list. If your static items do not consume the permissible number for display and you have also defined dynamic quick actions using this class, then one or more of your dynamic quick actions is displayed. 结论: 系统会限制 Quick Actions 的显示数量， 在 iOS 9 上最多显示 4 个，有些应用确实可以显示5个。 Quick Actions 截图 预览与弹出窗口(Peek and Pop)Peek and Pop 让 Google 直接翻译意思是偷看和流行，很明显不是苹果想表达的意思。Peek 英文解释为 look quickly or furtively 快速偷偷的瞥一眼，大约就是预览的意思，doc 上有的这一句 Optional navigation to the view shown in the preview—known as a pop 大概明白是什么意思了。就像微信中这个这个样子 上面这个效果在未联网状态下不受影响，而 加载的是网络资源,当未联网时,就无法实现预览功能, 属于 Web view peek and pop 按压属性(force properties)iOS9.0 为我们提供了一个新的交互参数:力度。我们可以检测某一交互的力度值，来做相应的交互处理 比如系统的联系人 实现关于主屏快速启动上面引用的一段话提到了 static quick actions 和 dynamic quick actions ，也就是说快速启动的设置方法有静态和动态。 静态 配置 info.plist 文件 摘一段酷狗的 info.plist 的配置方法，应该就一目了然了 1234567891011121314151617181920212223242526272829303132333435&lt;key&gt;UIApplicationShortcutItems&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;UIApplicationShortcutItemTitle&lt;/key&gt; &lt;string&gt;听歌识曲&lt;/string&gt; &lt;key&gt;UIApplicationShortcutItemType&lt;/key&gt; &lt;string&gt;com.kugou.shortcut.recognize&lt;/string&gt; &lt;key&gt;UIApplicationShortcutItemIconFile&lt;/key&gt; &lt;string&gt;3d_touch_recognize.png&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;UIApplicationShortcutItemTitle&lt;/key&gt; &lt;string&gt;继续播放&lt;/string&gt; &lt;key&gt;UIApplicationShortcutItemType&lt;/key&gt; &lt;string&gt;com.kugou.shortcut.playmusic&lt;/string&gt; &lt;key&gt;UIApplicationShortcutItemIconFile&lt;/key&gt; &lt;string&gt;3d_touch_playmusic.png&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;UIApplicationShortcutItemTitle&lt;/key&gt; &lt;string&gt;搜索&lt;/string&gt; &lt;key&gt;UIApplicationShortcutItemType&lt;/key&gt; &lt;string&gt;com.kugou.shortcut.search&lt;/string&gt; &lt;key&gt;UIApplicationShortcutItemIconFile&lt;/key&gt; &lt;string&gt;3d_touch_search.png&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;UIApplicationShortcutItemTitle&lt;/key&gt; &lt;string&gt;播放本地音乐&lt;/string&gt; &lt;key&gt;UIApplicationShortcutItemType&lt;/key&gt; &lt;string&gt;com.kugou.shortcut.local&lt;/string&gt; &lt;key&gt;UIApplicationShortcutItemIconFile&lt;/key&gt; &lt;string&gt;3d_touch_localmusic.png&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; UIApplicationShortcutItems 数组类型 快捷启动的 key UIApplicationShortcutItemTitle 标题(必填) [可监听该项判断用户是从哪一个标签进入App] UIApplicationShortcutItemType 类型(必填 [可监听该项判断用户是从哪一个标签进入App] UIApplicationShortcutItemIconFile 图标(默认是一个黑色的圆点) 动态每一项快速启动对应一个 UIApplicationShortcutItem 对象 1234567891011121314151617181920NS_CLASS_AVAILABLE_IOS(9_0) __TVOS_PROHIBITED@interface UIApplicationShortcutItem : NSObject &lt;NSCopying, NSMutableCopying&gt;- (instancetype)init NS_UNAVAILABLE;- (instancetype)initWithType:(NSString *)type localizedTitle:(NSString *)localizedTitle localizedSubtitle:(nullable NSString *)localizedSubtitle icon:(nullable UIApplicationShortcutIcon *)icon userInfo:(nullable NSDictionary *)userInfo NS_DESIGNATED_INITIALIZER;- (instancetype)initWithType:(NSString *)type localizedTitle:(NSString *)localizedTitle;// An application-specific string that identifies the type of action to perform.@property (nonatomic, copy, readonly) NSString *type;// Properties controlling how the item should be displayed on the home screen.@property (nonatomic, copy, readonly) NSString *localizedTitle;@property (nullable, nonatomic, copy, readonly) NSString *localizedSubtitle;@property (nullable, nonatomic, copy, readonly) UIApplicationShortcutIcon *icon;// Application-specific information needed to perform the action.// Will throw an exception if the NSDictionary is not plist-encodable.@property (nullable, nonatomic, copy, readonly) NSDictionary&lt;NSString *, id &lt;NSSecureCoding&gt;&gt; *userInfo;@end 快速启动项的图标对应的是 UIApplicationShortcutIcon 类 123456789101112NS_CLASS_AVAILABLE_IOS(9_0) __TVOS_PROHIBITED@interface UIApplicationShortcutIcon : NSObject &lt;NSCopying&gt;// Create an icon using a system-defined image.+ (instancetype)iconWithType:(UIApplicationShortcutIconType)type;// Create an icon from a custom image.// The provided image named will be loaded from the app's bundle// and will be masked to conform to the system-defined icon style.+ (instancetype)iconWithTemplateImageName:(NSString *)templateImageName;@end 创建 UIApplicationShortcutItem 对象后，可以通过 UIApplication 的 shortcutItems 属性进行关联。 1234@interface UIApplication (UIShortcutItems)// Register shortcuts to display on the home screen, or retrieve currently registered shortcuts.@property (nullable, nonatomic, copy) NSArray&lt;UIApplicationShortcutItem *&gt; *shortcutItems NS_AVAILABLE_IOS(9_0) __TVOS_PROHIBITED;@end 比如用如下代码动态创建酷狗的第 5 个 分享”酷狗”音乐 1234567891011121314151617- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { ... /** * 通过代码实现动态菜单 * 一般情况下设置主标题、图标、type等，副标题是不设置的 - 简约原则 * iconWithTemplateImageName 自定义的icon * iconWithType 系统的icon */ UIApplicationShortcutIcon *share = [UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeFavorite]; UIApplicationShortcutItem *itemShare = [[UIApplicationShortcutItem alloc] initWithType:@\"share\" localizedTitle:@\"分享 “酷狗”音乐\" localizedSubtitle:nil icon:share userInfo:nil]; [UIApplication sharedApplication].shortcutItems = @[itemShare]; ...} 但是最后发现还是只有 4 个,看来快速启动的数量确实是有限制。 问题: 如何区分点击具体要跳转到哪个功能界面? 必定存在信息的传递 123// Called when the user activates your application by selecting a shortcut on the home screen,// except when -application:willFinishLaunchingWithOptions: or -application:didFinishLaunchingWithOptions returns NO.- (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void(^)(BOOL succeeded))completionHandler NS_AVAILABLE_IOS(9_0) __TVOS_PROHIBITED; 当用户通过快速启动的方式激活应用时，会触发 UIApplicationDelegate 的这个方法 实现该方法,并设置断点，通过快速启动激活应用，输出 shortcutItem 参数 1&lt;UIApplicationShortcutItem: 0x17026f380; type: com.kugou.shortcut.local, title: 播放本地音乐&gt; 我们可以知道至少可以通过 type 和 title 去区分不同的快速启动按钮。 关于预览与弹出窗口经过授权的应用视图控制器可响应用户不同的按压力量，随着按压力量的增加，会有三个交互阶段： 暗示预览功能可用，会有一个虚化的效果Peek：重按一下后出现的预览，展示预览的视图以及快捷菜单Pop：跳转到预览的视图控制器，是在Peek后进一步按压后进入预览的视图控制器 流程 主视图控制器 用于显示 Peek 弹窗的视图控制器 Peek 视图控制器，用于提供预览的弹窗视图 主视图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#import \"ViewController.h\"#import \"PreviewViewController.h\"@interface ViewController () &lt;UIViewControllerPreviewingDelegate,UITableViewDataSource,UITableViewDelegate&gt; @property (nonatomic,strong) UITableView *tableView;@property (nonatomic,strong) NSArray *datas; @end@implementation ViewController- (void)viewDidLoad { [super viewDidLoad]; _tableView = [[UITableView alloc] initWithFrame:self.view.bounds style:UITableViewStylePlain]; _tableView.dataSource = self; _tableView.delegate = self; [self.view addSubview:_tableView];}- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { return 10;}- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"peekpop\"]; if (cell == nil) { cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@\"peekpop\"]; } cell.textLabel.text = self.datas[indexPath.row]; /** * UIForceTouchCapability 检测是否支持3D Touch * 支持3D Touch */ if (self.traitCollection.forceTouchCapability == UIForceTouchCapabilityAvailable) { // 系统所有cell可实现预览（peek） [self registerForPreviewingWithDelegate:self sourceView:cell]; // 注册cell } return cell;} - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{ [tableView deselectRowAtIndexPath:indexPath animated:YES]; PreviewViewController *webVC = [[PreviewViewController alloc] init]; webVC.webUrl = self.datas[indexPath.row]; webVC.hidesBottomBarWhenPushed = true; [self.navigationController pushViewController:webVC animated:true];} #pragma mark - UIViewControllerPreviewingDelegate- (nullable UIViewController *)previewingContext:(id &lt;UIViewControllerPreviewing&gt;)previewingContext viewControllerForLocation:(CGPoint)location{ // 转化坐标 location = [self.tableView convertPoint:location fromView:[previewingContext sourceView]]; // 根据locaton获取位置 NSIndexPath *indexPath = [self.tableView indexPathForRowAtPoint:location]; PreviewViewController *webVC = [[PreviewViewController alloc] init]; webVC.webUrl = self.datas[indexPath.row]; return webVC;} - (void)previewingContext:(id &lt;UIViewControllerPreviewing&gt;)previewingContext commitViewController:(UIViewController *)viewControllerToCommit{ viewControllerToCommit.hidesBottomBarWhenPushed = YES; [self.navigationController pushViewController:viewControllerToCommit animated:YES];}# pragma mark - 懒加载- (NSArray *)datas { if (_datas == nil) { NSMutableArray *dataM = [NSMutableArray arrayWithCapacity:30]; for (int i = 0; i &lt; 10; ++i) { [dataM addObject:@\"https://www.baidu.com\"]; } _datas = [dataM copy]; } return _datas;}@end Peek 视图控制器 123456789101112131415161718192021222324252627282930313233343536#import \"PreviewViewController.h\"@interface PreviewViewController ()@property (nonatomic,strong) UIWebView *webView;@end@implementation PreviewViewController- (void)viewDidLoad { [super viewDidLoad]; _webView = [[UIWebView alloc] initWithFrame:self.view.bounds]; [_webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:_webUrl]]]; [self.view addSubview:_webView];} - (NSArray&lt;id&lt;UIPreviewActionItem&gt;&gt; *)previewActionItems{ // 赞 UIPreviewAction *admire = [UIPreviewAction actionWithTitle:@\"赞\" style:UIPreviewActionStyleDefault handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) { NSLog(@\"点赞成功\"); }]; // 举报 UIPreviewAction *report = [UIPreviewAction actionWithTitle:@\"举报\" style:UIPreviewActionStyleDestructive handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) { NSLog(@\"举报成功\"); }]; // 收藏 UIPreviewAction *collect = [UIPreviewAction actionWithTitle:@\"收藏\" style:UIPreviewActionStyleSelected handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) { NSLog(@\"收藏成功\"); }]; return @[admire,report,collect];}@end 对以上的代码进行简答说明： 主视图遵守 UIViewControllerPreviewingDelegate 注册触发 Peek 的视图对象 设置 Peek 视图控制器的操作 (可选) 该协议有两个方法 1234567NS_CLASS_AVAILABLE_IOS(9_0) @protocol UIViewControllerPreviewingDelegate &lt;NSObject&gt;// If you return nil, a preview presentation will not be performed- (nullable UIViewController *)previewingContext:(id &lt;UIViewControllerPreviewing&gt;)previewingContext viewControllerForLocation:(CGPoint)location NS_AVAILABLE_IOS(9_0);- (void)previewingContext:(id &lt;UIViewControllerPreviewing&gt;)previewingContext commitViewController:(UIViewController *)viewControllerToCommit NS_AVAILABLE_IOS(9_0);@end 根据API-UIView​Controller​Previewing​Delegate,中可知 previewing​Context:​view​Controller​For​Location:​Called when the user has pressed a source view in a previewing view controller, thereby obtaining a surrounding blur to indicate that a preview (peek) is available. previewing​Context:​commit​View​Controller:​Called to let you prepare the presentation of a commit (pop) view from your commit view controller. 这两个方法将会分别在用户按压操作注册了 Peek 的视图对象与 Peek 视图即将从主视图 Pop 时触发。 参数说明 previewingContextThe context object for the previewing view controller. 预览视图控制器的上下文对象，负责实现一系列预览的效果，其中的 sourceView 属性指向主视图中触发预览操作的视图对象 locationThe location of the touch in the source view’s coordinate system. location 在 sourceView 视图的坐标系中触摸的位置，比如在下面那张截图中代理方法传递进来的 locaiton 参数的值为 (x = 95, y = 33.5) 这个是相对于点击的 cell 为了确定点击的具体是哪个 cell 需要对进行转换，转换后的结果为 (x = 95, y = 77.5) 将来自于 fromView: 视图的坐标 location 转为相对于 self.tableView 的 location ReturnThe view controller whose view you want to provide as the preview (peek), or nil to disable preview.. Peek 预览的视图控制器 12345678/*** UIForceTouchCapability 检测是否支持3D Touch* 支持3D Touch*/if (self.traitCollection.forceTouchCapability == UIForceTouchCapabilityAvailable) { // 系统所有cell可实现预览（peek） [self registerForPreviewingWithDelegate:self sourceView:cell]; // 注册cell} 注册与取消注册 API 1234567@interface UIViewController (UIViewControllerPreviewingRegistration)// Registers a view controller to participate with 3D Touch preview (peek) and commit (pop).- (id &lt;UIViewControllerPreviewing&gt;)registerForPreviewingWithDelegate:(id&lt;UIViewControllerPreviewingDelegate&gt;)delegate sourceView:(UIView *)sourceView NS_AVAILABLE_IOS(9_0);- (void)unregisterForPreviewingWithContext:(id &lt;UIViewControllerPreviewing&gt;)previewing NS_AVAILABLE_IOS(9_0);@end 在 Peek 视图控制器中添加代码 12345678910- (NSArray&lt;id&lt;UIPreviewActionItem&gt;&gt; *)previewActionItems{ // 赞 UIPreviewAction *admire = [UIPreviewAction actionWithTitle:@\"赞\" style:UIPreviewActionStyleDefault handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) { NSLog(@\"点赞成功\"); }]; ... return @[admire,report,collect];} 因为对预览的视图的操作写在 Peek 视图控制器是很正常 Swift 的实现风格的可以参考文章后的链接 ViewControllerPreviews: Using the UIViewController previewing APIs。 关于按压属性1234// Force of the touch, where 1.0 represents the force of an average touch@property(nonatomic,readonly) CGFloat force NS_AVAILABLE_IOS(9_0);// Maximum possible force with this input mechanism@property(nonatomic,readonly) CGFloat maximumPossibleForce NS_AVAILABLE_IOS(9_0); 按压实现预览本质上也是一种根据按压实现的交互。在此就不在赘述了。 参考 Is there a limit to how many UIApplicationShortcutItems you can have? 3D Touch Quick Action 4 Item Limit? iOS之实现3D Touch API-UIView​Controller​Previewing​Delegate ViewControllerPreviews: Using the UIViewController previewing APIs Understanding convertPoint:toView:","link":"/2017/03/18/iOSer-Realize-3d-Touch-on-iOS/"},{"title":"阅读:iOS App签名的原理","text":"导语 前几天在 Bugly 公众号上看到这篇 iOS App签名的原理，解决了我原来关于 iOS 开发的证书相关知识的一些模糊的地方。 下面按使用的场景进行梳理。 场景一: 指定 AppStore 安装 App 打包上传到 AppStore ，苹果服务器用对应用进行加壳,签名,用私钥对签名加密 iOS 从 AppStore 下载应用，在安装时用公钥进行验证 .ipa 包里有一个 _CodeSignature 的文件夹，其中有个 CodeResources文件,拖拽到 Sublime Text 中，发现其内容包括 4 个节点， 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;files&lt;/key&gt; &lt;dict&gt; ... &lt;/dict&gt; &lt;key&gt;files2&lt;/key&gt; &lt;dict&gt; ... &lt;/dict&gt; &lt;key&gt;rules&lt;/key&gt; &lt;dict&gt; ... &lt;/dict&gt; &lt;key&gt;rules2&lt;/key&gt; &lt;dict&gt; ... &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt; 参考这篇文章,可以得到如下观点 rules 和 files 是为老版本准备的，而 files2 和 rules2是为新的第二版的代码签名准备的。最主要的区别是在新版本中你无法再将某些资源文件排除在代码签名之外。 二进制的签名会被放到可执行文件中 参考数字签名的过程，整个流程应该这样的: 苹果后台对应用中的各项资源进行哈希并签名生成该表，用以标识这个应用，当要安装到 iOS 设备中时，先用公钥解密签名,同样对资源进行哈希然后进行匹配。如果匹配上的话，在当前场景下就可以证明应用没有被修改过，即代表是从 AppStore 上下载的，如果验证不通过，则无法安装。 二进制的签名我找了 Apple 的Code Signing Guide 重新确定了下签名的部分 哪些文件参与的签名 Nested code , 比如 .a 静态库, .frameworks (先签名)Mach-O executables , 二进制可执行文件Resources , 资源文件，就是 CodeResources 的部分 To apply the signature, the codesign utility adds the signature directly to the executable file. 这句话确实证明了关于二进制的签名会直接被加到可执行文件中。 场景二 : 开发环境下安装应用参考数字证书的过程 mac: 服务器苹果服务器: CAiOS 设备: 客户端 服务器向 CA 发送证书请求( .csr ),其中包含了本地生成的公钥，CA 签名后将证书发送回服务器并安装到服务器上，在进行应用安装时，用本地私钥签名并将证书一起安装到客户端。 因为客户端有 CA 的公钥，所以可以解密证书的签名，然后通过计算验证公钥是否已被认证，若被认证，则使用其公钥来解密私钥加密的内容。 证书是附在后面安装提到的 embedded.moilbeprovision 场景三 : AdHoc/企业证书安装应用为了保证权限(通知，IAP…)，安装设备数量统一进行控制，引入了描述文件 (Provisioning Profile) 。 描述文件也用苹果服务器私钥签名，打包时，会把描述文件一起打包到到应用中，文件名为 embedded.mobileprovision 编译自己的任意一个工程,然后找到 Produce 的目录,里面有 .app 目录，进到里面即可发现 embedded.mobileprovision。 可以用如下命令来查看 1security cms -D -i embedded.mobileprovision 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;AppIDName&lt;/key&gt; &lt;string&gt;XC Wildcard&lt;/string&gt; &lt;key&gt;ApplicationIdentifierPrefix&lt;/key&gt; &lt;array&gt; &lt;string&gt;ZEY3XXXXXX&lt;/string&gt; &lt;/array&gt; &lt;key&gt;CreationDate&lt;/key&gt; &lt;date&gt;2017-03-08T06:25:32Z&lt;/date&gt; &lt;key&gt;Platform&lt;/key&gt; &lt;array&gt; &lt;string&gt;iOS&lt;/string&gt; &lt;/array&gt; &lt;key&gt;DeveloperCertificates&lt;/key&gt; &lt;array&gt; &lt;data&gt;MIIF...fA=&lt;/data&gt; &lt;data&gt;MIIF...94=&lt;/data&gt; &lt;/array&gt; &lt;key&gt;Entitlements&lt;/key&gt; &lt;dict&gt; &lt;key&gt;keychain-access-groups&lt;/key&gt; &lt;array&gt; &lt;string&gt;ZEY3XXXXXX.*&lt;/string&gt; &lt;/array&gt; &lt;key&gt;get-task-allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;application-identifier&lt;/key&gt; &lt;string&gt;ZEY3XXXXXX.*&lt;/string&gt; &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt; &lt;string&gt;ZEY3XXXXXX&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;ExpirationDate&lt;/key&gt; &lt;date&gt;2018-03-08T06:25:32Z&lt;/date&gt; &lt;key&gt;Name&lt;/key&gt; &lt;string&gt;iOS Team Provisioning Profile: *&lt;/string&gt; &lt;key&gt;ProvisionedDevices&lt;/key&gt; &lt;array&gt; &lt;string&gt;2b8ffa94ec91d9ce9c94da9ad423b88888888888&lt;/string&gt; &lt;/array&gt; &lt;key&gt;TeamIdentifier&lt;/key&gt; &lt;array&gt; &lt;string&gt;ZEY3XXXXXX&lt;/string&gt; &lt;/array&gt; &lt;key&gt;TeamName&lt;/key&gt; &lt;string&gt;Deliang Wang&lt;/string&gt; &lt;key&gt;TimeToLive&lt;/key&gt; &lt;integer&gt;365&lt;/integer&gt; &lt;key&gt;UUID&lt;/key&gt; &lt;string&gt;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&lt;/string&gt; &lt;key&gt;Version&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt;&lt;/dict&gt; 可看到 embedded.moilbeprovision 中包含了应用的包名，证书，可安装设备，过期时间等等信息。 最后关键点 数字签名的保证了应用的完整性且来自 AppStore 。 描述文件统一管理权限，包名，可安装的设备等信息。 非对称加密，私钥加密，公钥验证 附一张来自原文的图 That’s all 参考 数字签名 数字证书 漫谈iOS程序的证书和签名机制 Apple - Code Signing Guide","link":"/2017/03/28/iOSer-Readers-iOS-App-signature-principle/"},{"title":"小记 - Apple 开发者续费","text":"导语最近，公司的个人开发者账号需要续费，同事发现他的 VISA 信用卡无法支付。提示你的支付授权失败。请核实你的信息后重试，或试试其他付款方式。我在尝试的时候也报了上面的错误，再次尝试就顺利支付了。搜索后发现原来自 2015年6月1日 起，中国大陆发行的 VISA 单标卡若在中国境内他行的 VISA 外卡收单商户交易，VISA 网络将不能受理。 解决方案换一张 VISA + 银联 的双标卡 不过据说很多银行表示已不再发双标卡产品… 单标卡 双标卡 参考 关于境内VISA单标信用卡停止境内跨行受理的通知 购买开发者账号失败，支付的时候总是提示“授权失败…”的提示 央妈放大招：“双标”信用卡将正式退市","link":"/2017/04/27/iOSer-Small-note-Apple-developer-renewal/"},{"title":"Swift 3上的String和Character","text":"概览 字符串如何遍历?字符串如何操作(增删改)?字符串如何比较? 本文主要关注的就是字符串的上面3点操作 环境说明 macOS Sierra 10.12.2Xcode Version 8.2.1 如何遍历?OC先看看OC中如何对集合进行遍历 123456789101112131415NSArray *ss = @[@1,@2,@3];// forI 提供外部索引,通过索引遍历集合for (int i = 0; i &lt; ss.count; ++i) { NSLog(@\"forI:%@\",ss[i]);}// forin 通过内部迭代集合,不需要索引for (NSNumber *s in ss) { NSLog(@\"forin:%@\",s);}// block方式迭代[ss enumerateObjectsUsingBlock:^(id _Nonnull s, NSUInteger idx, BOOL * _Nonnull stop) { NSLog(@\"enumerate:%@\",s);}]; 遍历OC字符串的方式 12345678910111213141516NSString *s = @\"testString\";// forIfor (int i = 0; i &lt; s.length; ++i) { NSLog(@\"%c\",[s characterAtIndex:i]);}// Collection expression type 'NSString *' may not respond to 'countByEnumeratingWithState:objects:count:'// NSString并没有实现NSFastEnumeration协议// for (NSString *subs in s) { // } [s enumerateSubstringsInRange:NSMakeRange(0, s.length) options:NSStringEnumerationByComposedCharacterSequences usingBlock:^(NSString * _Nullable substring, NSRange substringRange, NSRange enclosingRange, BOOL * _Nonnull stop) { NSLog(@\"%@\",substring);}]; Swift12345678// - 摘自String.h iOS10.2public struct String { /// Creates an empty string. public init() ...} 由上可知:Swift中的字符串是一个结构体 结构体是值类型,作参数传递时是拷贝副本进行传递,保证原字符串不会被改变 查看上面的注释可以了解到String的一些知识点 与NSString类无缝桥接123456/// A Unicode string value.////// A string is a series of characters, such as `\"Swift\"`. Strings in Swift are/// Unicode correct, locale insensitive, and designed to be efficient. The/// `String` type bridges with the Objective-C class `NSString` and offers/// interoperability with C functions that works with strings. 用字面量初始化12345/// You can create new strings using string literals or string interpolations./// A string literal is a series of characters enclosed in quotes.////// let greeting = \"Welcome!\"/// 123456789101112131415161718/// Character View/// --------------////// A string's `characters` property is a collection of *extended grapheme/// clusters*, which approximate human-readable characters. Many individual/// characters, such as \"é\", \"김\", and \"🇮🇳\", can be made up of multiple Unicode/// code points. These code points are combined by Unicode's boundary/// algorithms into extended grapheme clusters, represented by Swift's/// `Character` type. Each element of the `characters` view is represented by/// a `Character` instance.////// print(cafe.characters.count)/// // Prints \"9\"/// print(Array(cafe.characters))/// // Prints \"[\"C\", \"a\", \"f\", \"é\", \" \", \"d\", \"u\", \" \", \"🌍\"]\"////// Each visible character in the `cafe` string is a separate element of the/// `characters` view. 查看String的characters属性 1234567public struct CharacterView { /// Creates a view of the given string. public init(_ text: String)}/// A view of the string's contents as a collection of characters.public var characters: String.CharacterView String的characters是一个字符集合可以根据characters对String进行遍历操作 String.CharacterView123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/// `String.CharacterView` is a collection of `Character`.extension String.CharacterView : BidirectionalCollection { /// A position in a string's `CharacterView` instance. /// /// You can convert between indices of the different string views by using /// conversion initializers and the `samePosition(in:)` method overloads. /// The following example finds the index of the first space in the string's /// character view and then converts that to the same position in the UTF-8 /// view: /// /// let hearts = \"Hearts &lt;3 ♥︎ 💘\" /// if let i = hearts.characters.index(of: \" \") { /// let j = i.samePosition(in: hearts.utf8) /// print(Array(hearts.utf8.prefix(upTo: j))) /// } /// // Prints \"[72, 101, 97, 114, 116, 115]\" public struct Index : Comparable, CustomPlaygroundQuickLookable { /// A custom playground Quick Look for this instance. /// /// If this type has value semantics, the `PlaygroundQuickLook` instance /// should be unaffected by subsequent mutations. public var customPlaygroundQuickLook: PlaygroundQuickLook { get } } /// A type used to represent the number of steps between two indices, where /// one value is reachable from the other. /// /// In Swift, *reachability* refers to the ability to produce one value from /// the other through zero or more applications of `index(after:)`. public typealias IndexDistance = Int /// The position of the first character in a nonempty character view. /// /// In an empty character view, `startIndex` is equal to `endIndex`. public var startIndex: String.CharacterView.Index { get } /// A character view's \"past the end\" position---that is, the position one /// greater than the last valid subscript argument. /// /// In an empty character view, `endIndex` is equal to `startIndex`. public var endIndex: String.CharacterView.Index { get } /// Returns the next consecutive position after `i`. /// /// - Precondition: The next position is valid. public func index(after i: String.CharacterView.Index) -&gt; String.CharacterView.Index /// Returns the previous consecutive position before `i`. /// /// - Precondition: The previous position is valid. public func index(before i: String.CharacterView.Index) -&gt; String.CharacterView.Index /// Accesses the character at the given position. /// /// The following example searches a string's character view for a capital /// letter and then prints the character at the found index: /// /// let greeting = \"Hello, friend!\" /// if let i = greeting.characters.index(where: { \"A\"...\"Z\" ~= $0 }) { /// print(\"First capital letter: \\(greeting.characters[i])\") /// } /// // Prints \"First capital letter: H\" /// /// - Parameter position: A valid index of the character view. `position` /// must be less than the view's end index. public subscript(i: String.CharacterView.Index) -&gt; Character { get }} 由上面可以得知,forI方式的索引的数据类型由原来的int改成了String.CharacterView.Index 1let s = \"Swift\" forI方式 123for i in 0..&lt;s.characters.count { print(s.characters[s.characters.index(s.startIndex, offsetBy: i)])} for-in方式 123for c in s.characters { print(c)} block方式 123s.characters.forEach { (c) in print(c)} 如何操作(增删改)?增 可以用\\(String)组合字符串 12345678910111213/// String interpolations are string literals that evaluate any included/// expressions and convert the results to string form. String interpolations/// are an easy way to build a string from multiple pieces. Wrap each/// expression in a string interpolation in parentheses, prefixed by a/// backslash.////// let name = \"Rosa\"/// let personalizedGreeting = \"Welcome, \\(name)!\"////// let price = 2/// let number = 3/// let cookiePrice = \"\\(number) cookies: $\\(price * number).\"/// 可以用*”+”*连接字符串 123456/// Combine strings using the concatenation operator (`+`).////// let longerGreeting = greeting + \" We're glad you're here!\"/// print(longerGreeting)/// // Prints \"Welcome! We're glad you're here!\"/// append… 删 removeAll( ) remove(at:…) … 改12345// 直接赋值s = \"swift\"// 替换s.replaceSubrange(s.index(s.startIndex,offsetBy:1)...s.index(s.startIndex, offsetBy: 4), with: \"WIFT\") 如何比较?12345678910111213/// Comparing strings for equality using the equal-to operator (`==`) or a/// relational operator (like `&lt;` and `&gt;=`) is always performed using the/// Unicode canonical representation. This means that different/// representations of a string compare as being equal.////// let cafe1 = \"Cafe\\u{301}\"/// let cafe2 = \"Café\"/// print(cafe1 == cafe2)/// // Prints \"true\"////// The Unicode code point `\"\\u{301}\"` modifies the preceding character to/// include an accent, so `\"e\\u{301}\"` has the same canonical representation/// as the single Unicode code point `\"é\"`. 123456789101112extension String : Equatable { /// Returns a Boolean value indicating whether two values are equal. /// /// Equality is the inverse of inequality. For any values `a` and `b`, /// `a == b` implies that `a != b` is `false`. /// /// - Parameters: /// - lhs: A value to compare. /// - rhs: Another value to compare. public static func ==(lhs: String, rhs: String) -&gt; Bool} Unicode编码 使用==进行比较 内容比较 参考 字符串和字符（Strings and Characters）","link":"/2017/01/30/iOSer-String-and-Character-on-Swift-3/"},{"title":"UIView的init与initWithFrame:的调用关系","text":"前言 凑巧得知了以下现象: 调用UIView子类的init方法会先去调用initWithFrame: 调用UIView子类的initWithFrame:不会调用init方法 一开始会很自然的认为initWithFrame:多一个参数的方法内部会调用init这个初始化方法,会对上面的现象感到奇怪。但是在用Xcode查看了init和initWithFrame:方法的说明后就了然了。 流程 先从frame这个UIView的属性入手,当用 1UIView *v = [[UIView alloc] init]; 用lldb调试打印出frame 从得到的结果可知:就算只调用init方法,UIView对象的frame也是有值的? 类似Java类中的基本数据结构,都有默认值 直接设置frame属性,当前情况下,至少我没有写,虽然最终肯定是要进行设置的 调用了initWithFrame:方法,传递的参数为CGRectZero 因为没有UIView的init方法的具体代码,所以只能算是*揣测*,根据实际的情况,再加上既然已经有了initWithFrame:方法设置frame,应该没必要搞那么麻烦,就第3种情况吧。 调用UIView子类的init方法会先去调用initWithFrame:,这个算是可以成立的 若init调用initWithFrame:(?),initWithFrame:自然就不会再调用init方法了。 实现尝试去编写符合上面假设的代码 查看NSObject中的init方法的说明 至少可以得知两点 init是让子类实现初始化一个新对象的方法NSObject类的init没有初始化操作,只是简单的返回了一个self指针 继承关系为:CustomView -&gt; UIView -&gt; UIResponder -&gt; NSObject NSObject类 1234567- (instancetype)init { self = [super init]; if (self) { // Initialize self } return self;} UIView类 123456789101112131415161718- (instancetype)init { self = [super init]; if (self) { ... [self initWithFrame:CGRectZero]; ... } return self;}- (instancetype)initWithFrame:(CGRect)frame { self = [super init]; if (self) { ... self.frame = frame; ... }} … CustomUIView类 1234567891011121314- (instancetype)init { self = [super init]; if (self) { ... } return self;}- (instancetype)initWithFrame:(CGRect)frame { self = [super initWithFrame:frame]; if (self) { ... }} CustomView对象调用init方法 调用UIView的init方法 调用NSObject的init方法,返回self指针 self是CustomView对象,所以执行CustomView对象的initWithFrame:方法 CustomView对象调用initWithFrame:对象 调用UIView的init方法 调用NSObject的init方法,返回self指针 根据传递参数设置frame属性值 参考 一个类继承UIView,调用init方法,为什么这个init方法会去调用我重写的initWithFrame方法?","link":"/2017/03/01/iOSer-UIView-init-and-initWithFrame-call-relationship/"},{"title":"理解objc运行时一:类是什么","text":"环境说明 macOS Sierra 10.12.1Xcode 8.1 获得可运行的objc源码一个可以编译并运行的objc源码才能更好的理解运行时 objc-706 类OC中的大部分类是继承自NSObject这个类的因此从NSObject这个类入手 NSObject.h 123@interface NSObject &lt;NSObject&gt; { Class isa OBJC_ISA_AVAILABILITY;} 可知NSObject对象包含一个Class类型的isa指针 Class 有3个文件与Class有关 打开一个其他的一个正常的Xcode工程,同样点击Class 进入到 objc.h 再进入到runtime.h,Class的定义 1234567891011121314151617181920212223242526272829303132333435/* Types */#if !OBJC_TYPES_DEFINED/// An opaque type that represents a method in a class definition.typedef struct objc_method *Method;/// An opaque type that represents an instance variable.typedef struct objc_ivar *Ivar;/// An opaque type that represents a category.typedef struct objc_category *Category;/// An opaque type that represents an Objective-C declared property.typedef struct objc_property *objc_property_t;struct objc_class { Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif} OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */#endif 注意有个#if !OBJC_TYPES_DEFINED宏定义,正常Xcode工程找不到定义,但在objc-706工程中搜索可得,它在objc-private.h*中,#define OBJC_TYPES_DEFINED 1所以上面的代码其实是不会参与编译的,真正的定义在在*objc-private.h,再进入到objc-runtime-old.h,但是还有一个objc-runtime-new.h,根据命名与调试结果,真正的定义是objc-runtime-new.h 123456struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags ... 1typedef struct objc_class *Class;* Class是一个指向objc_class结构体的指针 参考 南峰子 - Objective-C Runtime 运行时之一：类与对象","link":"/2016/11/22/iOSer-Understand-objc-runtime-1-what-is-the-class/"},{"title":"理解iOS事件传递与响应机制","text":"导语说说 iOS 中关于事件是如何传递与响应的。 因素 iOS 关键词 时间 点击/长按/摇一摇/音乐暂停/播放时 地点 响应者 UIButton/UIView… 事件派发 &amp; 响应者链条 人物 用户/运行循环 NSRunLoop &amp; UIApplication 事件 UITapGestureRecognizer/UITouchUpInside… UIEvent 如何 执行的具体操作 外部业务实现 环境 &amp; 工具 macOS Sierra 10.12.3Xcode 8.2.1chisel 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#import \"ViewController.h\"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad { [super viewDidLoad]; // 手势 UIView *v = [[UIView alloc] initWithFrame:CGRectMake(0, 100, 100, 100)]; v.backgroundColor = [UIColor redColor]; UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapAction:)]; [v addGestureRecognizer:tap]; [self.view addSubview:v]; // 点击 UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, 200, 100, 30)]; btn.backgroundColor = [UIColor grayColor]; [btn setTitle:@\"测试\" forState:UIControlStateNormal]; [btn addTarget:self action:@selector(btnAction:) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn]; // Timer NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:5.0 target:self selector:@selector(timerAction:) userInfo:nil repeats:true]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; // CADisplay CADisplayLink *link = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkAction:)]; [link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; link.preferredFramesPerSecond = 6;}- (void)btnAction:(UIButton *)btn { NSLog(@\"点击事件\");}- (void)tapAction:(UITapGestureRecognizer *)tap { NSLog(@\"触摸事件\");}- (void)timerAction:(NSTimer *)timer { NSLog(@\"timer事件\");}- (void)displayLinkAction:(CADisplayLink *)link { NSLog(@\"displayLink事件\");}@end 调用堆栈 类型 截图 点击 手势 Timer CADisplayLink 小结各种类型的事件都是由 RunLoop 接收。触屏事件由 UIApplication 通过队列的方式进行派发。 相关的类: UIEvent类 UIEvent 是事件派发中的基本单元 12345678910111213141516171819202122232425NS_CLASS_AVAILABLE_IOS(2_0) @interface UIEvent : NSObject@property(nonatomic,readonly) UIEventType type NS_AVAILABLE_IOS(3_0);@property(nonatomic,readonly) UIEventSubtype subtype NS_AVAILABLE_IOS(3_0);@property(nonatomic,readonly) NSTimeInterval timestamp;#if UIKIT_DEFINE_AS_PROPERTIES@property(nonatomic, readonly, nullable) NSSet &lt;UITouch *&gt; *allTouches;#else- (nullable NSSet &lt;UITouch *&gt; *)allTouches;#endif- (nullable NSSet &lt;UITouch *&gt; *)touchesForWindow:(UIWindow *)window;- (nullable NSSet &lt;UITouch *&gt; *)touchesForView:(UIView *)view;- (nullable NSSet &lt;UITouch *&gt; *)touchesForGestureRecognizer:(UIGestureRecognizer *)gesture NS_AVAILABLE_IOS(3_2);// An array of auxiliary UITouch’s for the touch events that did not get delivered for a given main touch. This also includes an auxiliary version of the main touch itself.- (nullable NSArray &lt;UITouch *&gt; *)coalescedTouchesForTouch:(UITouch *)touch NS_AVAILABLE_IOS(9_0);// An array of auxiliary UITouch’s for touch events that are predicted to occur for a given main touch. These predictions may not exactly match the real behavior of the touch as it moves, so they should be interpreted as an estimate.- (nullable NSArray &lt;UITouch *&gt; *)predictedTouchesForTouch:(UITouch *)touch NS_AVAILABLE_IOS(9_0);@endNS_ASSUME_NONNULL_END 触屏事件事件类型 事件驱动应用程序的主要职责是处理用户事件，即由鼠标，键盘，跟踪器和平板电脑等设备生成的事件。 到 iOS 应用中相应的成了触屏、加速计、远程控制等事件。 12345678910111213141516171819202122232425262728NS_CLASS_AVAILABLE_IOS(2_0) @interface UIResponder : NSObject &lt;UIResponderStandardEditActions&gt;#if UIKIT_DEFINE_AS_PROPERTIES@property(nonatomic, readonly, nullable) UIResponder *nextResponder;#else- (nullable UIResponder*)nextResponder;#endif...// 触屏事件 (Multitouch)- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches NS_AVAILABLE_IOS(9_1);...// 加速器事件 (Motion Events)- (void)motionBegan:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);- (void)motionEnded:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);- (void)motionCancelled:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);// 远程事件 (Remote Control Events)- (void)remoteControlReceivedWithEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(4_0);@end 响应者 应用程序使用响应者对象接收和处理事件。响应者对象是 UIResponder 类的任何实例，常见的子类包括 UIView ，UIViewController 和 UIApplication 。 UIKit 自动管理大多数响应者相关的行为，包括事件如何从一个响应者传递到下一个。但是，您可以修改默认行为来更改事件在应用程序中的传送方式。 响应者链条 在当前场景下的 btn 的响应者链条如下 1234567(lldb) presponder btn&lt;UIButton: 0x115e0fea0; frame = (0 200; 100 30); opaque = NO; layer = &lt;CALayer: 0x1702214a0&gt;&gt; | &lt;UIView: 0x115d07820; frame = (0 0; 375 667); autoresize = W+H; layer = &lt;CALayer: 0x17403df00&gt;&gt; | | &lt;ViewController: 0x115e0d720&gt; | | | &lt;UIWindow: 0x115e0de20; frame = (0 0; 375 667); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x170245d90&gt;; layer = &lt;UIWindowLayer: 0x170220e00&gt;&gt; | | | | &lt;UIApplication: 0x115e007f0&gt; | | | | | &lt;AppDelegate: 0x17403b6a0&gt; 通过 UIApplication.h 文件中的注释与下面 lldb 调试的结果 actionA selector identifying an action method. See the discussion for information on the permitted selector forms.targetThe object to receive the action message. If target is nil, the app sends the message to the first responder, from whence it progresses up the responder chain until it is handled.senderThe object that is sending the action message. The default sender is the UIControl object that invokes this method.eventA UIEvent object that encapsulates information about the event originating the action message. 比较容易推断出 描述 值 sendAction btnAction: to ViewController from UIButton forEvent UITounesEvent UIView 不能接收触屏事件的三种情况： 不接受用户交互：userInteractionEnabled = NO; 隐藏：hidden = YES; 透明：alpha = 0.0~0.01 事件分发 发生触摸事件后，系统会将该事件加入到一个由 UIApplication 管理的队列事件中(从上面的调用堆栈中可知)。 UIApplication 会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常会先发送事件给应用程序的主窗口(keyWindow) 主窗口 (keyWindow) 对象首先会使用 hitTest:withEvent: 方法寻找此次 Touch 操作初始点所在的视图(View)，即需要将触摸事件传递给最合适的视图，这个过程称之为 hit-test view 应用如何找到最合适的控件来处理事件？有以下准则 首先判断主窗口（keyWindow）自己是否能接受触摸事件 触摸点是否在自己身上 从后往前遍历子控件，重复前面的两个步骤（首先查找数组中最后一个元素） 如果没有符合条件的子控件，那么就认为自己最合适处理注意：之所以会采取从后往前遍历子控件的方式寻找最合适的view只是为了做一些循环优化。因为相比较之下，后添加的view在上面，降低循环次数。 事件分发 &amp;&amp; 响应者链条都是为了找出合适的响应者 小结hit-test view 确定最合适的视图，若该视图如果不能响应该事件时，可通过响应者链条找到合适的响应者。 在当前场景下， UIButton 作为第一响应者能响应当前的点击事件，触发 UIResponser 协议的 touchesEnded:withEvent 代理方法，最后作为 sender 参数传递给 ViewController 的 btnAction: 方法。 手势UIView 中有 12345678@interface UIView (UIViewGestureRecognizers)@property(nullable, nonatomic,copy) NSArray&lt;__kindof UIGestureRecognizer *&gt; *gestureRecognizers NS_AVAILABLE_IOS(3_2);- (void)addGestureRecognizer:(UIGestureRecognizer*)gestureRecognizer NS_AVAILABLE_IOS(3_2);- (void)removeGestureRecognizer:(UIGestureRecognizer*)gestureRecognizer NS_AVAILABLE_IOS(3_2);... The gesture-recognizer objects currently attached to the view. gestureRecognizers 保存着与当前的视图对象相关联的 UIGestureRecognizer 类型对象 为视图添加手势 为视图添加 addTarget:Action:，将 响应者链条 部分稍作处理可得 小结无论是用 addTarget:Action: 还是将手势添加到视图对象上，最终都是创建了 UIEvent 这个事件单元对象。 手势相比触碰事件的好处是可以直接使用已经定义好的手势，开发者不用自己计算手指移动轨迹。缺点就是没办法自定义手势，只能用系统已经实现的手势。如果想实现自己发明的某种手势还得去用触摸。 总结当事件发生时，RunLoop 接收到外部或内部注册的事件，将其传递给 UIApplication 对象，UIApplication 封装成 UIEvent 类型的对象并将其分发给应用程序的主窗口(keyWindow)，主窗口对象使用 hit-test view 的流程找到响应当前事件最合适的视图，若该视图无法响应事件，则通过响应者链条向上传递，直到找到合适的响应者,该响应者需要实现了 touchesBegan:withEvent: 等代理方法，若没找到就将事件抛弃，最终会将响应者传递给外部的调用者。 参考 iOS 点击事件传递及响应 Understanding Responders and the Responder Chain Cocoa Event Handling Guide iOS手势（UIGestureRecognizer）和触摸（touche event）的区别和联系","link":"/2017/04/04/iOSer-Understand-iOS-event-delivery-and-response-mechanisms/"},{"title":"理解objc运行时二:类的结构(runtime.h)","text":"类的数据结构(runtime.h)1234567891011121314151617struct objc_class { Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif} OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ __OBJC2__ If you are running 10.5 or later, or any version of iOS, your computer is running Objective-C 2. If you are writing code which you want to work on systems before this, you can check for the OBJC2 macro, which will be defined only for Objective-C 2 and later systems. 参考 OBJC2_UNAVAILABLE12345678910111213/* OBJC2_UNAVAILABLE: unavailable in objc 2.0, deprecated in Leopard *//*主要是为了兼容以前的OC版本,目前条件下,可忽略 */#if !defined(OBJC2_UNAVAILABLE) # if __OBJC2__# define OBJC2_UNAVAILABLE UNAVAILABLE_ATTRIBUTE# else /* plain C code also falls here, but this is close enough */# define OBJC2_UNAVAILABLE \\ __OSX_DEPRECATED(10.5, 10.5, \"not available in __OBJC2__\") \\ __IOS_DEPRECATED(2.0, 2.0, \"not available in __OBJC2__\") \\ __TVOS_UNAVAILABLE __WATCHOS_UNAVAILABLE# endif#endif 因此可直接忽略掉OBJC2和OBJC2_UNAVAILABLE objc_class结构体 名称 含义 isa isa指针 super_class 父类 name 类名 version 类的版本号 instance_size 类的大小 ivars 变量列表 methodLists 方法列表 cache 方法缓存列表 protocols 协议列表 Q: isa指针指向哪?先了解下OC的类的继承体系 isa指针与superclass 要知道isa指针的指向,需要先了解元类, 元类(metaClass)因为类也是对象(struct objc_class : objc_object {…}), 元类可近似认为是类对象的isa指针所指向的类 方法调用对象封装了变量和方法,变量是数据,每个对象都不尽相同,但方法是操作,每个对象应该都一样,所有的对象共享一份方法的代码,放在类中,而因为类本身也是一个对象,当向类发送消息时,该类的isa指针应该指向保存类方法的地址,由上可得,元类中保存着类方法 对象方法的查找顺序:当前类 -&gt; 父类 -&gt; … -&gt; 根类 类方法的查找顺序:当前类的元类 -&gt; 元类父类 -&gt; 根元类 A:总结 对象的isa指针指向类对象 类对象的isa指针指向该类对象对应的元类对象 所有元类对象的isa指针统一指向NSObject元类对象 类对象的superclass指向父类的类对象,回溯而上直到NSObject类对象 NSObject的superclass指向nil NSObject元类对象的父类为NSObject类对象 NSObject类对象的isa指针指向NSObject元类对象 验证在objc-706工程中,在debug-objc target的main.mm添加测试代码 123objc_class *cls_a_s = (objc_class *)[NSString class];objc_class *cls_b_s = (objc_class *)cls_a_s-&gt;getMeta();NSLog(@\"%p,%p\",cls_a_s,cls_b_s); 输出结果: 观察 + 计算 0x1dffffb6c19d89 = 0x1d8001004a10f1 - 0x1004a10f0 + 0x7fffb6c19d88 类对象的isa指针指向地址满足下面的等式 addr(class-&gt;isa) = addr(metaclass-&gt;isa) - addr(metaclass-&gt;superclass) + addr(metaclass) 另一个测试用例 123objc_class *cls_a = (objc_class *)[NSObject class];objc_class *cls_b = (objc_class *)cls_a-&gt;getMeta();NSLog(@\"%p,%p\",cls_a,cls_b); 0x1d8001004a10f1 = 0x1d8001004a10f1 - addr(NSObject) + 0x1004a1140 NSObject类地址是0x1004a1140,上式也成立 Q: 如何获得super_class,version,name,instance_size的值获取super_class 12345678910111213/** * Returns the superclass of a class. * * @param cls A class object. * * @return The superclass of the class, or \\c Nil if * \\e cls is a root class, or \\c Nil if \\e cls is \\c Nil. * * @note You should usually use \\c NSObject's \\c superclass method instead of this function. */OBJC_EXPORT Class class_getSuperclass(Class cls) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0); 获取version 123456789101112/** * Returns the version number of a class definition. * * @param cls A pointer to a \\c Class data structure. Pass * the class definition for which you wish to obtain the version. * * @return An integer indicating the version number of the class definition. * * @see class_setVersion */OBJC_EXPORT int class_getVersion(Class cls) OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0); 获取name 123456789/** * Returns the name of a class. * * @param cls A class object. * * @return The name of the class, or the empty string if \\e cls is \\c Nil. */OBJC_EXPORT const char *class_getName(Class cls) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0); 获取instance_size 123456789/** * Returns the size of instances of a class. * * @param cls A class object. * * @return The size in bytes of instances of the class \\e cls, or \\c 0 if \\e cls is \\c Nil. */OBJC_EXPORT size_t class_getInstanceSize(Class cls) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0); 测试代码 123456789int main(int argc, const char * argv[]) { @autoreleasepool { NSLog(@\"NSString类的super_class是%@\",class_getSuperclass([NSString class])); NSLog(@\"NSString类的version是%d\",class_getVersion([NSString class])); NSLog(@\"NSString类的name是%s\",class_getName([NSString class])); NSLog(@\"NSString类的instance_size是%ld\",class_getInstanceSize([NSString class])); } return 0;} 输出结果: Q:如何获得ivars,methodLists,protocols获得ivars 123456789101112131415/** * Describes the instance variables declared by a class. * * @param cls The class to inspect. * @param outCount On return, contains the length of the returned array. * If outCount is NULL, the length is not returned. * * @return An array of pointers of type Ivar describing the instance variables declared by the class. * Any instance variables declared by superclasses are not included. The array contains *outCount * pointers followed by a NULL terminator. You must free the array with free(). * * If the class declares no instance variables, or cls is Nil, NULL is returned and *outCount is 0. */OBJC_EXPORT Ivar *class_copyIvarList(Class cls, unsigned int *outCount) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0); 获得methodLists 12345678910111213141516171819/** * Describes the instance methods implemented by a class. * * @param cls The class you want to inspect. * @param outCount On return, contains the length of the returned array. * If outCount is NULL, the length is not returned. * * @return An array of pointers of type Method describing the instance methods * implemented by the class—any instance methods implemented by superclasses are not included. * The array contains *outCount pointers followed by a NULL terminator. You must free the array with free(). * * If cls implements no instance methods, or cls is Nil, returns NULL and *outCount is 0. * * @note To get the class methods of a class, use \\c class_copyMethodList(object_getClass(cls), &amp;count). * @note To get the implementations of methods that may be implemented by superclasses, * use \\c class_getInstanceMethod or \\c class_getClassMethod. */OBJC_EXPORT Method *class_copyMethodList(Class cls, unsigned int *outCount) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0); 获得protocols 123456789101112131415/** * Describes the protocols adopted by a class. * * @param cls The class you want to inspect. * @param outCount On return, contains the length of the returned array. * If outCount is NULL, the length is not returned. * * @return An array of pointers of type Protocol* describing the protocols adopted * by the class. Any protocols adopted by superclasses or other protocols are not included. * The array contains *outCount pointers followed by a NULL terminator. You must free the array with free(). * * If cls adopts no protocols, or cls is Nil, returns NULL and *outCount is 0. */OBJC_EXPORT Protocol * __unsafe_unretained *class_copyProtocolList(Class cls, unsigned int *outCount) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0); 测试代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#import \"objc-private.h\"#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) { @autoreleasepool { Class cls = [NSObject class]; unsigned int count = 0; Ivar *list = class_copyIvarList(cls, &amp;count); for (unsigned int i = 0; i &lt; count; ++i) { Ivar ity = list[i]; const char *iname = ivar_getName(ity); NSLog(@\"%@\\n\",[NSString stringWithUTF8String:iname]); } free(list); objc_property_t *list2 = class_copyPropertyList(cls, &amp;count); for (unsigned int i = 0; i &lt; count; ++i) { objc_property_t ity = list2[i]; const char *iname = property_getName(ity); NSLog(@\"%@\\n\",[NSString stringWithUTF8String:iname]); } free(list2); Method *methods = class_copyMethodList(cls, &amp;count); for (unsigned int i = 0; i &lt; count; i++) { Method method = methods[i]; printf(\"\\t'%s'|'%s' of encoding '%s'\\n\", class_getName(cls), sel_getName(method_getName(method)), method_getTypeEncoding(method)); } free(methods); Protocol * __unsafe_unretained * protocols = class_copyProtocolList(cls, &amp;count); Protocol * protocol; for (unsigned int i = 0; i &lt; count; i++) { protocol = protocols[i]; NSLog(@\"protocol name: %s\", protocol_getName(protocol)); } } return 0;} 输出效果 获得cache 为已有类添加ivar,property,method,protocol 12345678910111213141516/** * Adds a new instance variable to a class. * * @return YES if the instance variable was added successfully, otherwise NO * (for example, the class already contains an instance variable with that name). * * @note This function may only be called after objc_allocateClassPair and before objc_registerClassPair. 需要在obj_allocateClassPair与objc_registerClassPair之间调用 * Adding an instance variable to an existing class is not supported. 不支持为已有的类添加实例变量 * @note The class must not be a metaclass. Adding an instance variable to a metaclass is not supported. 不支持为元类添加实例变量 * @note The instance variable's minimum alignment in bytes is 1&lt;&lt;align. The minimum alignment of an instance * variable depends on the ivar's type and the machine architecture. * For variables of any pointer type, pass log2(sizeof(pointer_type)). */OBJC_EXPORT BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0); 12345678910111213/** * Adds a property to a class. * * @param cls The class to modify. * @param name The name of the property. * @param attributes An array of property attributes. * @param attributeCount The number of attributes in \\e attributes. * * @return \\c YES if the property was added successfully, otherwise \\c NO * (for example, the class already has that property). */OBJC_EXPORT BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount) OBJC_AVAILABLE(10.7, 4.3, 9.0, 1.0); 123456789101112131415161718/** * Adds a new method to a class with a given name and implementation. * * @param cls The class to which to add a method. * @param name A selector that specifies the name of the method being added. * @param imp A function which is the implementation of the new method. The function must take at least two arguments—self and _cmd. * @param types An array of characters that describe the types of the arguments to the method. * * @return YES if the method was added successfully, otherwise NO * (for example, the class already contains a method implementation with that name). * * @note class_addMethod will add an override of a superclass's implementation, * but will not replace an existing implementation in this class. * To change an existing implementation, use method_setImplementation. */OBJC_EXPORT BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0); 1234567891011/** * Adds a protocol to a class. * * @param cls The class to modify. * @param protocol The protocol to add to \\e cls. * * @return \\c YES if the method was added successfully, otherwise \\c NO * (for example, the class already conforms to that protocol). */OBJC_EXPORT BOOL class_addProtocol(Class cls, Protocol *protocol) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0); 测试代码 添加proerty 1234567891011121314151617181920212223int main(int argc, const char * argv[]) { @autoreleasepool { Class cls = [NSObject class]; unsigned int count = 0; /* Defines a property attribute typedef struct { const char *name; *&lt; The name of the attribute const char *value; *&lt; The value of the attribute (usually empty) } objc_property_attribute_t; */ objc_property_attribute_t t = {\"T\",\"123\"}; class_addProperty(cls, \"newProperty\",&amp;t, 1); objc_property_t *list2 = class_copyPropertyList(cls, &amp;count); for (unsigned int i = 0; i &lt; count; ++i) { objc_property_t ity = list2[i]; const char *iname = property_getName(ity); NSLog(@\"%@\\n\",[NSString stringWithUTF8String:iname]); } free(list2); } return 0;} 添加method 1234567891011121314151617181920int main(int argc, const char * argv[]) { @autoreleasepool { Class cls = [NSObject class]; unsigned int count = 0; IMP imp = imp_implementationWithBlock(^{ NSLog(@\"add a new method\"); }); BOOL r = class_addMethod(cls, @selector(newMethod), imp, nil); Method *methods = class_copyMethodList(cls, &amp;count); for (unsigned int i = 0; i &lt; count; i++) { Method method = methods[i]; printf(\"\\t'%s'|'%s' of encoding '%s'\\n\", class_getName(cls), sel_getName(method_getName(method)), method_getTypeEncoding(method)); } free(methods); [(id)cls performSelector:@selector(newMethod)]; } return 0;} 添加protocol 12345678910111213141516171819int main(int argc, const char * argv[]) { @autoreleasepool { Class cls = [NSObject class]; unsigned int count = 0; // objc_addProtocol(); Protocol *p = objc_allocateProtocol(\"newProtocol\"); objc_registerProtocol(p); class_addProtocol(cls,p); Protocol * __unsafe_unretained * protocols = class_copyProtocolList(cls, &amp;count); Protocol * protocol; for (unsigned int i = 0; i &lt; count; i++) { protocol = protocols[i]; NSLog(@\"protocol name: %s\", protocol_getName(protocol)); } } return 0;} 注:以上函数声明摘自于iOS10.1的runtime.h 参考 南峰子 - Objective-C Runtime 运行时之一：类与对象","link":"/2016/12/25/iOSer-Understand-objc-runtime-2-class-structure-runtime-h/"},{"title":"理解objc运行时四-运行时流程分析","text":"概览 系统调用加载objc动态库前的一些流程 环境 macOS Sierra 10.12.3Xcode8.2.1 应用程序的执行流程exec函数族 12345$ whatis execbuiltin(1), !(1), %(1), .(1),... endif(1), endsw(1), esac(1), eval(1), exec(1), exit(1), export(1),...exec(ntcl) - Invoke subprocessessandbox-exec(1) - execute within a sandbox exec函数族可以根据指定的文件名找到可执行文件,并用它来取代调用进程的内容。 函数原型 1234567#include &lt;unistd.h&gt;int execl(const char *pathname, const char *arg0, ... /* (char *)0 */);int execv(const char *pathname, char *const argv[]);int execle(const char *pathname, const char *arg0, ... /* (char *)0, char *const envp[] */);int execve(const char *pathname, char *const argv[], char *const envp[]);int execlp(const char *filename, const char *arg0, ... /* (char *)0 */);int execvp(cosnt char *filename, char *const argv[]); 只有execve是真正意义上的系统调用,其它都是在此基础上经过包装的库函数 macOS*操作系统的内核为XNU* 参考苹果开源网站 在如下目录 xnu/bsd/kern/kern_exec.c 有execve函数的定义 1234567891011121314151617181920212223242526272829303132333435363738/* * execve * * Parameters: uap-&gt;fname File name to exec * uap-&gt;argp Argument list * uap-&gt;envp Environment list * * Returns: 0 Success * __mac_execve:EINVAL Invalid argument * __mac_execve:ENOTSUP Invalid argument * __mac_execve:EACCES Permission denied * __mac_execve:EINTR Interrupted function * __mac_execve:ENOMEM Not enough space * __mac_execve:EFAULT Bad address * __mac_execve:ENAMETOOLONG Filename too long * __mac_execve:ENOEXEC Executable file format error * __mac_execve:ETXTBSY Text file busy [misuse of error code] * __mac_execve:??? * * TODO: Dynamic linker header address on stack is copied via suword() *//* ARGSUSED */intexecve(proc_t p, struct execve_args *uap, int32_t *retval){ struct __mac_execve_args muap; int err; memoryshot(VM_EXECVE, DBG_FUNC_NONE); muap.fname = uap-&gt;fname; muap.argp = uap-&gt;argp; muap.envp = uap-&gt;envp; muap.mac_p = USER_ADDR_NULL; err = __mac_execve(p, &amp;muap, retval); return(err);} 可看出macOS中的execve函数 调用__mac_execve函数 函数原型的参数和一般的Unix系统有出入 __mac_execve exec_activate_image exec_mach_imgact load_machfile parse_machfile exec_mach_imgact 拷贝可执行文件到内存中，并根据不同的可执行文件类型选择不同的加载函数，所有的镜像的加载要么终止在一个错误上，要么最终完成加载镜像。 OS X有三种可执行文件，mach-o由exec_mach_imgact处理，fat binary由exec_fat_imgact处理，interpreter（解释器）由exec_shell_imgact处理 load_machfile load_machfile会加载Mach-O中的各种load monmand命令。在其内部会禁止数据段执行，防止溢出漏洞攻击，还会设置地址空间布局随机化（ASLR），还有一些映射的调整。 parse_machfile parse_machfile会根据load_command的种类选择不同的函数来加载，内部是一个Switch语句来实现的 对于命令的加载会进行多次扫描，当扫描三次之后，并且存在dylinker_command命令时，会执行 load_dylinker()，启动动态链接器 (dyld) 更详细的流程,请参看趣探 Mach-O：加载过程 重点关注的是objc运行时的加载流程,因为运行时也是一个动态库,有dyld加载器后,就可以去关注了objc动态库的加载流程。在此之前,有两个问题想要说明一下 macOS系统架构 mach-o文件头 macOS系统架构 Mac OS X is built on a Unix core; the Darwin core is based on the Berkeley Software Distribution (BSD) version of Unix. The heart of the Darwin core is called Mach. Darwin(达尔文)内核的核心是Mach,上层封装了BSD来支持POSIX mach-o文件头概述 Mach-o包含三个基本区域：头部（header structure）。加载命令（load command）。段（segment）。可以拥有多个段（segment），每个段可以拥有零个或多个区域（section）。每一个段（segment）都拥有一段虚拟地址映射到进程的地址空间。链接信息。一个完整的用户级Mach-o文件的末端是链接信息。其中包含了动态加载器用来链接可执行文件或者依赖库所需使用的符号表，字符串表等等。 新建一个Xcode工程,⌘ + B 后生成Product,将生成的App中的二进制文件拖到MachOView中,如下所示: 字段解释 魔数(Magic Number)标志了可执行文件的类型 后面找却只有 ARMv7是有的,但是ARM64却在wiki上没找到,搜索后,根据常用魔数 MH_MAGIC_64宏的定义在 xnu-(内核版本xxx)/EXTERNAL_HEADERS/mach-o/loader.h 这样就对上了 架构(Number of Architecture 2)可支持架构数量(ARMv7 &amp; ARMv64) CPU类型(CPU Type) &amp; CPU类型(CPU SubType)标明CPU类型,为了后续方便处理 同样offset,Size,Align都是说明了应用的内存位置相关的信息 Load Commands加载命令,根据上面会由parse_machfile函数执行 主要关注几个字段 LC_LOAD_DYLINKER:加载器,负责加载其他动态库 LC_LOAD_DYLIB(xxx):加载的动态库 更详细的可参考 iOS安全–了解Mach-o文件结构 参考 what-are-the-uses-of-the-exec-command-in-shell-scripts C-shell的基本使用 趣探 Mach-O：加载过程 Mac OS X Architecture and Terminology Architecture of macOS Magic number (programming) 常用魔数","link":"/2017/01/27/iOSer-Understand-objc-runtime-4-runtime-process-analysis/"},{"title":"理解objc运行时三:方法编码,执行,转发,交换","text":"方法编码概念 To assist the runtime system, the compiler encodes the return and argument types for each method in a character string and associates the string with the method selector. 为了辅助运行时系统，编译器对字符串中每个方法的返回和参数类型进行编码，并将字符串与方法选择器相关联 OC类型编码表 字符 含义 c A char i An int s A short l A long l is treated as a 32-bit quantity on 64-bit programs. q A long long C An unsigned char I An unsigned int S An unsigned short L An unsigned long Q An unsigned long long f A float d A double B A C++ bool or a C99 _Bool v A void * A character string (char *) @ An object (whether statically typed or typed id) # A class object (Class) : A method selector (SEL) [array type] An array {name=type…} A structure (name=type…) A union bnum A bit field of num bits ^type A pointer to type ? An unknown type (among other things, this code is used for function pointers 详情参考:Type Encoding 在上一节使用method_getTypeEncoding打印出方法列表时 12345...'NSString'|'initWithFormat:locale:arguments:' of encoding '@40@0:8@16@24[1{__va_list_tag=II^v^v}]32''NSString'|'initWithCoder:' of encoding '@24@0:8@16''NSString'|'initWithString:' of encoding '@24@0:8@16'... 12// method_getTypeEncoding函数的注释为返回一个描述了方法参数与返回类型的字符串 * Returns a string describing a method's parameter and return types. 方法是如何编码的 为什么NSString的initWithString*的编码是@24@0:8@16* Google了一下 Apple Mail List: method_getTypeEncoding returns strange string 里面主要说了两个事情 为什么有这么多的@:之类的数字代表什么意思 因为OC方法默认带了self*和_cmd*这两个参数,所以这也是为什么能直接在方法中用这两个”关键字”的原因,所以配合上面的编码表 @(返回值)24@(self)0:(_cmd)8@(第一个参数NSString) 关于数字代表什么意思? 帖子上说法不太统一, 有说是栈偏移量(Stack offset)的,有说和(arm,ppc,x86_64)平台相关。 尝试查了源码,调试了半天,不太成功,并不是明显的有一个生成规则。经过观察,发现@0:8是每个方法都是一样的(NSString类),结合上面的含义 0 用来描述self,8用来描述_cmd,想到self指向该类地址基地址,偏移量正好为0,因此揣测数字的意思应该是相对于类的基地址的偏移量 数据类型IvarIvar用于表示类的实例变量的类型 定义如下 12345678struct objc_ivar { char *ivar_name OBJC2_UNAVAILABLE; char *ivar_type OBJC2_UNAVAILABLE; int ivar_offset OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif} 测试代码 定义了一个DataStructure类 123456789101112131415161718192021@interface DataStructure : NSObject { int _a; long _b; char _c; NSArray *_d;}int main(int argc, const char * argv[]) { @autoreleasepool { Class cls = [DataStructure class]; unsigned int count = 0; Ivar *list = class_copyIvarList(cls, &amp;count); for (unsigned int i = 0; i &lt; count; ++i) { Ivar ity = list[i]; const char *iname = ivar_getName(ity); NSLog(@\"%@\\n\",[NSString stringWithUTF8String:iname]); } free(list); } return 0;} type : i 整数name: _aoffset: 0x1007028a0 objc_property_tobjc_property_t用于表示类的属性的类型 123// runtime.h/// An opaque type that represents an Objective-C declared property.typedef struct objc_property *objc_property_t; 12// objc-private.htypedef struct property_t *objc_property_t; 都是指向objc_property结构体的指针 objc_property结构体的定义 12345// objc-runtime-new.hstruct property_t { const char *name; const char *attributes;}; 里面有个指针attributes指向objc_property_attribute_t结构体的数组 123456// runtime.h/// Defines a property attributetypedef struct { const char *name; /**&lt; The name of the attribute */ const char *value; /**&lt; The value of the attribute (usually empty) */} objc_property_attribute_t; 测试代码 123456789101112131415161718int main(int argc, const char * argv[]) { @autoreleasepool { Class cls = [DataStructure class]; unsigned int count = 0; objc_property_attribute_t t1 = {\"g1\",\"val1\"}; objc_property_attribute_t t2 = {\"g2\",\"val2\"}; objc_property_attribute_t t[] = {t1,t2}; class_addProperty(cls, \"g\", t, 2); objc_property_t *list2 = class_copyPropertyList(cls, &amp;count); for (unsigned int i = 0; i &lt; count; ++i) { objc_property_t ity = list2[i]; const char *iname = property_getName(ity); NSLog(@\"%@\\n\",[NSString stringWithUTF8String:iname]); } free(list2); } return 0;} objc_property_t 中的attributes指针确实指向了通过class_addProperty函数添加到类中,类型为objc_property_attribute_t结构体的数组 关联对象(Associated Object)OC*中要想给原有的类添加方法,要么是动态添加,另一种就是分类(Category),但是分类时,不能添加实例变量,编译器不允许,可以通过关联对象进行绑定,同时还可以指定管理策略,像使用@property*一样方便。 测试代码: 1234567891011static const void *assockey = \"\";int main(int argc, const char * argv[]) { @autoreleasepool { Class cls = [DataStructure class];// unsigned int count = 0; objc_setAssociatedObject(cls, assockey, @\"123\", OBJC_ASSOCIATION_COPY_NONATOMIC); NSLog(@\"%@\",objc_getAssociatedObject(cls, assockey)); } return 0;} 跟进去得到 1234567891011121314151617181920212223242526272829303132333435363738394041424344void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) { // retain the new value (if any) outside the lock. ObjcAssociation old_association(0, nil); id new_value = value ? acquireValue(value, policy) : nil; { AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) { // break any existing association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { // secondary table exists ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) { old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); } else { (*refs)[key] = ObjcAssociation(policy, new_value); } } else { // create the new association (first time). ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); object-&gt;setHasAssociatedObjects(); } } else { // setting the association to nil breaks the association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) { old_association = j-&gt;second; refs-&gt;erase(j); } } } } // release the old value (outside of the lock). if (old_association.hasValue()) ReleaseValue()(old_association);} 大致原理是有个AssociationsHashMap将key和value进行关联,根据注释,可以得出,如果key相同时,retain新值release旧值 方法的执行前面说了,OC是一门动态的面向对象编程语言,它脱胎于SmalltalkWiki Smalltalk中的消息机制被OC采用并传承下来 MessagesThe message is the most fundamental language construct in Smalltalk. Even control structures are implemented as message sends. Smalltalk adopts by default a synchronous, single dynamic message dispatch strategy (as contrasted to the asynchronous, multiple dispatch strategy adopted by some other object-oriented languages). 而它与C++这种函数调用(function calling)区别在于。运行时所应执行的代码由运行环境来决定;而使用函数调用的语言,则由编译器决定。 先了解一些概念 SELSEL与Method有关,看下Method Method123456789// runtime.h/// An opaque type that represents a method in a class definition.typedef struct objc_method *Method;struct objc_method { SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE;} OBJC2_UNAVAILABLE; 123456789101112131415161718// objc-private.htypedef struct method_t *Method;// objc-runtime-new.hstruct method_t { SEL name; const char *types; IMP imp; struct SortBySELAddress : public std::binary_function&lt;const method_t&amp;, const method_t&amp;, bool&gt; { bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) { return lhs.name &lt; rhs.name; } };}; 一个Method包含 123SEL name*: // 方法名const char * types: // 方法的编码IMP imp: // 方法的实现 123// objc.h/// An opaque type that represents a method selector.typedef struct objc_selector *SEL; 代码验证 当向一个OC对象执行方法(发送消息)时,方法在底层会转换成调用objc_msgSend( )函数 该函数的原型为void objc_msgSend(id self, SEL cmd,…) 该函数通过SEL在self对象的列表中找指定的方法 测试代码 1234567int main(int argc, const char * argv[]) { @autoreleasepool { NSObject *cls= [[NSObject alloc] init]; [cls debugDescription]; } return 0;} 按指令级别调试 ⌃ + F7 功能键开启情况下,要加上fn, 从调用堆栈看确实调用了objc_msgSend,再继续跟进,会进到objc-msg-x86_64.s(因为是macOS的源代码) 当然还有其他的一些情况,会交由Objective-C运行环境中的另外一些函数来处理 objc_msgSend_stret: 发送消息要返回结构体,交由此函数处理objc_msgSend_fpret:发送消息返回的是浮点数,交由此函数处理objc_msgSendSuper: 给父类发送消息,交由此函数处理 现在我们已经知道哪个对象(self)要接收消息(SEL),但是消息具体执行什么?Method结构体已经告诉了到,就是那个IMP,如果我们要知道那个IMP,一种方法就是用一个表去关联方法名(SEL)和方法实现(IMP),这样在objc_msgSend中就可以根据方法名(SEL)去找到方法实现(IMP) 第二部分,在探究类的结构时,曾使用class_copyMethodList得到方法列表,打断点,进入objc-runtime-new.mm 12345678910111213141516171819202122232425262728293031Method *class_copyMethodList(Class cls, unsigned int *outCount){ unsigned int count = 0; Method *result = nil; if (!cls) { if (outCount) *outCount = 0; return nil; } rwlock_reader_t lock(runtimeLock); assert(cls-&gt;isRealized()); count = cls-&gt;data()-&gt;methods.count(); if (count &gt; 0) { result = (Method *)malloc((count + 1) * sizeof(Method)); count = 0; // 遍历获取方法,换言之,可通过cls-&gt;data()-&gt;methods获得方法的IMP地址,知道要执行的代码的地址 for (auto&amp; meth : cls-&gt;data()-&gt;methods) { result[count++] = &amp;meth; } result[count] = nil; } if (outCount) *outCount = count; return result;} 其中有一句 cls-&gt;data()-&gt;methods.count() 看看cls-&gt;data()-&gt;methods尝试直接访问,不行,应该是锁的关系 直接调试里面的代码 方法转发在第二部分的方法调用中,知道了查找方法的顺序,因为OC的动态性,在编译期间向类发送了其无法解读的消息,并不会报错,但是当运行时,发现接收者确实无法响应消息时,就会报unrecognized selector sent to instance 0x87*** Terminating app due to uncaught exception NSInvalidArgumentException…,但是在此之前,OC还会启动“消息转发”(message forwarding)机制,让程序员有机会告诉对象如何处理未知消息。 动态方法解析接收者是对象 1+ (BOOL)resolveInstanceMethod:(SEL)selector 接收者是类 1+ (BOOL)resolveClassMethod:(SEL)selector selector参数为未识别的方法前提:相关方法的实现代码已经写好,只是运行时插入到类中即可,常常用来实现@dynamic属性。 备援接收者1- (id)forwardingTargetForSelector:(SEL)selector selector参数为未识别的方法id返回类型代表能识别selector方法的对象,如果没有,返回nil 测试代码 123456789101112131415161718192021int main(int argc, const char * argv[]) { @autoreleasepool { DataStructure *d = [[DataStructure alloc] init]; [d performSelector:@selector(haha)]; } return 0;}- (id)forwardingTargetForSelector:(SEL)aSelector { return [[NewTarget alloc] init];}@interface NewTarget : NSObject- (void)haha;@end@implementation NewTarget- (void)haha { NSLog(@\"haha\");}@end 将发送给DataStructure类的haha消息让NewTarget类去响应 该方法配合组合的形式,可以模拟多继承的效果 完整的消息转发启动完整的消息转发机制,创建NSInvocation对象,封装未响应对象的SEL,target及参数,调用 1- (void)forwardInvocation:(NSInvocation *)invocation 使用该方法可以修改消息内容,追加参数,更改SEL等 方法交换(Method Swizzling)从上面也可以知道,OC中可以在运行时,动态添加方法,改变接收对象,消息改变与转发等。因为Method方法有SEL与IMP,可以通过修改SEL指向的IMP,达到方法交换的效果。 代码 1234567891011121314151617181920212223242526272829/** * cls 类 * originalSelector cls类原SEL * swizzSelector cls类新SEL */ + (void)hookMethod:(Class)cls OriginSelector:(SEL)originalSelector SwizzledSelector:(SEL)swizzledSelector { // 方法指针 Method originalMethod = class_getInstanceMethod(cls, originalSelector); Method swizzledMethod = class_getInstanceMethod(cls, swizzledSelector); // 为原SEL添加新的IMP实现 BOOL didAddMethod = class_addMethod(cls, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); // 添加成功 if (didAddMethod) { // 用原SEL的IMP实现替换新SEL的IMP实现 达到交换方法的效果 class_replaceMethod(cls, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { // 若失败,直接交换 method_exchangeImplementations(originalMethod, swizzledMethod); }} 参考 南峰子:Objective-C Runtime 运行时之二：成员变量与属性 ASSOCIATED OBJECT 《Effective Objective-C 2.0》","link":"/2016/12/25/iOSer-Understand-objc-runtime-3-method-encoding-execution-etc/"},{"title":"理解Block(下)","text":"前言本文将会从内存结构上分析 OC 中的 Block 。 环境 macOS Sierra 10.12.3Xcode 8.2.1 关于 Block 的实现在 Block的实现 中的 Block 的结构声明如下 12345678910111213141516struct Block_literal_1 { void *isa; // initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock int flags; int reserved; void (*invoke)(void *, ...); struct Block_descriptor_1 { unsigned long int reserved; // NULL unsigned long int size; // sizeof(struct Block_literal_1) // optional helper functions void (*copy_helper)(void *dst, void *src); // IFF (1&lt;&lt;25) void (*dispose_helper)(void *src); // IFF (1&lt;&lt;25) // required ABI.2010.3.16 const char *signature; // IFF (1&lt;&lt;30) } *descriptor; // imported variables}; 关于 ABI 在计算机软件中，应用程序二进制接口（ABI）是两个程序模块之间的接口，其中一个程序模块通常是机器代码级别的库或操作系统。 ABI确定如何调用函数以及在系统调用的情况下将二进制格式信息从一个程序组件传递到下一个程序组件或操作系统的详细信息。 Block : 结构中有一个 isa 指针，初始化时指向 _NSConcreteStackBlock 或 _NSConcreteGlobalBlock 的地址, 用于实现对象相关的功能。 flags : 用于按 bit 位表示一些 block 的附加信息 reserved : 保留位 void (*invoke)(void* ,...) : 接收可变参数的函数指针，指向 block 实现的函数调用 (invoke) 地址。 descriptor : Block_descriptor_1 结构体的指针，表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。 imported variables : capture 过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。 实践实践一 : 新建 Xcode 命令行工程main.m 12345678910111213#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) { @autoreleasepool { // insert code here... void (^blockDemo)() = ^() { NSLog(@\"Hello world\"); }; blockDemo(); } return 0;} 设置断点，编译并运行，按指令级别单步调试，可得到 从上面的结果可知, Block 结构确实如上面所描述的, isa 指针指向的是 __NSGlobalBlock__ 将工程的二进制文件放到 Hopper ，查看 __main_block_invoke 123456789101112131415 ___main_block_invoke:0000000100000f10 push rbp ; Objective C Block defined at 0x100001060, XREF=0x1000010700000000100000f11 mov rbp, rsp0000000100000f14 sub rsp, 0x100000000100000f18 lea rax, qword [ds:cfstring_Hello_world] ; @\"Hello world\"0000000100000f1f mov qword [ss:rbp+var_8], rdi0000000100000f23 mov qword [ss:rbp+var_10], rdi0000000100000f27 mov rdi, rax ; argument \"format\" for method imp___stubs__NSLog0000000100000f2a mov al, 0x00000000100000f2c call imp___stubs__NSLog0000000100000f31 add rsp, 0x100000000100000f35 pop rbp0000000100000f36 ret ; endp0000000100000f37 db 0x90 ; '.' 反汇编得到 1234void ___main_block_invoke(void * _block) { NSLog(@\"Hello world\"); return;} 修改 Xcode 工程，用 Block 去捕获参数 123456789101112131415#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) { @autoreleasepool { // insert code here... int a = 1; NSString *testString = @\"2\"; void (^blockDemo)() = ^() { NSLog(@\"Hello world,%d,%@\",a,testString); }; blockDemo(); } return 0;} 同样操作得到如下截图 如果取消 ARC 环境, isa 指针会指向 __NSStackBlock__，在此不再截图说明。 小结一 验证了 Block 中 invoke 函数指针指向 block 实现的函数地址。 验证了 imported variables 确实保存了从外部 capture 到 Block 中的变量 问题一Block 中 isa 指针指向的对象和 Block的实现 描述的有出入 实践二 : clang 重写工程的 main.m 文件找到 main.m 文件，在终端中用 clang -rewrite-objc path/to/main.m 生成对应的 C++ 代码。 参考本文后的引用链接 3 摘录出与 Block 相关的实现部分 1234567891011121314151617181920212223#ifndef BLOCK_IMPL#define BLOCK_IMPLstruct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};// Runtime copy/destroy helper functions (from Block_private.h)#ifdef __OBJC_EXPORT_BLOCKSextern \"C\" __declspec(dllexport) void _Block_object_assign(void *, const void *, const int);extern \"C\" __declspec(dllexport) void _Block_object_dispose(const void *, const int);extern \"C\" __declspec(dllexport) void *_NSConcreteGlobalBlock[32];extern \"C\" __declspec(dllexport) void *_NSConcreteStackBlock[32];#else__OBJC_RW_DLLIMPORT void _Block_object_assign(void *, const void *, const int);__OBJC_RW_DLLIMPORT void _Block_object_dispose(const void *, const int);__OBJC_RW_DLLIMPORT void *_NSConcreteGlobalBlock[32];__OBJC_RW_DLLIMPORT void *_NSConcreteStackBlock[32];#endif#endif#define __block#define __weak 123456789101112131415161718192021222324252627282930struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) { NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_lk_znn1qp4925j412wt4t_qkplc0000gn_T_main_8067ac_mi_0); }static struct __main_block_desc_0 { size_t reserved; size_t Block_size;} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};int main(int argc, const char * argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; void (*blockDemo)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); ((void (*)(__block_impl *))((__block_impl *)blockDemo)-&gt;FuncPtr)((__block_impl *)blockDemo); } return 0;}static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; main 函数的执行流程 函数 __main_block_impl_0 以 __main_block_func_0 与 __main_block_desc_0_DATA 作参数传入来完成结构体 __main_block_impl_0 的初始化 函数 __main_block_func_0 在这里即为 NSLog(@\"Hello world\")，将其地址传递给结构体 __main_block_impl_0 中的 __block_impl 结构体 impl 的函数指针 FuncPtr 参数 __main_block_desc_0 传递到结构体 __main_block_impl_0 中的 __main_block_desc_0 结构体的 Desc blockDemo 函数指针引用了前面结构体初始化中获得的 __main_block_impl_0 结构体 blockDemo 函数指针引用的结构体强转为 __block_impl * 类型，因为结构体 __main_block_impl_0 的内存结构中最前面就是 __block_impl 结构体的 impl，因此在这里强转类型借用一下面向对象的概念就是子类强转成父类指针，是没有问题的。当然面向过程早于面向对象，面向对象为什么能实现父类指针强转成子类，反倒是应该要依赖两者兼容的内存结构。 执行第 5 步生成的 __block_impl 的结构体的 FuncPtr 函数，前面部分的 ((void (*)(__block_impl *)) 表明这个函数是无返回值,需要一个 __block_impl 的参数，后面部分的 ((__block_impl *)blockDemo) 说明要执行 FuncPtr 函数，并把 blockDemo 强转为 (__block_impl * ) 作为参数传递到该函数中 小结二从上面的实践中,我们可以得知平时创建的 Block 包含了 struct __block_impl 和类似 struct __main_block_desc_0 这与 Block实现 中描述的 Block 的结构是等价的。 关于问题一 在实践一中用 po 输出 Block 的 isa 对象为类似 __NSStackBlock__ 这种的类型的 在实践二中用 clang 重写 OC 代码，Block 的 isa 指针指向 _NSConcreteStackBlock / _NSConcreteStackBlock 哪个才是正确的呢? 思考之后，我觉得是这样的: 从内存角度上看，isa 中保存的就是一个内存地址。我们用 po 来输出时，就是告诉 lldb 把我传入的这个内存地址认为是一个对象的起始地址，以一个对象的角度去看它，因为 Apple 对 Block 进行了相应的封装，自然输出对应的 Block 对象类型。然后在 clang 翻译成 C++ 后，是以 _NSConcreteStackBlock 这种变量地址的角度来看待它。简而言之，两者都没有问题，只是角度不同而已。 实践三 : 捕获外部变量的 Block类似实践二操作，查看捕获了外部变量的 Block 的实现 12345678910111213141516171819202122232425262728293031323334353637383940struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; int a; NSString *testString; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, NSString *_testString, int flags=0) : a(_a), testString(_testString) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) { int a = __cself-&gt;a; // bound by copy NSString *testString = __cself-&gt;testString; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_lk_znn1qp4925j412wt4t_qkplc0000gn_T_main_6832f1_mi_1,a,testString); }static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;testString, (void*)src-&gt;testString, 3/*BLOCK_FIELD_IS_OBJECT*/);}static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;testString, 3/*BLOCK_FIELD_IS_OBJECT*/);}static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};int main(int argc, const char * argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; int a = 1; NSString *testString = (NSString *)&amp;__NSConstantStringImpl__var_folders_lk_znn1qp4925j412wt4t_qkplc0000gn_T_main_6832f1_mi_0; void (*blockDemo)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a, testString, 570425344)); ((void (*)(__block_impl *))((__block_impl *)blockDemo)-&gt;FuncPtr)((__block_impl *)blockDemo); } return 0;}static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; 小结三main 函数的执行流程 这次与实践二主要差别在 结构体 __main_block_impl_0 的多了两个 a 和 testString 属性接收外界传入的参数。 结构体 __main_block_desc_0 多了 copy 和 dispose 两个函数 多了 __main_block_copy_0 和 __main_block_dispose_0 两个静态方法 查看 Block-private.h 1234567891011// Runtime support functions used by compiler when generating copy/dispose helpers// Values for _Block_object_assign() and _Block_object_dispose() parametersenum { // see function implementation for a more complete description of these fields and combinations BLOCK_FIELD_IS_OBJECT = 3, // id, NSObject, __attribute__((NSObject)), block, ... BLOCK_FIELD_IS_BLOCK = 7, // a block variable BLOCK_FIELD_IS_BYREF = 8, // the on stack structure holding the __block variable BLOCK_FIELD_IS_WEAK = 16, // declared __weak, only used in byref copy helpers BLOCK_BYREF_CALLER = 128, // called from __block (byref) copy/dispose support routines.}; 因为 a 不是对象，所以是以传值的方式进行传递过程。而 testString 是对象，会在函数 __main_block_copy_0 中以参数 3 去调用函数 _Block_object_assign，在函数 __main_block_dispose_0 中类似。 实践四 : __Block 修饰捕获的变量插曲1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) { @autoreleasepool { // insert code here... int a = 1; NSString *testString = @\"2\"; __block int b = 2; __block NSString *testString2 = @\"3\"; void (^blockDemo)() = ^() { NSLog(@\"Hello world,%d,%d,%@,%@\",a,b,testString,testString2); }; blockDemo(); } return 0;} 上面这段代码用 clang -rewrite-objc 会报 clang: error: unable to execute command: Segmentation fault: 11 ，段错误，一般是访问了非法地址造成的。很多编程语言为了避免字符串被重复创建，一般都会有个字符串常量缓存池。而 OC 中也不例外，用字面量创建的字符串是放在数据段中的。 the string will be stored in a area of memory called data segment. This area never changes after the application is launched 这个区域的数据在应用启动后不会被改变，而用 __block 来修饰，很明显是想在 block 中进行修改，所以才会报段错误。 回归修改后的代码 1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) { @autoreleasepool { // insert code here... int a = 1; NSString *testString = @\"2\"; __block int b = 2; __block NSString *testString2 = [[NSString alloc] initWithString:@\"3\"]; void (^blockDemo)() = ^() { NSLog(@\"Hello world,%d,%d,%@,%@\",a,b,testString,testString2); }; blockDemo(); } return 0;} rewrite 后的结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263struct __Block_byref_b_0 { void *__isa;__Block_byref_b_0 *__forwarding; int __flags; int __size; int b;};struct __Block_byref_testString2_1 { void *__isa;__Block_byref_testString2_1 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); NSString *testString2;};struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; int a; NSString *testString; __Block_byref_b_0 *b; // by ref __Block_byref_testString2_1 *testString2; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, NSString *_testString, __Block_byref_b_0 *_b, __Block_byref_testString2_1 *_testString2, int flags=0) : a(_a), testString(_testString), b(_b-&gt;__forwarding), testString2(_testString2-&gt;__forwarding) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) { __Block_byref_b_0 *b = __cself-&gt;b; // bound by ref __Block_byref_testString2_1 *testString2 = __cself-&gt;testString2; // bound by ref int a = __cself-&gt;a; // bound by copy NSString *testString = __cself-&gt;testString; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_lk_znn1qp4925j412wt4t_qkplc0000gn_T_main_894ba5_mi_2,a,(b-&gt;__forwarding-&gt;b),testString,(testString2-&gt;__forwarding-&gt;testString2)); }static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;b, (void*)src-&gt;b, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;testString, (void*)src-&gt;testString, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_assign((void*)&amp;dst-&gt;testString2, (void*)src-&gt;testString2, 8/*BLOCK_FIELD_IS_BYREF*/);}static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;b, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;testString, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_dispose((void*)src-&gt;testString2, 8/*BLOCK_FIELD_IS_BYREF*/);}static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};int main(int argc, const char * argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; int a = 1; NSString *testString = (NSString *)&amp;__NSConstantStringImpl__var_folders_lk_znn1qp4925j412wt4t_qkplc0000gn_T_main_894ba5_mi_0; __attribute__((__blocks__(byref))) __Block_byref_b_0 b = {(void*)0,(__Block_byref_b_0 *)&amp;b, 0, sizeof(__Block_byref_b_0), 2}; __attribute__((__blocks__(byref))) __Block_byref_testString2_1 testString2 = {(void*)0,(__Block_byref_testString2_1 *)&amp;testString2, 33554432, sizeof(__Block_byref_testString2_1), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSString *(*)(id, SEL, NSString *))(void *)objc_msgSend)((id)((NSString *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSString\"), sel_registerName(\"alloc\")), sel_registerName(\"initWithString:\"), (NSString *)&amp;__NSConstantStringImpl__var_folders_lk_znn1qp4925j412wt4t_qkplc0000gn_T_main_894ba5_mi_1)}; void (*blockDemo)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a, testString, (__Block_byref_b_0 *)&amp;b, (__Block_byref_testString2_1 *)&amp;testString2, 570425344)); ((void (*)(__block_impl *))((__block_impl *)blockDemo)-&gt;FuncPtr)((__block_impl *)blockDemo); } return 0;}static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; 小结四以 __block 修饰的外部变量被 Block 捕获时，会创建一个以 __Block_byref_变量名_捕获顺序为变量名的结构体 12345__attribute__((__blocks__(byref))) __Block_byref_b_0 b = {(void*)0,(__Block_byref_b_0 *)&amp;b, 0, sizeof(__Block_byref_b_0), 2};void (*blockDemo)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a, testString, (__Block_byref_b_0 *)&amp;b, (__Block_byref_testString2_1 *)&amp;testString2, 570425344));__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, NSString *_testString, __Block_byref_b_0 *_b, __Block_byref_testString2_1 *_testString2, int flags=0) : a(_a), testString(_testString), b(_b-&gt;__forwarding), testString2(_testString2-&gt;__forwarding) {...} 根据上面的代码,可以得出结构体 __Block_byref_xxx_xx 中的 __forwarding 就是指向这个结构体的地址，同时在结构体的初始化方法中传递的是变量地址的引用，并将这个引用传递给结构体 __main_block_impl_0 中对应的外部变量，因此用 __block 修饰的外部变量是以传址的方式被 Block 捕获的。 OC 的内存管理是基于引用计数的，拷贝到 Block 中的外部变量被结构体 __Block_byref_xxx_xx 的 __forwarding 所引用了，因此需要考虑维护对象的引用计数。 总结最后，以我的话来总结下 Block 具体是什么? Block 是一个结构体指针，初始化方法中接收捕获的外部变量，其中有 __block 修饰则传址，没有则传值， 结构体中的 FuncPtr 属性以函数指针的形式指向一个预定义的匿名函数，在调用时，会把 Block 作为参数传递到预定义的匿名函数中并执行。 That's all 参考 Block Implementation Specification Wiki - Application binary interface 谈Objective-C block的实现 iOS-Runtime-Headers a-look-inside-blocks-episode-3-block-copy How Objective-C handles the memory of immutable strings","link":"/2017/03/26/iOSer-Understand-the-block-next/"},{"title":"理解Block(上)","text":"前言 整理一些概念 环境 Xcode 8.2.1macOS Sierra 10.12.3 是什么 Block objects are a C-level syntactic and runtime feature. They are similar to standard C functions, but in addition to executable code they may also contain variable bindings to automatic (stack) or managed (heap) memory. A block can therefore maintain a set of state (data) that it can use to impact behavior when executed. Block是个C语言级别的语法与运行时特性。它和函数类似,能执行代码,但更重要的是能绑定堆栈中的变量,通过设置这些变量来改变代码的行为。 用在哪 You can use blocks to compose function expressions that can be passed to API, optionally stored, and used by multiple threads. Blocks are particularly useful as a callback because the block carries both the code to be executed on callback and the data needed during that execution. Block常被用在多线程中,在应用开发时,大多数情况下不能因为网络请求而阻塞与用户的交互,待响应返回后,又需要根据响应的结果对页面进行调整。在这种场景下,可以让主线程可以提供一个Block到子线程。 优点 主线程:实现异步,无需关注网络请求的细节部分,只要考虑请求结果对界面的影响,预先做好处理方式。 子线程:负责网络请求,它清楚网络请求何时完成,由它来通知主线程进行页面刷新操作是比较合适的。 而它们的联结点就是Block,主线程提供Block,子线程负责在合适时机调用Block 如果没有Block因为Block和函数类似,用函数来实现回调功能,同时因为OC是面向对象的编程语言,为了能与其他方法交互,更贴近现实情形,写了如下代码 12345678910111213141516171819202122232425262728293031// 主线程 .m 函数定义void completedFunc(NSString *response) { NSLog(@\"Hello %@\",response);}// 函数调用SubViewController *subVC = [[SubViewController alloc] init];[subVC setCompletedFunc:completedFunc];sleep(3); [self.navigationController pushViewController:subVC animated:true];// 子线程.h- (void)setCompletedFunc:(void (NSString *))r;// 子线程.m// 接收函数指针@property (nonatomic,copy) NSString *httpResponse;@property (nonatomic,assign) Response reponser;- (void)setCompletedFunc:(void (NSString *))r { _reponser = r; // ...}// 在合适的时机调用回调方法比如viewDidLoadNSLog(@\"发送网络请求\");// 接收网络请求数据_httpResponse = @\"test,test,test\";// 执行回调_reponser(_httpResponse); 如果用Block方式改写,可以将函数的定义与函数参数的传递结合在一起,和匿名函数差不多,因为主线程中并不关心函数的名称,主要还是其中执行的代码,子线程中是要属性引用来执行,还是直接执行,那是子线程需要考虑的事情。而httpResponse是子线程中的变量,被传递到主线程的函数中进行执行了。因此Block和通知,代理等一样都具有传递数据的能力。 这里所说的子线程和主线程只是为了区分文件,不是说有什么主线程的.m。 怎么写 int是返回值 ^是声明block的语法 myBlock是block*变量的名称,它的值为{return num * multiplier;}* int num是参数名 {return num \\ multiplier;}是block*的内容 Xcode的block代码块提示为:inlineBlock 作属性1@property (nonatomic,copy) void (^responser)(NSString *res); 如果觉得不好看,可以typedef定义一个别名类型 12typedef void (^Responser)(NSString *);@property (nonatomic,copy) Responser req; 作参数123- (void)setReq:(void (^)(NSString *))req { } 123- (void)setReq:(Responser)req { } 作返回值123- (void (^)(NSString *))req { return nil;} 123- (Responser)req { return nil;} Block的类型 属性:是OC的一项特性,用于封装对象中的数据。 原子性([no]atomatic) 读写权限(readwrite/readonly) 内存管理语义(retain,copy,assign,weak,strong,unsafe_unretained) 方法名(getter,setter) strong:为该种属性设置新值时,设置方法会先保留新值并释放旧值,然后再将新值设置上去copy:与strong类似,但是不保留新值,而是将其”拷贝”。当属性类型为NSString时,常用该特质来保护其封装性 详情可以参考书籍Effective Objective C 2.0 第二章第6条 通过这儿的5道题可知 Block可根据存储的区域分为3种类型:NSGlobalBlock,NSStackBlock,NSMallocBlock 123456789101112131415161718192021222324252627282930313233typedef void (^dBlock)();@interface MRCViewController ()@property (nonatomic,copy) dBlock dB;@end@implementation MRCViewController- (void)viewDidLoad { [super viewDidLoad]; dBlock b = ^{ printf(\"666\"); }; NSLog(@\"b=%@\",b); char d = 'D'; printf(\"d的addr:%p\\n\", &amp;d); dBlock b2 = ^{ printf(\"d的addr:%p\\n\", &amp;d); }; NSLog(@\"b2=%@\",b2); self.dB = b2; NSLog(@\"b2=%@\",b2); NSLog(@\"dB=%@\",self.dB); self.dB(); // MRC环境下 dBlock dB2 = [[b2 copy] autorelease]; NSLog(@\"dB2=%@\",dB2); dB2();}... 输出结果为 MRC ARC 目前结论: 不绑定变量时,MRC和ARC*环境下都是NSGlobalBlock类型。 绑定非对象变量的情况下,被绑定的变量都是传值的,在MRC环境下,创建Block默认会存储在栈中,即为NSStackBlock类型,生命周期为函数或方法体内有效,当使用copy修饰的属性对其进行引用或对Block调用copy + autorelease时,将会拷贝一个新的Block到堆中,即为NSMallocBlock类型,生命周期将会被延长。在ARC环境下,~~创建Block默认存储在堆中,即为NSMallocBlock类型~~,当使用copy*修饰的属性对其接收时,因为内存地址没变,所以只进行了浅拷贝。 但是,根据谈Objective-C block的实现中的评论,在ARC环境下照着操作后,输出确实如此。因此又进行了以下的代码测试 123456789id arr;NSLog(@\"%@\", ^(){NSLog(@\"%@\", arr); }); // 如果绑定的不是对象会有影响吗?NSLog(@\"%@\",^{printf(\"d的addr:%p\\n\", &amp;d);}); dBlock b3 = nil;NSLog(@\"%@\",b3 = ^{printf(\"d的addr:%p\\n\", &amp;d);});b3(); 输出结果: 不论Block*绑定的是对象还是非对象数据类型,结果都是一样的,直接输出都是NSStackBlock类型的,但是当进行赋值操作后,在上面的情况下,用b3去接收Block类型时,ARC发现这个Block的生命周期变了,在输出后,依然应该存在,所以对其进行拷贝一份到堆中,因此b3类型变为NSMallocBlock*。 通过b3执行输出的地址,也不是原来的地址了,因为非对象数据类型是传值的,那么如果换成对象,会有不同吗?再分别写了如下测试代码: 123456789NSString *d2 = @\"123\";printf(\"d2的addr%p\\n\",d2);dBlock b4 = ^ { printf(\"d2的addr:%p\\n\", d2);};b4();NSLog(@\"b4=%@\",b4);self.dB = b4;NSLog(@\"dB=%@\",self.dB); MRC环境下输出 ARC环境下输出 可以得到结果,对于对象的绑定在MRC和ARC都只是进行了浅拷贝 现在绑定的是局部变量,如果是对象的属性,会有变化吗? 进行如下代码测试: 123456789@property (nonatomic,strong) NSArray *dBTestArr;self.dBTestArr = @[@\"456\"];printf(\"dBTestArr:%p\",self.dBTestArr);dBlock b5 = ^ { NSLog(@\"dBTestArr:%p\",self.dBTestArr);};b5();NSLog(@\"b5=%@\",b5); MRC环境输出 ARC环境输出 同样也是对变量进行浅拷贝。 如果是静态变量呢,会有变化吗? 代码 123456789static NSArray *dBTestArr2;dBTestArr2 = @[@\"789\"];printf(\"dBTestArr2:%p\\n\",dBTestArr2);dBlock b6 = ^ { NSLog(@\"dBTestArr2:%p\",dBTestArr2);};b6();NSLog(@\"b6=%@\",b6); MRC环境输出 ARC环境输出 变量是浅拷贝的,同时Block*统一都是NSGlobalBlock*,这也很好理解,因为静态变量在内存中是分配在全局区的。 OC没有类属性,但是有关联属性,如果关联到类对象上,用Block进行绑定,会怎么样呢? 代码 123456789#import &lt;objc/message.h&gt;static const char *dBTest3 = \"dbTest3\"; // static const char *dBTest4 = \"dbTest4\";objc_setAssociatedObject([self class], dBTest3, @[@\"0\"], OBJC_ASSOCIATION_RETAIN);printf(\"dBTest3:%p\\n\",objc_getAssociatedObject([self class], dBTest3));dBlock b7 = ^ { NSLog(@\"dBTest3:%p\",objc_getAssociatedObject([self class], dBTest3));};b7();NSLog(@\"b7=%@\",b7); MRC环境 ARC环境 同样也是对变量浅拷贝,MRC*下是NSStackBlock,ARC下是NSMallocBlock* 总结一下,大概如下表: 绑定变量类型 MRC ARC 不绑定 NSGlobalBlock NSGlobalBlock 局部变量 NSStackBlock,copy*属性赋值修饰拷贝一个NSMallocBlock*对象,非对象传值,对象传址 NSStackBlock,赋值后拷贝一个为NSMallocBlock对象,非对象传值,对象传址 属性 NSStackBlock,非对象传值,对象传址 NSStackBlock,赋值后拷贝一个为NSMallocBlock对象,非对象传值,对象传址 静态变量 NSGlobalBlock,变量地址 NSGlobalBlock,变量地址 关联对象 NSStackBlock,对象传址 NSMallocBlock,对象传址 到这里,先停一下,说明两个问题 在5道练习题中的Example B有 12345678910111213void exampleB_addBlockToArray(NSMutableArray *array) { char b = 'B'; [array addObject:^{ printf(\"%cn\", b); }];}void exampleB() { NSMutableArray *array = [NSMutableArray array]; exampleB_addBlockToArray(array); void (^block)() = [array objectAtIndex:0]; block();} 能把Block添加到数组中,那么Block应该是一个对象吧。 在JaviSoto/iOS10-Runtime-Headers工程中,查找发现Block对象的继承关系为 NSStackBlock =&gt; __NSStackBlock =&gt; NSBlock =&gt; NSObjectNSGlobalBlock =&gt; __NSGlobalBlock =&gt; NSBlock =&gt; NSObjectNSMallocBlock =&gt; __NSMallocBlock =&gt; NSBlock =&gt; NSObject 可知OC中的Block确实是一个对象 还有一个小问题就是存在的到底是NSConcreteGlobalBlock,NSConcreteStackBlock,还是NSMallocBlock这种类型的? 在13年发表的,猜测可能苹果对Block应该进行修改了,又根据clang-do 又觉得偏向于NSConcreteGlobalBlock,我暂时认为在底层实际上是NSConcreteGlobalBlock这种的,然后在OC*上表现为NSMallocBlock* __Block123456NSString *d2 = @\"123\";printf(\"d2的addr%p\\n\",d2);dBlock b4 = ^ { printf(\"d2的addr:%p\\n\", d2); d2 = @\"777\";}; 以上代码将会报Variable is not assignable (missing __block type specifier) 为什么呢? 同样根据clang-doc,里面有这样的说明 因为如果变量不用__block修饰,那么默认在拷贝时,会添加const进行修饰 Block的循环引用更新: 170402在 5个动画,理解常用垃圾回收算法的执行过程 中有这样一段话 引用计数算法存在很多问题。最大的一个问题是，它无法解决循环引用问题。这种情况很常见，父对象和反向引用会形成引用环。 原来的先构造一个简单的循环引用 1234@property (nonatomic,copy) dBlock dBCycle;self.dBCycle = ^ { NSLog(@\"%@\",self);}; 正常情况下,self是VC,被导航控制器的viewControllers属性持有,而self持有dBCycle这个Block属性,当pop控制器后,self的引用计数为0,被释放,然后dBCycle计数也为0,也能被顺利释放 在上面的循环引用代码中,当pop控制器后,self被dBCycle属性持有,所以不能被回收,dBCycle指向的Block的内存地址,在执行完Block后,因为它的引用计数还是至少为1(self持有),所以也不会被释放,有点类似死锁的概念,双方互相依赖对象。dealloc方法不会被调用。 知道原理之后,关注一下AFNetworking中的success回调Block 进入 1234- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE; 再进入 12345- (NSURLSessionDataTask *)GET:(NSString *)URLString parameters:(id)parameters progress:(void (^)(NSProgress * _Nonnull))downloadProgress success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure 1234567- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method URLString:(NSString *)URLString parameters:(id)parameters uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress success:(void (^)(NSURLSessionDataTask *, id))success failure:(void (^)(NSURLSessionDataTask *, NSError *))failure 1234567891011121314dataTask = [self dataTaskWithRequest:request uploadProgress:uploadProgress downloadProgress:downloadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) { if (error) { if (failure) { failure(dataTask, error); } } else { if (success) { success(dataTask, responseObject); } } }]; success回调的Block作参数传递到completionHander中 123456789101112131415- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler { __block NSURLSessionDataTask *dataTask = nil; url_session_manager_create_task_safely(^{ dataTask = [self.session dataTaskWithRequest:request]; }); // 添加代理对象 [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; return dataTask;} 传递到 123456789- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler{ AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init]; delegate.manager = self; delegate.completionHandler = completionHandler; ... delegate.completionHandler这block持有了我们传递的success回调的Block delegate被self(AFHTTPSessionManager)对象的mutableTaskDelegatesKeyedByTaskIdentifier属性持有 大致理解如下 AFHTTPSessionManager_Obj.mutableTaskDelegatesKeyedByTaskIdentifier.delegate.completionHandler = ^ { succcess()} 若你在success()中使用了VC的self,因为 12345678910111213141516171819202122232425262728+ (instancetype)manager { return [[[self class] alloc] initWithBaseURL:nil];}- (instancetype)initWithBaseURL:(NSURL *)url { return [self initWithBaseURL:url sessionConfiguration:nil];}- (instancetype)initWithBaseURL:(NSURL *)url sessionConfiguration:(NSURLSessionConfiguration *)configuration{ self = [super initWithSessionConfiguration:configuration]; if (!self) { return nil; } // Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected if ([[url path] length] &gt; 0 &amp;&amp; ![[url absoluteString] hasSuffix:@\"/\"]) { url = [url URLByAppendingPathComponent:@\"\"]; } self.baseURL = url; self.requestSerializer = [AFHTTPRequestSerializer serializer]; self.responseSerializer = [AFJSONResponseSerializer serializer]; return self;} AFHTTPSessionManager_Obj等价于局部变量,当方法执行完后,变量会被释放,紧接着Block执行完后,会被回收,对VC的self持有会被释放,当pop后,self对象也会被释放。 参考 Blocks Programming Topics Effective Objective C 2.0 http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/ 谈Objective-C block的实现 JaviSoto/iOS10-Runtime-Headers clang-doc","link":"/2017/03/03/iOSer-Understand-the-block/"},{"title":"查看.ipa文件的Info.plist","text":"场景 当通过.ipa文件的Info.plist文件去获得应用的配置信息时,若通过视图方式去找到Info.plist文件,感觉略显麻烦,因此决定使用shell脚本来解决该问题 方案look_info.sh123456789101112#!/bin/shtimestamp=$(date +%s)dir=`basename ${1} .ipa`_${timestamp}mkdir ./${dir}cp ${1} ./${dir}/${dir}.zipunzip -d ./${dir}/ ./${dir}/${dir}.zip &gt; /dev/null 2&gt;&amp;1cd ./${dir}/Payload/*.app/plutil -convert xml1 Info.plistcat Info.plist | less 用法1$ ./look_info.sh ./app_name.ipa 效果图 代码 参考 Linux Shell 脚本中字符串的连接方法 gzip和unzip Linux命令-去掉文件名的目录和后缀","link":"/2016/11/30/iOSer-View-the-Info.plist-of-the-.ipa-file/"},{"title":"WKWebView & UIWebView 进度条动画","text":"导语 本文目的是实现一个网络请求进度条的动画效果，主要结构分为以下三个部分 JAProgressWKWebView : 使用 WKWebView 的场景 JAProgressUIWebView : 使用 UIWebView 的场景 JAProgressView : 一般情况下使用 NSURLSession 的场景 环境 macOS Sierra 10.12.4Xcode 8.3.2iPhone 6S (10.1.1)iPad Mini 2 (8.4) WKWebView A WKWebView object displays interactive web content, such as for an in-app browser. You can use the WKWebView class to embed web content in your app. To do so, create a WKWebView object, set it as the view, and send it a request to load web content.ImportantStarting in iOS 8.0 and OS X 10.10, use WKWebView to add web content to your app. Do not use UIWebView or WebView. WKWebView 是 Apple 在 iOS 8 时用于替代 UIWebView 的控件 原理 WKWebView 控件提供了如下的属性,用于描述当前页面的加载进度，采用 KVO 的方式，获得进度值并进行相应的操作。 1234567891011 WKWebView.h /*! @abstract An estimate of what fraction of the current navigation has been completed. @discussion This value ranges from 0.0 to 1.0 based on the total number of bytes expected to be received, including the main document and all of its potential subresources. After a navigation completes, the value remains at 1.0 until a new navigation starts, at which point it is reset to 0.0. @link WKWebView @/link is key-value observing (KVO) compliant for this property. */@property (nonatomic, readonly) double estimatedProgress; 实践 添加观察者 1234567- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration { if (self = [super initWithFrame:frame configuration:configuration]) { [self setup]; [self addObserver:self forKeyPath:JAkEstimatedProgress options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil]; } return self;} 刷新进度 12345- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context { double newKey = [[change objectForKey:NSKeyValueChangeNewKey] doubleValue]; [self.progressBarlayer flush:newKey];} 移除观察者 1234567- (void)dealloc { @try { [self removeObserver:self forKeyPath:JAkEstimatedProgress]; } @catch (NSException *exception) { // NSLog(@\"%@\",exception); }} 使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445#import \"JAWKViewController.h\"#import \"JAProgressView.h\"@interface JAWKViewController () &lt;WKNavigationDelegate&gt;@property (nonatomic,strong) JAProgressWKWebView *webView;@end@implementation JAWKViewController- (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor colorWithWhite:0.92 alpha:1.0]; self.automaticallyAdjustsScrollViewInsets = false; WKWebViewConfiguration *theConfiguration = [[WKWebViewConfiguration alloc] init]; JAProgressWKWebView *webView = [[JAProgressWKWebView alloc] initWithFrame:CGRectMake(0, 64, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height - 64) configuration:theConfiguration]; webView.backgroundColor = [UIColor groupTableViewBackgroundColor]; webView.opaque = false; webView.navigationDelegate = self; [self.view addSubview:_webView = webView]; // [self.navigationController.navigationBar addSubview:webView.progressView];}- (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; NSURL *nsurl=[NSURL URLWithString:self.urlString]; NSURLRequest *nsrequest=[NSURLRequest requestWithURL:nsurl]; [_webView loadRequest:nsrequest];}- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation { NSLog(@\"加载完成\");}- (void)webView:(WKWebView *)webView didFailNavigation:(WKNavigation *)navigation withError:(NSError *)error { NSLog(@\"加载失败\"); [_webView finish];}- (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning];}@end UIWebView You can use the UIWebView class to embed web content in your app. To do so, create a UIWebView object, attach it to a window, and send it a request to load web content. You can also use this class to move back and forward in the history of webpages, and you can even set some web content properties programmatically.NoteIn apps that run in iOS 8 and later, use the WKWebView class instead of using UIWebView. Additionally, consider setting the WKPreferences property javaScriptEnabled to NO if you render files that are not supposed to run JavaScript. 原理 先叉开一下话题，看看造好的轮子是如何实现检测网络进度的。下面以 AFNetworking 为例进行说明 在 AFN 中有一个 UIWebView+AFNetworking.h 文件，是为 UIWebView 添加的分类，里面有 1234- (void)loadRequest:(NSURLRequest *)request progress:(NSProgress * _Nullable __autoreleasing * _Nullable)progress success:(nullable NSString * (^)(NSHTTPURLResponse *response, NSString *HTML))success failure:(nullable void (^)(NSError *error))failure; 最终调用的是调用了下面的方法 123456- (void)loadRequest:(NSURLRequest *)request MIMEType:(nullable NSString *)MIMEType textEncodingName:(nullable NSString *)textEncodingName progress:(NSProgress * _Nullable __autoreleasing * _Nullable)progress success:(nullable NSData * (^)(NSHTTPURLResponse *response, NSData *data))success failure:(nullable void (^)(NSError *error))failure; 关注 progress 参数，要求传递的是一个 progress 对象的地址 1234567NSURLSessionDataTask *dataTask;...self.af_URLSessionTask = dataTask;if (progress != nil) { *progress = [self.sessionManager downloadProgressForTask:dataTask];}[self.af_URLSessionTask resume]; 顾名思义 progress 会接收 downloadProgressForTask: 方法的返回值，即本次请求的进度 进到 downloadProgressForTask: 方法中 123- (NSProgress *)downloadProgressForTask:(NSURLSessionTask *)task { return [[self delegateForTask:task] downloadProgress];} 查看 downloadProgress 属性在哪个类中 123@interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;...@property (nonatomic, strong) NSProgress *downloadProgress; 在文件中以 downloadProgress 进行搜索会发现 12345678910111213141516171819202122#pragma mark - NSProgress Tracking- (void)setupProgressForTask:(NSURLSessionTask *)task { __weak __typeof__(task) weakTask = task;... [task addObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived)) options:NSKeyValueObservingOptionNew context:NULL]; [task addObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive)) options:NSKeyValueObservingOptionNew context:NULL];... [self.downloadProgress addObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted)) options:NSKeyValueObservingOptionNew context:NULL];... 找到响应的方法 12345678910111213- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context { if ([object isKindOfClass:[NSURLSessionTask class]] || [object isKindOfClass:[NSURLSessionDownloadTask class]]) { if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) { self.downloadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]) { self.downloadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) { self.uploadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]) { self.uploadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; } } ... 进度的计算是根据 NSURLSession 的两个只读的属性 countOfBytesReceived &amp; countOfBytesExpectedToReceive ，前者是已接收到的数据长度，后者是期望接收到的总长度，来自于 Http 头中的 Content-Length 字段，通过接收这两个值的变化对应去修改 NSProgress 中的 completedUnitCount &amp; totalUnitCount 这两个值 123456/* The size of the job whose progress is being reported, and how much of it has been completed so far, respectively. For an NSProgress with a kind of NSProgressKindFile, the unit of these properties is bytes while the NSProgressFileTotalCountKey and NSProgressFileCompletedCountKey keys in the userInfo dictionary are used for the overall count of files. For any other kind of NSProgress, the unit of measurement you use does not matter as long as you are consistent. The values may be reported to the user in the localizedDescription and localizedAdditionalDescription. If the receiver NSProgress object is a \"leaf progress\" (no children), then the fractionCompleted is generally completedUnitCount / totalUnitCount. If the receiver NSProgress has children, the fractionCompleted will reflect progress made in child objects in addition to its own completedUnitCount. As children finish, the completedUnitCount of the parent will be updated.*/@property int64_t totalUnitCount;@property int64_t completedUnitCount; fractionCompleted 属性是根据 completedUnitCount / totalUnitCount 得到的。 因此很自然的一种思路是去监听传递的 progress 参数的 fractionCompleted 再此之前先设断点证明下确实走了 setupProgressForTask: 同时因为 AFURLSessionManagerTaskDelegate 并没有暴露给外部，不去修改框架比较好 KVO 是一对多的，也算比较合适。 可添加类似如下的代码对 progress 参数的 fractionCompleted 属性进行观察 123456789101112131415161718- (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; NSURL *nsurl=[NSURL URLWithString:self.urlString]; NSURLRequest *nsrequest=[NSURLRequest requestWithURL:nsurl]; NSProgress *progress = [[NSProgress alloc] init]; [_webView loadRequest:nsrequest progress:&amp;progress success:^NSString * _Nonnull(NSHTTPURLResponse * _Nonnull response, NSString * _Nonnull HTML) { return @\"\"; } failure:^(NSError * _Nonnull error) { }]; [progress addObserver:_webView forKeyPath:@\"fractionCompleted\" options:NSKeyValueObservingOptionNew context:NULL];}#pragma mark - UIWebViewDelegate- (void)webViewDidFinishLoad:(UIWebView *)webView { NSLog(@\"加载完成\");} 但是会发现 _webView 对象中的方法 123456789- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context { dispatch_async(dispatch_get_main_queue(), ^{ double newKey = [[change objectForKey:NSKeyValueChangeNewKey] doubleValue]; [self.progressBarlayer flush:newKey]; if (1 - newKey &lt; 0.01) { [self finish]; } });} 并没有被执行，跟踪 AFNetowrking progress 的 fractionCompleted 一直都为 0 因为 countOfBytesExpectedToReceive 的总长度是 -1 (0xffffffffffffffff) 这一点可以在 issues - Progress and KVO never called 得到佐证，主要是因为请求头的 Content-Length 字段未设置。 访问 https://www.baidu.com 123456789101112131415161718192021220x0000000000000b6d2925(lldb) po dataTask.response&lt;NSHTTPURLResponse: 0x174030160&gt; { URL: https://www.baidu.com/ } { status code: 200, headers { Connection = \"keep-alive\"; \"Content-Encoding\" = gzip; \"Content-Type\" = \"text/html\"; Date = \"Sat, 13 May 2017 09:14:00 GMT\"; P3p = \"CP=\\\" OTI DSP COR IVA OUR IND COM \\\"\"; Server = \"bfe/1.0.8.18\"; \"Set-Cookie\" = \"BAIDUID=623A610A25264EC09CC77FECD44A7CE4:FG=1; max-age=31536000; expires=Sun, 13-May-18 09:14:00 GMT; domain=.baidu.com; path=/; version=1, H_WISE_SIDS=102431; path=/; domain=.baidu.com, BDSVRTM=9; path=/, __bsi=13135479753770821857_00_33_N_N_11_0303_C02F_N_N_Y_0; expires=Sat, 13-May-17 09:14:05 GMT; domain=www.baidu.com; path=/\"; Traceid = 149466684009534243944441198276626132688; \"Transfer-Encoding\" = Identity; Vary = \"Accept-Encoding\";} }(lldb) po dataTask.countOfBytesExpectedToReceive2925(lldb) 访问 https://www.bing.com 123456789101112131415161718192021220xffffffffffffffff-1(lldb) po dataTask.response&lt;NSHTTPURLResponse: 0x17022c6c0&gt; { URL: https://www.bing.com/ } { status code: 200, headers { \"Cache-Control\" = \"private, max-age=0\"; \"Content-Encoding\" = gzip; \"Content-Length\" = 32317; \"Content-Type\" = \"text/html; charset=utf-8\"; Date = \"Sat, 13 May 2017 09:16:11 GMT\"; P3P = \"CP=\\\"NON UNI COM NAV STA LOC CURa DEVa PSAa PSDa OUR IND\\\"\"; Server = \"Microsoft-IIS/10.0\"; \"Set-Cookie\" = \"_SS=SID=3C3C051FE4516B5A18710F9EE5F06A6F; domain=.bing.com; path=/, _EDGE_S=SID=3C3C051FE4516B5A18710F9EE5F06A6F; path=/; httponly; domain=bing.com\"; Vary = \"Accept-Encoding\"; \"X-MSEdge-Ref\" = \"Ref A: 0505C24953B941CA96CF74FAE726B298 Ref B: BJ1EDGE0322 Ref C: Sat May 13 02:16:11 2017 PST\";} }(lldb) po dataTask.countOfBytesExpectedToReceive-1(lldb) 访问 https://www.google.com 123456789101112131415161718192021220xffffffffffffffff-1(lldb) po dataTask.response&lt;NSHTTPURLResponse: 0x170033180&gt; { URL: https://www.google.com/ } { status code: 200, headers { \"Alt-Svc\" = \"quic=\\\":443\\\"; ma=2592000; v=\\\"37,36,35\\\"\"; \"Cache-Control\" = private; \"Content-Encoding\" = gzip; \"Content-Type\" = \"text/html; charset=Big5\"; Date = \"Sat, 13 May 2017 09:24:46 GMT\"; Expires = \"Sat, 13 May 2017 09:24:46 GMT\"; P3P = \"CP=\\\"This is not a P3P policy! See https://www.google.com/support/accounts/answer/151657?hl=en for more info.\\\"\"; Server = gws; \"Set-Cookie\" = \"NID=103=adCbLI6_cKax8zD5WTTC6Xq-Vviron4fGJDZeVf1OEiQhvSD9L3Q53n8HrmZS8--BUJIIAbR_cb5UwweP0nvyOKD0J4tbOLf6tr-p_Vva5mnAiYyWKKzsOhqtc9SjBhW; expires=Sun, 12-Nov-2017 09:24:46 GMT; path=/; domain=.google.com; HttpOnly\"; \"Transfer-Encoding\" = Identity; \"X-Frame-Options\" = SAMEORIGIN; \"X-XSS-Protection\" = \"1; mode=block\";} }(lldb) po dataTask.countOfBytesExpectedToReceive-1 第二次 1234567891011121314151617181920212223242526270x0000000000002ae7- Hook 1 (expr -- @import UIKit)- Hook 2 ( target stop-hook disable)10983(lldb) po dataTask.response&lt;NSHTTPURLResponse: 0x17003cd60&gt; { URL: https://www.google.com/ } { status code: 200, headers { \"Alt-Svc\" = \"quic=\\\":443\\\"; ma=2592000; v=\\\"37,36,35\\\"\"; \"Cache-Control\" = private; \"Content-Encoding\" = gzip; \"Content-Type\" = \"text/html; charset=Big5\"; Date = \"Sat, 13 May 2017 10:09:01 GMT\"; Expires = \"Sat, 13 May 2017 10:09:01 GMT\"; P3P = \"CP=\\\"This is not a P3P policy! See https://www.google.com/support/accounts/answer/151657?hl=en for more info.\\\"\"; Server = gws; \"Set-Cookie\" = \"NID=103=f7RScaRo91vaPuGoStsjYJrDLUSANq6fwzBypLCvMeUasdsx443kwCfnzioj167ke0Buh6c6qVsA_xiT8olCjCvOtOd4P9drblpB5PkDMGiWg0J6qJnBuhoeFQIREDVT; expires=Sun, 12-Nov-2017 10:09:01 GMT; path=/; domain=.google.com; HttpOnly\"; \"Transfer-Encoding\" = Identity; \"X-Frame-Options\" = SAMEORIGIN; \"X-XSS-Protection\" = \"1; mode=block\";} }(lldb) po dataTask.countOfBytesExpectedToReceive10983 名称 Content-Length countOfBytesExpectedToReceive https://www.baidu.com ❎ ✔️ https://www.bing.com ✔️ ❎ https://www.google.com ❎ ❎ / ✔️ 搜索 Content-Length 字段的相关内容 rfc2616.html#header.content-length rfc2616.html#message.length 在 HTTP 1.1 中应用可以通过 Content-Lenght 字段确定消息的长度， Content-Length 失效的几种情况 状态码为 1xx,204 和 304 设置了 Transfer-Encoding 且该值不等于 identity 同时存在 Transfer-Encoding 和 Content-Length 响应的数据类型为 multipart/byteranges 且没有指定 transfer-length 服务器关闭连接 在 这里 1、在Http 1.0及之前版本中，content-length字段可有可无。2、在http1.1及之后版本。如果是keep alive，则content-length和chunk必然是二选一。若是非keep alive，则和http1.0一样。content-length可有可无。 Transfer-Encoding 用来指定数据传输的格式，有如下的格式 Transfer-Encoding: chunkedTransfer-Encoding: compressTransfer-Encoding: deflateTransfer-Encoding: gzipTransfer-Encoding: identity chunked 的格式详情可以参考 Wiki-分块传输编码 如果一个HTTP消息（请求消息或应答消息）的Transfer-Encoding消息头的值为chunked，那么，消息体由数量未定的块组成，并以最后一个大小为0的块为结束。每一个非空的块都以该块包含数据的字节数（字节数以十六进制表示）开始，跟随一个CRLF （回车及换行），然后是数据本身，最后块CRLF结束。在一些实现中，块大小和CRLF之间填充有白空格（0x20）。最后一块是单行，由块大小（0），一些可选的填充白空格，以及CRLF。最后一块不再包含任何数据，但是可以发送可选的尾部，包括消息头字段。消息最后以CRLF结尾。 但是到这里依然没完全解决我的困惑，在 iOS 中如何比较获得网络请求的总长度？ 寻找头文件后发现，在 NSURLResponse 对象中 1234567891011121314/*! @method expectedContentLength @abstract Returns the expected content length of the receiver. @discussion Some protocol implementations report a content length as part of delivering load metadata, but not all protocols guarantee the amount of data that will be delivered in actuality. Hence, this method returns an expected amount. Clients should use this value as an advisory, and should be prepared to deal with either more or less data. @result The expected content length of the receiver, or -1 if there is no expectation that can be arrived at regarding expected content length.*/@property (readonly) long long expectedContentLength; 我的方案 经过测试,在 NSURLSessionDataDelegate 的代理方法URLSession:dataTask:didReceiveData: , data 即为每次获取的数据,而 dataTask 中的 response 属性的 expectedContentLength 有时会在数据并没有完全接收到时就可以获得长度,因此对 UIWebView 用这个值来获取网络请求进度,采用的主要思路是 在未获得 expectedContentLength 长度时，用数组保存每次 data 的值 获取到 expectedContentLength ， 根据数组中的值算出进度，在本地实现动画。 网络请求暂时决定还是依赖 AFNetworking , 添加了一个分类，在运行时替换 URLSession:dataTask:didReceiveData: 方法来实现 实践 分类 AFHTTPSessionManager+JACoder.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#import \"AFHTTPSessionManager+JACoder.h\"#import &lt;objc/message.h&gt;NSString *kAFJAReceiveDataNotification = @\"kAFNReceiveDataNotification\";NSString *kAFJAReceiveResponseNotification = @\"kAFJAReceiveResponseNotification\";@implementation AFHTTPSessionManager (JACoder)+ (void)load { Method originalMethod = class_getInstanceMethod(self, @selector(URLSession:dataTask:didReceiveData:)); Method swizzledMethod = class_getInstanceMethod(self, @selector(ja_URLSession:dataTask:didReceiveData:)); BOOL didAddMethod = class_addMethod(self, @selector(URLSession:dataTask:didReceiveData:), method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) { class_replaceMethod(self, @selector(ja_URLSession:dataTask:didReceiveData:), method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { method_exchangeImplementations(originalMethod, swizzledMethod); }}- (void)ja_URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data { [self ja_URLSession:session dataTask:dataTask didReceiveData:data]; // ... if (dataTask.response.expectedContentLength != -1 &amp;&amp; self.isLock == false) {// NSLog(@\"data = %ld\",data.length);// NSLog(@\"dataTask = %lld\",dataTask.response.expectedContentLength); [[NSNotificationCenter defaultCenter] postNotificationName:kAFJAReceiveDataNotification object:data]; [[NSNotificationCenter defaultCenter] postNotificationName:kAFJAReceiveResponseNotification object:dataTask]; self.lock = true; }else { // NSLog(@\"data = %ld\",data.length); [[NSNotificationCenter defaultCenter] postNotificationName:kAFJAReceiveDataNotification object:data]; }}- (BOOL)isLock { return (BOOL)[objc_getAssociatedObject(self, @selector(isLock)) doubleValue];}- (void)setLock:(BOOL)lock { objc_setAssociatedObject(self, @selector(setLock:), @(lock), OBJC_ASSOCIATION_ASSIGN);}@end 接收到已获取总长度的通知后的相应处理,为了和 WKWebView 统一，在继承 UIWebView 的子类中添加了 estimatedProgress 属性，同样用 KVO 去处理。 1234567891011121314151617181920212223242526272829303132333435363738- (void)receiveWithNotification:(NSNotification *)noti { if ([noti.object isKindOfClass:[NSURLSessionDataTask class]]) { NSURLSessionDataTask *dataTask = (NSURLSessionDataTask *)noti.object; self.expectedContentLength = dataTask.response.expectedContentLength; if (self.estimatedProgress == 0 ) { if (self.records.count == 0) { self.estimatedProgress = 1.0; }else { for (NSData *record in self.records) { self.estimatedProgress += (CGFloat)record.length / self.expectedContentLength; } self.records = [NSArray array]; } }else { for (NSData *record in self.records) { self.estimatedProgress += (CGFloat)record.length / self.expectedContentLength; } } // NSLog(@\"noti dataTask:%f\",self.estimatedProgress); } if ([noti.object isKindOfClass:[NSData class]]) { NSData *data = (NSData *)noti.object; if (self.expectedContentLength != -1 &amp;&amp; self.expectedContentLength != 0) { for (NSData *record in self.records) { self.estimatedProgress += (CGFloat)record.length / self.expectedContentLength; } self.estimatedProgress += (CGFloat)data.length / self.expectedContentLength; // NSLog(@\"noti data:%f\",self.estimatedProgress); self.records = [NSArray array]; }else { NSMutableArray *recordsM = [NSMutableArray arrayWithArray:self.records]; [recordsM addObject:data]; self.records = [recordsM copy]; } }} estimatedProgress 属性变化的处理 123456789- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context { dispatch_async(dispatch_get_main_queue(), ^{ double newKey = [[change objectForKey:NSKeyValueChangeNewKey] doubleValue]; [self.progressBarlayer flush:newKey]; if (1 - newKey &lt; 0.01) { [self finish]; } });} UIView 对于一般的 App 请求,大多都是返回 JSON 数据的接口,也可以做一个进度条的效果。 原理 一事不烦二主，也用 AFNetworking 做请求。上面已经分析了 AFNetworking 如何检测请求进度的, 大多数情况下的请求进度肯定是没问题的。 实践 用 AFNetworking 发起请求，根据回调返回的 NSProgress 值实现刷新操作。 12345678910111213141516171819202122232425262728293031323334353637383940#import \"JAUIViewController.h\"#import &lt;AFNetworking.h&gt;#import \"JAProgressView.h\"@interface JAUIViewController ()@property (nonatomic,strong) JAProgressView *progressView;@end@implementation JAUIViewController- (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor colorWithWhite:0.92 alpha:1.0]; _progressView = [[JAProgressView alloc] init]; [self.navigationController.navigationBar addSubview:_progressView];}- (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; [[AFHTTPSessionManager manager] GET:@\"http://api.map.baidu.com/telematics/v3/weather?location=%E5%98%89%E5%85%B4&amp;output=json&amp;ak=5slgyqGDENN7Sy7pw29IUvrZ\" parameters:nil progress:^(NSProgress * _Nonnull downloadProgress) { dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ [_progressView flush:downloadProgress.fractionCompleted]; }); // or // [[NSNotificationCenter defaultCenter] postNotificationName:JAEstimatedProgressNotification object:downloadProgress]; } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { }];}- (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning];} 相应的处理 1234567891011121314// 通知- (void)receiveWithNotification:(NSNotification *)notifcation { dispatch_async(dispatch_get_main_queue(), ^{ if ([notifcation.object isKindOfClass:[NSProgress class]]) { NSProgress *progress = (NSProgress *)notifcation.object; [self.progressBarlayer flush:progress.fractionCompleted]; } });}// 传值- (void)flush:(CGFloat)progress { [self.progressBarlayer flush:progress];} 效果图 DEMO 参考 Progress and KVO never called Wiki-分块传输编码 MDN - Transfer-Encoding http协议中content-length 以及chunked编码分析","link":"/2017/05/13/iOSer-WKWebView-UIWebView-progress-monitoring/"},{"title":"Xcode8-插件失效","text":"前言 Xcode8 出于安全原因,禁止了第三方插件,改为 Xcode Source Editor &lt; Xcode81$ find ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add $ find ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add IDE常用插件 VVDocument 文档注释 , Xcode8 已支持 ⌥ + ⌘ + / MCLog 输出日志过滤, Xcode8 已支持 ActivatePowerMode 打字酷炫效果 Xcode8上使用第三方插件“解决方案” 参考 Xcode 8 won’t load plug-ins Using and Extending the Xcode Source Editor","link":"/2016/11/20/iOSer-Xcode8-plugin-is-invalid/"},{"title":"iOS远程推送总结","text":"内容概要 远程推送的原理远程推送证书格式及其转换(.pem/.p12)远程推送证书的制作流程实例与环境 远程推送的原理官方文档 A remote notification, also called a push notification, arrives from outside the device. It originates on a remote server that you manage—the app’s notification provider—and is pushed to your app on a user’s device via the Apple Push Notification service (APNs). 远程推送是基于APNs(苹果推送服务) 问题① APNs为什么能远程推送?② APNs怎么知道要推送给哪个设备的哪个应用? APNs uses a persistent IP connection for implementing remote notifications. Apple Push Notification service (APNs) propagates remote notifications to devices having apps registered to receive those notifications. Each app on a device establishes an accredited and encrypted IP connection with the service and receives notifications over this persistent connection. With a TLS connection established between the device and APNs, APNs can then provide an app-specific device token to each app that registers for remote notifications. 答案① 存在一个长连接② 设备上的每个app都可建立一个加密的许可ip用于连接与接收远程推送(deviceToken) 原理图更详细的步骤(来自互联网) 设备上的应用连接APNs服务器 APNs服务器接收到请求生成deviceToken加密后返回给设备 设备上应用获得deviceToken后上报给应用服务器 应用服务器调用APNs的API并发送 deviceToken(Each notification that your provider sends to APNs must include the device token) APNs服务器根据deviceToken将消息推送给指定设备的具体应用 Device tokens can change after updating the operating system, and always change when a device’s data and settings are eraseddeviceToken在更新系统和重新安装(先删除)会被更新 远程推送证书格式及其转换 从上图可知应用服务器与APNs会有一个TLS认证,在申请证书时,提到了使用CSR获得SSL证书,我们先来了解其他一些相关的概念 SSL/TLS传输层安全协议（英语：Transport Layer Security，缩写：TLS），及其前身安全套接层（Secure Sockets Layer，缩写：SSL）是一种安全协议，目的是為网络通信，提供安全及数据完整性保障。 1.协商加密协议 1.1 客户端生成随机数RNc发送client_hello,包含客户端支持的协议,支持的压缩算法等 1.2 服务器接收到client_hello,并随机生成一个RNs,发送server_hello,包含服务器支持的协议,支持的压缩算法等(如果浏览器与服务器支持的版本不一致，服务器关闭加密通信) 1.3 客户端收到RNs,准备进入证书交换阶段 2.证书交换 2.1 服务器发送公钥,并要求客户端返回其公钥 2.2 客户端收到服务器的公钥,并检查其证书的有效性,颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等 2.3 客户端验证证书合法后将发送自己的公钥,并hash处理以前的消息,最后用私钥签名加密发送给服务器 2.4 服务器使用客户端的公钥解密并采用相同的hash算法验证 2.5 客户端生成随机PMS(pre-master-secrect:一个用在对称加密密钥产生中的46位元組的乱数字),并用服务器的公钥加密发送给服务器 2.6 双方各自使用MS,RNc,RNs去创建一个MS作为主密钥 3.对称密钥的数据传输保密 3.1 客户端通知服务器使用MS做key加密 3.2 服务器通知客户端使用MS做key加密 结果可能使用Diffie-Hellman交换,或简化的公钥加密,双方各自用私钥解密。所有其他关键数据均使用MS加密Wiki 在了解SSL的过程中,我们又碰到了RSA,X509等概念,下面依次解释 RSARSA加密算法是现在世界上运用最广泛的非对称加密算法，比如常用的https协议、银行交易等等 非对称加密算法 非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。 用途1:公钥加密 甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。 用途2:数字签名 另一方面，甲方可以使用乙方的公钥对机密信息进行签名后再发送给乙方；乙方再用自己的私匙对数据进行验签。 X509一种证书标准,主要定义了证书中应该包含哪些内容 参考RFC5280 SSL使用的就是这种证书标准,该标准有两种编码格式(PEM和DER) PEMPEM - Privacy Enhanced Mail,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是BASE64编码.查看PEM格式证书的信息:openssl x509 -in certificate.pem -text -nooutApache和*NIX服务器偏向于使用这种编码格式. DERDER - Distinguished Encoding Rules,打开看是二进制格式,不可读.查看DER格式证书的信息:openssl x509 -in certificate.der -inform der -text -nooutJava和Windows服务器偏向于使用这种编码格式. 让我们重新理解证书申请的过程(数字证书)1.从钥匙串中导出CSR文件,包含公钥及其他一些信息,Apple开发者中心进行签名后,生成.cer文件,这是一个数字证书的签名过程2.在导出CSR文件时,除了公钥上传给Apple开发者中心,钥匙串中还存在私钥,在双击时,通过私钥去匹配签名证书中的公钥,一个数字证书的签名与验签就完成了 .p12Personal Information Exchange Syntax Standard See RFC 7292. Defines a file format commonly used to store private keys with accompanying public key certificates, protected with a password-based symmetric key. PFX is a predecessor to PKCS #12.This container format can contain multiple embedded objects, such as multiple certificates. Usually protected/encrypted with a password. Usable as a format for the Java key store and to establish client authentication certificates in Mozilla Firefox. Usable by Apache Tomcat. 从中可以获知p12文件(个人信息交换标准),包含了私钥和与之相关的公钥证书,有密码作保护 从钥匙串中将.p12文件导出并上传到极光服务器,因为证书的颁发机构就是Apple,在检测证书是否合法当然没有问题,自然也可以与Apple的APNs服务器建立TLS通信 .pem多用于*NIX服务器.cer, .crt, .der – usually in binary DER form这些后缀名的文件一般格式都为DER从Apple开发者中心下载的证书就是.cer格式的.pem与.cer/.crt的不同就是它是用base64编码来表示的,而那两个都是用DER格式编码的 验证.cer文件 123456789101112$ openssl x509 -in aps-3.cer -inform der -text -nooutCertificate: Data: Version: 3 (0x2) Serial Number: 21:91:22:78:63:a2:3a:8c Signature Algorithm: sha256WithRSAEncryption Issuer: C=US, O=Apple Inc., OU=Apple Worldwide Developer Relations, CN=Apple Worldwide Developer Relations Certification Authority Validity Not Before: Oct 24 06:26:06 2016 GMT Not After : Nov 23 06:26:06 2017 GMT ... 证明从Apple开发者中心下载的推送证书是用X.509中的DER格式编码的 格式转换PEM–p12(PEM–PKCS#12) 12$ openssl pkcs12 -export -out Cert.p12 -in Cert.pem -inkey key.pem PFX/p12–CER/DER(PKCS#12–CER/DER) 123$ openssl pkcs12 -in certificate.p12 -out certificate.cer如无需加密pem中私钥，可以添加选项-nodes；如无需导出私钥，可以添加选项-nokeys; CER/DER–PEM(编码DER–BASE64) 1$ openssl x509 -inform der -in certificate.cer -out certificate.pem 应用服务器和APNs服务器通过TLS建立信任已经说明了,顺便提一下设备和APNs服务器的信任过程 Trust between APNs and each device is established automatically by iOS upon initial device activation (and without participation by your app), as described in this section. Each device has a cryptographic certificate and a private cryptographic key, obtained at initial device activation and stored in the device’s keychain. During activation, APNs uses the certificate and key to validate the device’s connection using peer-to-peer authentication 大体上也是APNs服务器发送公钥证书,然后系统验证证书,通过后发送设备证书,两者建立信任 证书制作 登陆Apple开发者中心 创建AppId 使用钥匙串导出.certSigningRequest文件 创建 &amp;&amp; 下载推送证书(.cer文件) 只要有开发者账号,创建基本没什么问题,具体的截图流程可参考 极光 .certSigningRequest A CSR or Certificate Signing request is a block of encoded text that is given to a Certificate Authority when applying for an SSL Certificate CSR或证书签名请求是我们申请SSL证书时给予认证机构的表明身份的一段文本 实例与环境本地服务器 [参考教程]效果图: 推送证书相关处理 p12 钥匙串导出 pem 将下载的.cer文件导出为.pem格式的文件 将钥匙串中的p12文件中的私钥导出为.pem格式的文件 合并两个文件 1234$ openssl x509 -in 证书名字.cer -inform der -out push_distribution_cer.pem// man pkcs12 可知-nocerts 即 no certificates at all will be output.$ openssl pkcs12 -nocerts -out pushKey.pem -in p12名字.p12$ cat 下载证书生成的.pem p12生成的.pem &gt; 最终证书的名字.pem 测试证书的有效性1234生产环境 openssl s_client -connect gateway.push.apple.com:2195 -cert 下载证书生成的.pem -key p12生成的.pem开发环境时服务器地址: gateway.sandbox.push.apple.com:2195 将合并后的证书文件拷贝到本地服务器的合适目录,后面会用到 PHPrecv.php 负责接收从客户端上报的deviceToken12345678&lt;?php $myfile = fopen(\"testfile.txt\", \"w\") or die(\"Unable to open file!\"); $deviceToken = $_GET['deviceToken']; $result = [\"deviceToken\" =&gt; $deviceToken]; echo json_encode($result); fwrite($myfile,$deviceToken); fclose($myfile);?&gt; RemotePush.php 负责与APNs服务器交互,实现推送1234567891011121314151617181920212223242526272829303132333435&lt;?php $filename = \"testfile.txt\"; $myfile = fopen($filename, \"r\") or die(\"Unable to open file!\"); $contents = fread($myfile, filesize($filename)); $deviceToken= $contents; $body = array(\"aps\" =&gt; array(\"alert\" =&gt; '推送的内容',\"badge\" =&gt; 1,\"sound\"=&gt;'default')); //推送方式，包含内容和声音 $ctx = stream_context_create(); //如果在Windows的服务器上，寻找pem路径会有问题，路径修改成这样的方法： //$pem = dirname(__FILE__) . '/' . 'apns-dev.pem'; //linux 的服务器直接写pem的路径即可 stream_context_set_option($ctx,\"ssl\",\"local_cert\",\"remote.pem\"); $pass = 'Apple123#@!'; stream_context_set_option($ctx, 'ssl', 'passphrase', $pass); //此处有两个服务器需要选择，如果是开发测试用，选择第二名sandbox的服务器并使用Dev的pem证书，如果是正是发布，使用Product的pem并选用正式的服务器 $fp = stream_socket_client(\"ssl://gateway.push.apple.com:2195\", $err, $errstr, 60, STREAM_CLIENT_CONNECT, $ctx); // $fp = stream_socket_client(\"ssl://gateway.sandbox.push.apple.com:2195\", $err, $errstr, 60, STREAM_CLIENT_CONNECT, $ctx); if (!$fp) { echo \"Failed to connect $err $errstrn\"; return; } print \"Connection OK\\n\"; $payload = json_encode($body); //这边可以弄一个循环实现多个deviceToken 值,这里暂用一个token值得方法 $msg = chr(0) . pack(\"n\",32) . pack(\"H*\", str_replace(' ', '', $deviceToken)) . pack(\"n\",strlen($payload)) . $payload; echo \"sending message :\" . $payload .\"\\n\"; fwrite($fp, $msg); fclose($fp);?&gt; iOS客户端AppDelegate.mimport iOS10特有的UserNotification框架 123#ifdef NSFoundationVersionNumber_iOS_9_x_Max#import &lt;UserNotifications/UserNotifications.h&gt;#endif 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { if ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 10.0) { //iOS10特有 UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter]; // 必须写代理，不然无法监听通知的接收与点击 center.delegate = self; [center requestAuthorizationWithOptions:(UNAuthorizationOptionAlert | UNAuthorizationOptionBadge | UNAuthorizationOptionSound) completionHandler:^(BOOL granted, NSError * _Nullable error) { if (granted) { // 点击允许 NSLog(@\"注册成功\"); [center getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) { NSLog(@\"%@\", settings); }]; } else { // 点击不允许 NSLog(@\"注册失败\"); } }]; }else if ([[UIDevice currentDevice].systemVersion doubleValue] &gt;= 8.0) { // 1.注册UserNotification,以获取推送通知的权限 UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeSound | UIUserNotificationTypeAlert | UIUserNotificationTypeBadge categories:nil]; [application registerUserNotificationSettings:settings]; // 2.注册远程推送 [application registerForRemoteNotifications]; } else { //iOS8之前,注册远程推送的方法 [application registerForRemoteNotificationTypes:UIRemoteNotificationTypeNewsstandContentAvailability | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeSound]; } return YES;}// 获得deviceToken成功- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken { NSString *deviceTokenStr = [[NSString stringWithFormat:@\"%@\",deviceToken] stringByReplacingOccurrencesOfString:@\" \" withString:@\"\"]; deviceTokenStr = [deviceTokenStr substringWithRange:NSMakeRange(1, deviceTokenStr.length - 2 )]; // [[[UIAlertView alloc] initWithTitle:@\"deviceToken\" message:deviceTokenStr delegate:nil cancelButtonTitle:@\"取消\" otherButtonTitles:nil] show]; NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLSession *session = [NSURLSession sessionWithConfiguration:config]; NSString *path = [NSString stringWithFormat:@\"http://192.168.198.104/~Jason/remotePush/recv.php?deviceToken=%@\",deviceTokenStr]; // NSLog(@\"%@\",deviceTokenStr); NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:path]]; [[session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { if (!error) { NSDictionary *result = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil]; NSLog(@\"成功:%@\",result); } }] resume];}// 获得Device Token失败- (void)application:(UIApplication *)applicationdidFailToRegisterForRemoteNotificationsWithError:(NSError *)error { NSLog(@\"did Fail To Register For Remote Notifications With Error: %@\", error);} Xcode配置 推送测试123456Warning: stream_socket_client(): SSL operation failed with code 1. OpenSSL Error messages:error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed in /Users/Jason/Sites/remotePush/remotePush.php on line 19Warning: stream_socket_client(): Failed to enable crypto in /Users/Jason/Sites/remotePush/remotePush.php on line 19Warning: stream_socket_client(): unable to connect to ssl://gateway.sandbox.push.apple.com:2195 (Unknown error) in /Users/Jason/Sites/remotePush/remotePush.php on line 19 google后发现可能是mac OS Sierra的原因 解决方案123451. 升级openssl [可选]2. php -r \"print_r(openssl_get_cert_locations());\"3. wget http://curl.haxx.se/ca/cacert.pem // 移动到2中输出的default_cert_file中4. sudo mv cacert.pem /usr/local/libressl/etc/ssl/cert.pem 终端推送1234$ php remotePush.phpConnection OKsending message :{\"aps\":{\"alert\":\"\\u63a8\\u9001\\u7684\\u5185\\u5bb9\",\"badge\":1,\"sound\":\"default\"}} 其他脚本PushMeBabypushtry网站 环境 macOS Sierra Version 10.12(16A323)Version 8.0 (8A218a)iPhone 6s 9.3.1 参考 What is a CSR (Certificate Signing Request)? Wiki-PKCS HTTPS的工作原理 Get Apache, MySQL, PHP and phpMyAdmin working on macOS Sierra 传输层安全协议 About Local and Remote Notifications - Apple Developer iOS开发 iOS10推送必看 APNs push notification with macOS Sierra Enabling Apple Push Notifications for ad hoc distribution environment","link":"/2016/11/20/iOSer-iOS-Remote-Push-Summary/"},{"title":"iOS摇一摇","text":"前言简单实现摇一摇功能 环境 &amp; 工具 macOS Sierra 10.12.3Xcode 8.2.1cartool 理论 设置引用允许摇一摇 设置第一响应者 在触发摇一摇后的事件中添加代码即可 实践 先从iTunes中下载一个有摇一摇功能的App,拆包找资源,发现图片资源放在Assets.car中了Google后,发现这个cartool可以,原理是使用了CoreUI.framework中私有方法,因为不管怎么加密,最终的工程中要引用正常的图片,那必定有解密的方法,git下源代码,编译后得到二进制的可执行文件 使用如下指令导出Assets.car中的图片资源 12# 桌面上新建了Assets目录» ~/Desktop ./cartool Assets.car Assets 找到我需要的图片资源 新建工程,编写相应的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657- (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; // 允许摇一摇 [UIApplication sharedApplication].applicationSupportsShakeToEdit = true; // 成为第一响应者 [self becomeFirstResponder]; // 获得图片 _shakeImageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@\"shakeImage\"]]; _shakeImageView.frame = self.view.bounds; _shakeImageView.contentMode = UIViewContentModeScaleAspectFit; [self.view addSubview:_shakeImageView]; // 自动触发摇一摇 [self performSelector:@selector(motionBegan:withEvent:) withObject:nil];}- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event { NSLog(@\"开始摇动\"); [self shakeSender];}- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event { NSLog(@\"取消摇动\");}- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event { if (event.subtype == UIEventSubtypeMotionShake) { // 判断是否是摇动结束 NSLog(@\"摇动结束\"); }}- (void)shakeSender { // 绕着垂直于手机的z轴旋转,呈现的就是摇一摇动画 CABasicAnimation* shake = [CABasicAnimation animationWithKeyPath:@\"transform.rotation.z\"]; // 设置抖动幅度 shake.fromValue = [NSNumber numberWithFloat:-0.2]; shake.toValue = [NSNumber numberWithFloat:+0.2]; shake.duration = 0.2; shake.autoreverses = YES; //是否重复 // 测试时 shake.repeatCount = 99; [_shakeImageView.layer addAnimation:shake forKey:@\"imageView\"]; _shakeImageView.alpha = 1.0; [UIView animateWithDuration:2.0 delay:2.0 options:UIViewAnimationOptionCurveEaseIn animations:^{} completion:nil];} 效果图 工程Demo 参考 iOS「摇一摇」功能的实现 提取assets.car中的图片 .car文件的解压","link":"/2017/03/10/iOSer-iOS-Shake/"},{"title":"理论篇：iOS 应用重签名","text":"导语 在整理阅读:iOS App签名的原理了解了签名的过程，现在重新回头整理一下 iOS 重签名的一些内容。 环境 &amp; 工具 macOS Sierra 10.12.4Xcode 8.3.1 数字签名 数位签章（又称公钥数位签章，英语：Digital Signature ）是一种类似写在纸上的普通的物理签名，但是使用了公钥加密领域的技术实现，用于鉴别数字信息的方法。 在这里指 codesign 的参数 identity ，它的生成是用 SHA-1 算法对整个数字证书内容进行摘要生成的 40 位的 16 进制的字符序列。 Entitlement 在 《深入解析Mac OS X &amp; iOS 操作系统》一书中提到: Entitlement 是一种权限声明机制，从概念上非常像 .Net 和 Java 中使用的声明式权限机制。在 iOS 中 entitlement plist 是直接嵌入在应用程序的二进制中的，并且由苹果进行数字签名 关于 Entitlement 文件是嵌入到应用程序的二进制中的论断，已进行验证。 描述文件 Apple 用于描述与管理应用安装的文件，其中包含了证书，包名，可安装设备等信息。 总结 数字签名: 用于解决已获得授权的应用的完整性 (是否完整) 描述文件: 用于解决应用是否能被授权安装 (是否安装) Entitlement: 用于解决该应用的权限 (是否有权限) 过程分析 一开始不明白没事，总有明白的。关于签名这件事，Xcode 是了解的，因此考虑从它入手。 在 Xcode 上用 ⌘ B 去编译一个 iOS 的工程，通过查看本次运行的日志信息中的签名（Sign）部分。我们可以了解到 iOS 应用开发时的签名工作是由 macOS 上的 codesign 负责的。 “预处理” cd 到工程目录 export CODESIGN_ALLOCATE 定义 CODESIGN_ALLOCATE 环境变量 export PATH : 临时添加 PATH 环境变量，主要为了让 Xcode 中的一些指令能被找到 读取描述文件。 正文: codesign 通过查看 codesign 的 man 手册来确定参数的具体含义 -f, –force When signing, causes codesign to replace any existing signature on the path(s) given. Without this option, existing signatures will not be replaced, and the signing oper-ation fails. 使用 -f，--force 参数会在签名时替换掉原有的签名，大约就是个是否进行覆盖操作的意思。 -s, –sign identity Sign the code at the path(s) given using this identity. See SIGNING IDENTITIES below. SIGNING IDENTITIES To be used for code signing, a digital identity must be stored in a keychain that is on the calling user’s keychain search list. All keychain sources are supported if properly configured. In particular, it is possible to sign code with an identity stored on a supported smart card. If your signing identity is stored in a different form, you need to make it available in keychain form to sign code with it.… 打开钥匙串， 找到签名的数字证书，指令中 identity 的值是 Fingerprints 中 40 位的 16 进制 SHA-1 值。 关于 SHA-1 和 MD5 都是数字签名算法。 Fingerprints 是指纹的意思，算隐含唯一性。 –entitlements path When signing, take the file at the given path and embed its con- tents in the signature as entitlement data. If the data at path does not already begin with a suitable binary (“blob”) header, one is attached automatically. 找到对应路径下的 xxx.app.xcent 文件，具体内容大概如下 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;application-identifier&lt;/key&gt; &lt;string&gt;XXX.包名&lt;/string&gt; &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt; &lt;string&gt;XXX&lt;/string&gt; &lt;key&gt;get-task-allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;keychain-access-groups&lt;/key&gt; &lt;array&gt; &lt;string&gt;XXX.包名&lt;/string&gt; &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt; get-task-allow ：允许其他进程附上该进程，比如开发环境下 Xcode 会用 lldb 附上进程进行调试。已验证过在 AdHoc 包中的该字段也确实会变成 false。 keychain-access-groups ： 为了开发者能用钥匙串在自己的应用间传递信息（比如:密码）。 embedded.mobileprovision (描述文件) 最后生成的包中有 embedded.mobileprovision 文件，这个就是我们从苹果后台下载的描述文件，其中包含了应用的包名，证书，可安装设备，过期时间等等信息，在签名时会被打包到应用中。因为不签名Xcode 无法通过编译，无法验证，因此只是觉得应该是签名操作时生成的。 在重签名过程中，网上会说从自己以前打包的应用里面拷贝，当然是可以的，但是从苹果后台下载要重签名的描述文件，然后重新命名为 embedded.mobileprovision 也是一个方案。 下面是一个 embedded.mobileprovision 的示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;AppIDName&lt;/key&gt; &lt;string&gt;XC Wildcard&lt;/string&gt; &lt;key&gt;ApplicationIdentifierPrefix&lt;/key&gt; &lt;array&gt; &lt;string&gt;ZEY3XXXXXX&lt;/string&gt; &lt;/array&gt; &lt;key&gt;CreationDate&lt;/key&gt; &lt;date&gt;2017-03-08T06:25:32Z&lt;/date&gt; &lt;key&gt;Platform&lt;/key&gt; &lt;array&gt; &lt;string&gt;iOS&lt;/string&gt; &lt;/array&gt; &lt;key&gt;DeveloperCertificates&lt;/key&gt; &lt;array&gt; &lt;data&gt;MIIF...fA=&lt;/data&gt; &lt;data&gt;MIIF...94=&lt;/data&gt; &lt;/array&gt; &lt;key&gt;Entitlements&lt;/key&gt; &lt;dict&gt; &lt;key&gt;keychain-access-groups&lt;/key&gt; &lt;array&gt; &lt;string&gt;ZEY3XXXXXX.*&lt;/string&gt; &lt;/array&gt; &lt;key&gt;get-task-allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;application-identifier&lt;/key&gt; &lt;string&gt;ZEY3XXXXXX.*&lt;/string&gt; &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt; &lt;string&gt;ZEY3XXXXXX&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;ExpirationDate&lt;/key&gt; &lt;date&gt;2018-03-08T06:25:32Z&lt;/date&gt; &lt;key&gt;Name&lt;/key&gt; &lt;string&gt;iOS Team Provisioning Profile: *&lt;/string&gt; &lt;key&gt;ProvisionedDevices&lt;/key&gt; &lt;array&gt; &lt;string&gt;2b8ffa94ec91d9ce9c94da9ad423b88888888888&lt;/string&gt; &lt;/array&gt; &lt;key&gt;TeamIdentifier&lt;/key&gt; &lt;array&gt; &lt;string&gt;ZEY3XXXXXX&lt;/string&gt; &lt;/array&gt; &lt;key&gt;TeamName&lt;/key&gt; &lt;string&gt;Deliang Wang&lt;/string&gt; &lt;key&gt;TimeToLive&lt;/key&gt; &lt;integer&gt;365&lt;/integer&gt; &lt;key&gt;UUID&lt;/key&gt; &lt;string&gt;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&lt;/string&gt; &lt;key&gt;Version&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt;&lt;/dict&gt; 总结 “预处理” 做好一些前期的处理工作（设置环境变量，读取描述文件等） -sign 的 SHA-1 值 ，从钥匙串中找到对应的数字证书 --entitlements 确定应用的权限 codesign 指令对应用的二进制文件，资源，动态库进行签名（二进制的签名保存在自己内部） 安装过程： iOS 设备用验证 embedded.mobileprovision 文件的数字证书，取出其中的公钥，能取出证明经过了苹果服务器的授权，即该公钥是有效的，用该公钥去解密本地私钥加密的信息(_CodeSignature)，得到真实签名值，然后同样计算，验证文件的完整性，完整性通过后就可以安装。 方案 重签名一般就是在苹果认可的体系下: AppStore 分发 开发者调试安装 AdHoc / 企业包分发 让应用顺利安装。 主要是让 iOS 设备认为完整性没有被破坏 关于工具 Apple 已经提供了，就是 codesign 。 说明 一开始我以为重签名并没有太多可以写的内容，毕竟网上关于如何重签名的资料还是挺多的，也有不少优秀的工具可以很方便的完成重签名的操作。 为了让自己确定知道哪些因素会影响重签名，测试(折腾)了挺久才大致了解了点，因为这部分目前比较乱，需要时间去整理，而且实际重签名操作还有一些情况需要考虑: 多 target*，注入 *dylib ，所以打算拆成两篇，把具体的如何重签名的操作在实践篇中再谈谈。 参考 Wiki - 数字签名 What does get-task-allow do in Xcode? Simplifying using Keychain Access Groups","link":"/2017/04/09/iOSer-iOS-application-re-signature-theory-articles/"},{"title":"objc-706工程搭建","text":"环境 macOS 10.12.1Xcode 8.1 代码可编译 &amp; 运行的工程 objc-706 流程源代码下载 macOS10.12.1 objc4-706 编译 -&gt; 失败 -&gt; 编译 -&gt; 失败… 编译 -&gt; 成功✘ ‘sys/reason.h’ file not found (objc-os.h) Q1: 为什么&lt;sys/param.h&gt;可以找到? 按住⌘ 点击进入&lt;sys/param.h&gt; 实际路径 1/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/param.h Q2: 为什么会去找这个路径? A2 : 决定于Build Settings中的Use Standard System Header Directory Searching字段 Controls whether the standard system directories are searched for header files. When disabled, only the directories you have specified with -I options (and the directory of the current file, if appropriate) are searched. 实际目录下确实没有 &lt;sys/reason.h&gt; A1: 实际目录下确实没有 &lt;sys/reason.h&gt; 原来的头文件查找目录在/tmp*下,为了方便,添加路径$(SRCROOT)/include* 在objc-706工程目录中创建一个include目录,将相关的头文件放在这里 Q3: 如何找到对应的头文件 A3: Google ⏎ xxx.h site:opensource.apple.com 比如 reason.h site:opensource.apple.com 结果如下: 看上去应该在xnu这个目录下 根据有sys目录,最后找到 [reason.h](https://opensource.apple.com/source/xnu/xnu-3789.21.4/bsd/sys/reason.h) 更好的方法是将整个目录下载下来通过 find/grep 指令去查找 12$ find ~/Downloads/objc-res/xnu-3789.21.4/* -name \"reason.h\"/Users/Jason/Downloads/objc-res/xnu-3789.21.4/bsd/sys/reason.h* 在include下创建sys目录 将reason.h拷贝到sys目录下 ⌘ + B* ✘ mach-o/dyld_priv.h file not found (objc-os.h)dyld_priv.h ⌘ + B ✘ os/lock_private.h file not found (objc-os.h) 没找到换个思路,改搜github 比较过,两个都是一样的,选择一个即可lock_private.hlock_private.h ⌘ + B ✘ ‘System/pthread_machdep.h’ file not found (objc-os.h) 应该在Libc中 但macOS10.12.1的Libc-1158.20.4并没有pthreads目录,找以前的版本,在Libc-825.40.1找到了pthread目录 pthread_machdep.h 在include目录下新建System目录,拷贝pthread_machdep.h到该目录下 ⌘ + B ✘ System/machine/cpu_capabilities.h file not found (pthread_machdep.h)cpu_capabilities.h 在System目录下新建machine目录,拷贝cpu_capabilities.h到该目录下 ⌘ + B ✘ CrashReporterClient.h file not found (objc-os.h)在Libc-825.40.1中存在CrashReporterClient.h 将其拷贝到include目录下 ⌘ + B ✘ CrashReporterClient.h file not found (CrashReporterClient.h)#include_next 包含指定文件所在的路径的后面路径的那个文件 例如有个搜索路径链，在#include中，它们的搜索顺序依次是A，B，C，D和E。在B目录中有个头文件叫a.h，在D目录中也有个头文件叫a.h，如果在我们的源代码中这样写#include &lt;a.h&gt;，那么我们就会包含的是B目录中的a.h头文件，如果我们这样写#include_next &lt;a.h&gt;那么我们就会包含的是D目录中的a.h头文件 代码有如下注释 1/* Include the real CrashReporterClient.h */ 但我们没有真正的CrashReporterClient.h Build Settings-&gt;Preprocessor Macros（Debug &amp; Release）加入: LIBC_NO_LIBCRASHREPORTERCLIENT ⌘ + B 错误就有些多了 参考 objc - 编译Runtime源码将需要的压缩包先下载下来 先解决.h没有的问题 ✘ phread/workqueue_private.h file not found (objc-os.h)✔︎ ./libpthread-218.20.1/private/workqueue_private.h在include目录下新建pthread目录,拷贝workqueue_private.h到pthread目录中⌘ + B ✘ pthread/qos_private.h file not found (objc-os.h)./libpthread-218.20.1/private/qos_private.h✔︎ ./libpthread-218.20.1/sys/qos_private.h⌘ + B ✘ sys/qos_private.h file not found (objc-os.h)./libpthread-218.20.1/private/qos_private.h✔︎ ./libpthread-218.20.1/sys/qos_private.h⌘ + B ✘ objc-shared-cache.h file not found (objc-os.h)✔︎ ./dyld-421.2/include/objc-shared-cache.h⌘ + B 终于不报xxx.h not found的错误了 继续,解决变量未定义的问题 用grep的方式去找出来 1$ grep -rne \"#define.*_PTHREAD_TSD_SLOT_MACH_THREAD_SELF\" . ✔︎ /libpthread-218.20.1/private/tsd_private.h workqueue_private.h*也是来自于/libpthread-218.20.1/private,拷贝到了pthread目录下,将tsd_private.h也拷贝至pthread*目录下 还是报错,仔细检查objc-os.h 发现并未引入tsd_private.h头文件 在第34行上下加一句 1#include &lt;pthread/tsd_private.h&gt; ⌘ + B ✘ ‘os/tsd.h’ file not found (tsd_private.h)./libdispatch-703.20.1/src/shims/tsd.h✔︎ ./xnu-3789.21.4/libsyscall/os/tsd.h⌘ + B ✘ ‘pthread/spinlock_private.h’ file not found (tsd_private.h)✔︎./libpthread-218.20.1/private/spinlock_private.h⌘ + B 错误”变多了”,看警告,发现重复定义了,参考上面的blog 重复定义了pthread_lock_t，切换到Terminal，⌘+T打开新的一个Tab，cd到objc4-680/include/那grep一下就好了:cd ../objc4-680/include/grep -rne “typedef.*pthread_lock_t” .结果:./pthread/spinlock_private.h:59:typedef volatile OSSpinLock pthread_lock_t;./System/pthread_machdep.h:214:typedef int pthread_lock_t;从结果发现我们之前引入的pthread_machdep.h已经typedef过了。注释掉其中一个就好。但我这里选择注释掉pthread_machdep.h的，在Line 214：//typedef int pthread_lock_t;为什么是它呢？因为它是我们从Libc拷过来的，而Libc我们下载了较旧的版本。… 因此注释掉pthread_machdep.h中重定义的部分 根据重定义pthread_lock_t的错误 1$ grep -rne \"typedef.*pthread_lock_t\" . ./Libc-825.40.1/fbsdcompat/spinlock.h:65:typedef pthread_lock_t spinlock_t;./Libc-825.40.1/pthreads/pthread_machdep.h:214:typedef int pthread_lock_t;✔︎ ./libpthread-218.20.1/private/spinlock_private.h:59:typedef volatile OSSpinLock pthread_lock_t __deprecated_msg(“Use &lt;os/lock.h&gt; instead”);./libpthread-218.20.1/tests/cond_hang3.c:14:typedef long pthread_lock_t; ⌘ + B ✘ Unknown type name ‘pthread_priority_t’ (objc-os.h)1$ grep -rne \"pthread_priority_t;\" . ./libdispatch-703.20.1/src/shims.h:42:typedef unsigned long pthread_priority_t;./libdispatch-703.20.1/src/shims.h:80:typedef unsigned long pthread_priority_t;✔︎ ./libpthread-218.20.1/private/qos_private.h:38:typedef unsigned long pthread_priority_t; 1#include &lt;pthread/qos_private.h&gt; ⌘ + B 1$ grep -rne \"os_unfair_lock\" . ./libpthread-218.20.1/src/internal.h:105:typedef os_unfair_lock _pthread_lock;./libpthread-218.20.1/src/internal.h:108:#define _PTHREAD_LOCK(lock) os_unfair_lock_lock_with_options_inline(&amp;(lock), OS_UNFAIR_LOCK_DATA_SYNCHRONIZATION)./libpthread-218.20.1/src/internal.h:109:#define _PTHREAD_LOCK_FROM_MACH_THREAD(lock) os_unfair_lock_lock_inline_no_tsd_4libpthread(&amp;(lock))./libpthread-218.20.1/src/internal.h:110:#define _PTHREAD_UNLOCK(lock) os_unfair_lock_unlock_inline(&amp;(lock))./libpthread-218.20.1/src/internal.h:111:#define _PTHREAD_UNLOCK_FROM_MACH_THREAD(lock) os_unfair_lock_unlock_inline_no_tsd_4libpthread(&amp;(lock)) 这里路径是src,有点不一样,先不要引入internal.h,先Google一下,os_unfair_lock OSSpinlock is depreciatedos_unfair_lock 是个结构体,在facebook/folly - macOS Sierra issues中提到了warning: ‘OSSpinLockUnlock’ is deprecated: first deprecated in macOS 10.12 - Use os_unfair_lock_unlock() from &lt;os/lock.h&gt; instead [-Wdeprecated-declarations] 所以引入 1#include &lt;os/lock.h&gt; ⌘ + B grep后发现又在internal.h中,根据lock.h,修改一下lock() &amp; unlock()方法 修改后 ⌘ + B ✘ ‘_simple.h’ file not found (objc-errors.mm)✔︎ ./Libc-825.40.1/gen/_simple.h⌘ + B ✘ Use of undeclared identifier ‘os_unfair_lock_assert_owner’ (objc-lockdebug.mm)1$ grep -rne \"os_unfair_lock_assert_owner\" . 没有匹配项 Google了未发现,先将该函数的功能修改为输出日志 ⌘ + B ✘ ‘Block_private.h’ file not found (objc-block-trampolines.mm)✔︎ ./libclosure-67/Block_private.h⌘ + B 链接动态库的时候不能打开libobjc.order,查看在对应路径下并没有libobjc.order文件,发现objc工程已经有libobjc.order,应该会有字段说明要引用的路径,想办法让工程引入本身的libobjc.order文件 最后找到Build Settings的Order File 将该字段统一修改为$(PROJECT_DIR)/libobjc.order ⌘ + B 因为工程中并没有CrashReporterClient的库将Other Linker flags*中的-lCrashReporterClient参数去掉*⌘ + B** 终于编译成功了☺,然后创建一个debug-objc的target,导入修改的libobjc.A.dylib ⌘ + R正常运行并输出,lockdebug_mutex_assert_locked被调用了很多次,但不会影响,可注释掉它的输出 OK,已经可以进行调试了 续可以调试,但是在debug-objc工程中还是无法访问objc_class 进行以下操作 添加代码 123objc_class *obj_1 = (objc_class *)[NSObject class];objc_class *obj_2 = (objc_class *)[NSString class];NSLog(@\"%p,%p\",obj_1,obj_2); main.m 引入#import “objc-private.h” // 会报错 main.m -&gt; main.mm 因为 objc-private.h 是objetive-c++类型的 CrashReporterClient.h 报错 -&gt; 同 objc-706 工程类似处理,在 buildsetting ,设置LIBC_NO_LIBCRASHREPORTERCLIENT objc-probes.h file not found =&gt; 从网上找到文件放到工程的 include 目录,并在 debug-objc 添加 $(SRCROOT)/include maptable.h file not found(&lt;objc/maptable.h&gt;) =&gt; 从网上找到文件后放到工程的 include/objc(目录没有要创建) 编译成功 截图如下: 参考 gcc：预处理语句－－#include和#include_next Apple开源 objc - 编译Runtime源码","link":"/2017/02/11/iOSer-objc-706-project-structures/"},{"title":"objc4-709工程搭建","text":"导语objc 运行时的最新版本为 709 ，一回生,二回熟，简单的记录一下过程。 环境 &amp; 工具 macOS Sierra 10.12.4Xcode 8.3.2objc-709搭建 objc-706 时的头文件 流程✘ 'sys/reason.h’ file not found (objc-os.h) 因为打算把缺少的头文件统一放到工程下的 include 目录下,因此在 Building Setting &gt; Header Search Paths 添加 $(SRCROOT)/include 字段 12➜ cd /path/to/objc4-709➜ objc4-709 mkdir -p include/sys 递归创建目录,将 reason.h 拷贝到 sys 目录中 ✘ mach-o/dyld_priv.h file not found (objc-os.h)同理,创建 mach-o 目录 &amp; 拷贝 dyld_priv.h 到 mach-o 中 ✘ os/lock_private.h file not found (objc-os.h)创建目录 &amp; 拷贝 lock_private.h ✘ 'System/pthread_machdep.h’ file not found (objc-os.h)创建目录 &amp; 拷贝 pthread_machdep.h ✘ System/machine/cpu_capabilities.h file not found (pthread_machdep.h)创建目录 &amp; 拷贝 cpu_capabilities.h ✘ CrashReporterClient.h file not found (objc-os.h)创建目录 &amp; 拷贝 cpu_capabilities.h ✘ CrashReporterClient.h file not found (CrashReporterClient.h)根据 objc-706 的经验 在 Build Settings-&gt;Preprocessor Macros（Debug &amp; Release） 加入: LIBC_NO_LIBCRASHREPORTERCLIENT 编译报了很多错,先解决缺少头文件的问题 ✘ phread/workqueue_private.h file not found (objc-os.h)创建目录 &amp; 拷贝 workqueue_private.h ✘ pthread/qos_private.h file not found (objc-os.h)拷贝 qos_private.h 到 pthread 目录 ✘ sys/qos_private.h file not found (objc-os.h)拷贝 qos_private.h 到 sys 目录 ✘ objc-shared-cache.h file not found (objc-os.h)拷贝 objc-shared-cache.h 到 include 目录，不报缺少头文件的错误了，继续解决变量未定义的问题，用 grep 的方式去找出来 1➜ grep -rne \"#define.*_PTHREAD_TSD_SLOT_MACH_THREAD_SELF\" . ✔︎ /libpthread-218.20.1/private/tsd_private.h workqueue_private.h 也是来自于 /libpthread-218.20.1/private ,已拷贝到 pthread 目录,将 tsd_private.h 也拷贝至pthread目录下 还是报错,检查 objc-os.h 发现并未引入 tsd_private.h 头文件 在第 34 行上下加一句 1#include &lt;pthread/tsd_private.h&gt; ✘ 'os/tsd.h’ file not found (tsd_private.h)拷贝 tsd.h 到 os 目录 ✘ 'pthread/spinlock_private.h’ file not found (tsd_private.h)拷贝 spinlock_private.h 到 pthread 目录 因为我拷贝的是原来自己已经处理过的文件,所以没有出现重复定义的错误 ✘ Unknown type name 'pthread_priority_t’ (objc-os.h) 引入 qos_private.h 头文件，如下所示 1234567891011#include &lt;pthread/qos_private.h&gt;#if SUPPORT_QOS_HACKstatic inline pthread_priority_t pthread_self_priority_direct() { pthread_priority_t pri = (pthread_priority_t) _pthread_getspecific_direct(_PTHREAD_TSD_SLOT_PTHREAD_QOS_CLASS); return pri &amp; ~_PTHREAD_PRIORITY_FLAGS_MASK;}#endif ✘ Unknown type name 'os_unfair_lock (objc-os.h)'同样的问题,已经在 objc-706 中出现过了 解决方法是: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include \"objc-lockdebug.h\"// 引入这个文件#include &lt;os/lock.h&gt;template &lt;bool Debug&gt;class mutex_tt : nocopy_t { os_unfair_lock mLock; public: mutex_tt() : mLock(OS_UNFAIR_LOCK_INIT) { }// void lock() {// lockdebug_mutex_lock(this);//// os_unfair_lock_lock(&amp;mLock);// os_unfair_lock_lock_with_options_inline// (&amp;mLock, OS_UNFAIR_LOCK_DATA_SYNCHRONIZATION);// }// void unlock() {// lockdebug_mutex_unlock(this);//// os_unfair_lock_unlock_inline(&amp;mLock);// } void lock() { lockdebug_mutex_lock(this); os_unfair_lock_lock(&amp;mLock); } void unlock() { lockdebug_mutex_unlock(this); os_unfair_lock_unlock(&amp;mLock); } void assertLocked() { lockdebug_mutex_assert_locked(this); } void assertUnlocked() { lockdebug_mutex_assert_unlocked(this); } // Address-ordered lock discipline for a pair of locks. static void lockTwo(mutex_tt *lock1, mutex_tt *lock2) { if (lock1 &gt; lock2) { lock1-&gt;lock(); lock2-&gt;lock(); } else { lock2-&gt;lock(); if (lock2 != lock1) lock1-&gt;lock(); } } static void unlockTwo(mutex_tt *lock1, mutex_tt *lock2) { lock1-&gt;unlock(); if (lock2 != lock1) lock2-&gt;unlock(); }}; ✘ '_simple.h’ file not found (objc-errors.mm)拷贝 _simple.h 到 include 目录 ✘ 'Block_private.h’ file not found (objc-block-trampolines.mm)拷贝 Block_private.h 到 include 目录 报 libobjc.order 链接失败 解决办法是将 Building Settings 中的 Order File 的字段 改为 $(PROJECT_DIR)/libobjc.order 因为工程中并没有 CrashReporterClient 的库将 Other Linker flags 中的 -lCrashReporterClient 参数去掉 编译通过 创建一个 debug-objc 的 target ,导入修改的 libobjc.A.dylib，就又可以愉快的调试了。 objc-709 参考 objc-706工程搭建","link":"/2017/05/05/iOSer-objc-709-project-structures/"},{"title":"Windows与Mac端数据共享","text":"背景在win上访问外部的网站网速比较快,但是日常开发又在macbook上,因此需要两台电脑能数据共享，一开始是想通过微信的,但是同一个账号不能同时登陆；用网盘传输之类的，又要额外下载应用或者依赖浏览器。既然是个人使用,可以直接在win上创建共享目录来解决。 操作设置共享目录在win上设置个人目录 用ipconfig命令获取win的内网IP 访问在mac上使用Finder 输入 smb://win的IP 填写用户名 + 密码登陆成功后，选择要访问的共享目录 最后就能挂载成功，实现win与mac间的文件共享","link":"/2025/03/28/Technology-win-mac-brige/"},{"title":"学习笔记 - Flask - 02","text":"前言待业家中继续学习。 Flask 项目结构1234567891011121314151617181920212223my_flask_app/│├── app/│ ├── __init__.py│ ├── routes/ -- 将不同功能模块的路由分开管理│ │ ├── __init__.py│ │ ├── main.py -- 主模块的路由│ │ └── auth.py -- 认证相关的路由│ ├── models/ -- 管理数据模型,通常与数据操作相关│ │ ├── __init__.py │ │ └── user.py -- 用户模型│ ├── templates/ -- 存放 HTML 模板文件│ │ ├── layout.html -- 布局相关│ │ └── home.html│ └── static/ -- 存放静态文件,如CSS和JavaScript│ ├── css/│ └── js/│├── config.py -- 配置文件,包含应用的配置信息├── requirements.txt -- 列出项目的依赖库├── migrations/│ └── ...└── run.py -- 用于启动Flask应用 如何在Trae IDE中配置Python解释器看到app.py 报错,因为没有导入flask库,但我的设备已经安装了,所以应该是需要配置下。在设置中找半天没有找到,后来搜索才知道原来是在Editor中，搜索python,然后将 Python: Default Interpreter Path的路径设置为设备安装的路径。 藏的有点深,可能从产品的角度上看是不想局限在某种语言,可以在Editor设置的说明文案部分增加编译器,解释器。 路由Flask 路由是Flask应用的核心部分，用于处理不同URL的请求，并将请求的处理委托给相应的视图函数 路由的相关说明 定义路由: 使用 @app.route(‘/path’) 装饰器定义URL和视图函数的映射。 路由参数: 通过动态部分在URL中传递参数的类型 路由规则: 使用类型转换器指定URL参数的类型 请求方法: 指定允许的HTTP请求方法。（GET,POST,DELETE,PUT) 路由函数返回: 视图函数可以返回不同类型的响应 静态文件和模板: 管理静态文件和动态渲染 HTML 模板 路由优先级: 确保路由顺序正确，以避免意外的匹配结果 定义路由12345678910from flask import Flaskapp = Flask(__name__)@app.route('/') # 装饰器，用于定义路由。/ 表示根 URLdef home(): return 'Welcome to the Home Page!'if __name__ == '__main__': app.run(debug=True) 路由参数12345678...@app.route('/greet/&lt;name&gt;') # 动态路由，&lt;name&gt; 是一个变量def greet(name): return f'Hello, {name}!'if __name__ == '__main__': app.run(debug=True) 路由规则路由规则支持不同 字符串(默认): 匹配任意字符串 整数(int:name): 匹配整数值 浮点数float:value): 匹配浮点数值 path(path:name): 匹配任意字符，包括斜杆/ 12345678910111213141516171819202122# 访问/user/1 能正常输出User ID:1@app.route('/user/&lt;int:user_id&gt;')def user_profile(user_id): return f'User ID: {user_id}'# 访问/user/1 能正常输出User ID:1@app.route('/user/&lt;user_id&gt;')def user_profile(user_id): return f'User ID: {user_id}'# 访问/user/1 int和user_id同时存在时走int@app.route('/user/&lt;user_id&gt;')def user_profile2(user_id): return f'User ID2: {user_id}' # 换成float，访问/user/1# Not Found# The requested URL was not found on the server. If you entered the URL # manually please check your spelling and try again.@app.route('/user/&lt;float:user_id&gt;')def user_profile(user_id): return f'User ID: {user_id}' 请求方法Flask 路由支持不同的 HTTP 请求方法，如 GET、POST、PUT、DELETE 等。可以通过 methods 参数指定允许的请求方法。 123@app.route('/submit', methods=['POST'])def submit(): return 'Form submitted!' 此时设置了是POST请求，如果用Trae自带的浏览器访问,因为实际是GET请求,会报405错误码不允许 使用postman发送post请求验证能获得正常的返回 路由函数返回 字符串: 返回纯文本响应 HTML: 返回HTML页面 JSON: 返回JSON数据 Response对象: 自定义响应 123456789101112from flask import jsonify, Response@app.route('/json')def json_response(): data = {'key': 'value'} return jsonify(data)@app.route('/custom')def custom_response(): response = Response('Custom response with headers', status=200) response.headers['X-Custom-Header'] = 'Value' return response 返回json 返回自定义响应 静态文件和模板静态文件（如 CSS、JavaScript、图片）可以通过 static 路由访问。模板文件则通过 templates 文件夹组织，用于渲染 HTML 页面。 styles.css 1&lt;link rel=\"stylesheet\" href=\"{{ url_for('static', filename='styles.css') }}\"&gt; 123p { color: #940f0f;} 这个格式默认是在找工程下的static目录下的styles.css app.py 123@app.route('/tutorial02/&lt;name&gt;')def hello(name): return render_template('02.html', name=name) 02.html 1234567891011121314&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;link rel=\"stylesheet\" href=\"{{ url_for('static', filename='styles.css') }}\"&gt; &lt;title&gt;02&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;02&lt;/h1&gt; &lt;p&gt; {{ name }} &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 路由优先级Flask 按照定义的顺序匹配路由，第一个匹配成功的路由将被处理。确保更具体的路由放在更一般的路由之前。 1234567@app.route('/user/&lt;int:user_id&gt;')def user_profile(user_id): return f'User ID: {user_id}'@app.route('/user')def user_list(): return 'User List' /user/123 将匹配到 /user/&lt;int:user_id&gt;，而 /user 将匹配到 user_list。 参考 Flask项目结构 Flask路由","link":"/2025/04/01/Technology-learn-flask-02/"}],"tags":[],"categories":[{"name":"Technology","slug":"Technology","link":"/categories/Technology/"},{"name":"iOSer","slug":"iOSer","link":"/categories/iOSer/"},{"name":"Clang","slug":"Clang","link":"/categories/Clang/"}]}